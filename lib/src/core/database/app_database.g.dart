// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'app_database.dart';

// ignore_for_file: type=lint
class $GrimoireTableTable extends GrimoireTable
    with TableInfo<$GrimoireTableTable, GrimoireTableData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $GrimoireTableTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _uuidMeta = const VerificationMeta('uuid');
  @override
  late final GeneratedColumn<String> uuid = GeneratedColumn<String>(
    'uuid',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
    'name',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _descMeta = const VerificationMeta('desc');
  @override
  late final GeneratedColumn<String> desc = GeneratedColumn<String>(
    'desc',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _iconAssetMeta = const VerificationMeta(
    'iconAsset',
  );
  @override
  late final GeneratedColumn<String> iconAsset = GeneratedColumn<String>(
    'icon_asset',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<int> createdAt = GeneratedColumn<int>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _updatedAtMeta = const VerificationMeta(
    'updatedAt',
  );
  @override
  late final GeneratedColumn<int> updatedAt = GeneratedColumn<int>(
    'updated_at',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  @override
  List<GeneratedColumn> get $columns => [
    uuid,
    name,
    desc,
    iconAsset,
    createdAt,
    updatedAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'grimoire_table';
  @override
  VerificationContext validateIntegrity(
    Insertable<GrimoireTableData> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('uuid')) {
      context.handle(
        _uuidMeta,
        uuid.isAcceptableOrUnknown(data['uuid']!, _uuidMeta),
      );
    } else if (isInserting) {
      context.missing(_uuidMeta);
    }
    if (data.containsKey('name')) {
      context.handle(
        _nameMeta,
        name.isAcceptableOrUnknown(data['name']!, _nameMeta),
      );
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    if (data.containsKey('desc')) {
      context.handle(
        _descMeta,
        desc.isAcceptableOrUnknown(data['desc']!, _descMeta),
      );
    }
    if (data.containsKey('icon_asset')) {
      context.handle(
        _iconAssetMeta,
        iconAsset.isAcceptableOrUnknown(data['icon_asset']!, _iconAssetMeta),
      );
    } else if (isInserting) {
      context.missing(_iconAssetMeta);
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    } else if (isInserting) {
      context.missing(_createdAtMeta);
    }
    if (data.containsKey('updated_at')) {
      context.handle(
        _updatedAtMeta,
        updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta),
      );
    } else if (isInserting) {
      context.missing(_updatedAtMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {uuid};
  @override
  GrimoireTableData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return GrimoireTableData(
      uuid: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}uuid'],
      )!,
      name: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}name'],
      )!,
      desc: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}desc'],
      ),
      iconAsset: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}icon_asset'],
      )!,
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}created_at'],
      )!,
      updatedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}updated_at'],
      )!,
    );
  }

  @override
  $GrimoireTableTable createAlias(String alias) {
    return $GrimoireTableTable(attachedDatabase, alias);
  }
}

class GrimoireTableData extends DataClass
    implements Insertable<GrimoireTableData> {
  final String uuid;
  final String name;
  final String? desc;
  final String iconAsset;
  final int createdAt;
  final int updatedAt;
  const GrimoireTableData({
    required this.uuid,
    required this.name,
    this.desc,
    required this.iconAsset,
    required this.createdAt,
    required this.updatedAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['uuid'] = Variable<String>(uuid);
    map['name'] = Variable<String>(name);
    if (!nullToAbsent || desc != null) {
      map['desc'] = Variable<String>(desc);
    }
    map['icon_asset'] = Variable<String>(iconAsset);
    map['created_at'] = Variable<int>(createdAt);
    map['updated_at'] = Variable<int>(updatedAt);
    return map;
  }

  GrimoireTableCompanion toCompanion(bool nullToAbsent) {
    return GrimoireTableCompanion(
      uuid: Value(uuid),
      name: Value(name),
      desc: desc == null && nullToAbsent ? const Value.absent() : Value(desc),
      iconAsset: Value(iconAsset),
      createdAt: Value(createdAt),
      updatedAt: Value(updatedAt),
    );
  }

  factory GrimoireTableData.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return GrimoireTableData(
      uuid: serializer.fromJson<String>(json['uuid']),
      name: serializer.fromJson<String>(json['name']),
      desc: serializer.fromJson<String?>(json['desc']),
      iconAsset: serializer.fromJson<String>(json['iconAsset']),
      createdAt: serializer.fromJson<int>(json['createdAt']),
      updatedAt: serializer.fromJson<int>(json['updatedAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'uuid': serializer.toJson<String>(uuid),
      'name': serializer.toJson<String>(name),
      'desc': serializer.toJson<String?>(desc),
      'iconAsset': serializer.toJson<String>(iconAsset),
      'createdAt': serializer.toJson<int>(createdAt),
      'updatedAt': serializer.toJson<int>(updatedAt),
    };
  }

  GrimoireTableData copyWith({
    String? uuid,
    String? name,
    Value<String?> desc = const Value.absent(),
    String? iconAsset,
    int? createdAt,
    int? updatedAt,
  }) => GrimoireTableData(
    uuid: uuid ?? this.uuid,
    name: name ?? this.name,
    desc: desc.present ? desc.value : this.desc,
    iconAsset: iconAsset ?? this.iconAsset,
    createdAt: createdAt ?? this.createdAt,
    updatedAt: updatedAt ?? this.updatedAt,
  );
  GrimoireTableData copyWithCompanion(GrimoireTableCompanion data) {
    return GrimoireTableData(
      uuid: data.uuid.present ? data.uuid.value : this.uuid,
      name: data.name.present ? data.name.value : this.name,
      desc: data.desc.present ? data.desc.value : this.desc,
      iconAsset: data.iconAsset.present ? data.iconAsset.value : this.iconAsset,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('GrimoireTableData(')
          ..write('uuid: $uuid, ')
          ..write('name: $name, ')
          ..write('desc: $desc, ')
          ..write('iconAsset: $iconAsset, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode =>
      Object.hash(uuid, name, desc, iconAsset, createdAt, updatedAt);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is GrimoireTableData &&
          other.uuid == this.uuid &&
          other.name == this.name &&
          other.desc == this.desc &&
          other.iconAsset == this.iconAsset &&
          other.createdAt == this.createdAt &&
          other.updatedAt == this.updatedAt);
}

class GrimoireTableCompanion extends UpdateCompanion<GrimoireTableData> {
  final Value<String> uuid;
  final Value<String> name;
  final Value<String?> desc;
  final Value<String> iconAsset;
  final Value<int> createdAt;
  final Value<int> updatedAt;
  final Value<int> rowid;
  const GrimoireTableCompanion({
    this.uuid = const Value.absent(),
    this.name = const Value.absent(),
    this.desc = const Value.absent(),
    this.iconAsset = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  GrimoireTableCompanion.insert({
    required String uuid,
    required String name,
    this.desc = const Value.absent(),
    required String iconAsset,
    required int createdAt,
    required int updatedAt,
    this.rowid = const Value.absent(),
  }) : uuid = Value(uuid),
       name = Value(name),
       iconAsset = Value(iconAsset),
       createdAt = Value(createdAt),
       updatedAt = Value(updatedAt);
  static Insertable<GrimoireTableData> custom({
    Expression<String>? uuid,
    Expression<String>? name,
    Expression<String>? desc,
    Expression<String>? iconAsset,
    Expression<int>? createdAt,
    Expression<int>? updatedAt,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (uuid != null) 'uuid': uuid,
      if (name != null) 'name': name,
      if (desc != null) 'desc': desc,
      if (iconAsset != null) 'icon_asset': iconAsset,
      if (createdAt != null) 'created_at': createdAt,
      if (updatedAt != null) 'updated_at': updatedAt,
      if (rowid != null) 'rowid': rowid,
    });
  }

  GrimoireTableCompanion copyWith({
    Value<String>? uuid,
    Value<String>? name,
    Value<String?>? desc,
    Value<String>? iconAsset,
    Value<int>? createdAt,
    Value<int>? updatedAt,
    Value<int>? rowid,
  }) {
    return GrimoireTableCompanion(
      uuid: uuid ?? this.uuid,
      name: name ?? this.name,
      desc: desc ?? this.desc,
      iconAsset: iconAsset ?? this.iconAsset,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (uuid.present) {
      map['uuid'] = Variable<String>(uuid.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    if (desc.present) {
      map['desc'] = Variable<String>(desc.value);
    }
    if (iconAsset.present) {
      map['icon_asset'] = Variable<String>(iconAsset.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<int>(createdAt.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<int>(updatedAt.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('GrimoireTableCompanion(')
          ..write('uuid: $uuid, ')
          ..write('name: $name, ')
          ..write('desc: $desc, ')
          ..write('iconAsset: $iconAsset, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $MagicCharacterTableTable extends MagicCharacterTable
    with TableInfo<$MagicCharacterTableTable, MagicCharacterTableData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $MagicCharacterTableTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _magicIdMeta = const VerificationMeta(
    'magicId',
  );
  @override
  late final GeneratedColumn<int> magicId = GeneratedColumn<int>(
    'magic_id',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _uuidMeta = const VerificationMeta('uuid');
  @override
  late final GeneratedColumn<String> uuid = GeneratedColumn<String>(
    'uuid',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _grimoireUUidMeta = const VerificationMeta(
    'grimoireUUid',
  );
  @override
  late final GeneratedColumn<String> grimoireUUid = GeneratedColumn<String>(
    'grimoire_u_uid',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
    'name',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _descMeta = const VerificationMeta('desc');
  @override
  late final GeneratedColumn<String> desc = GeneratedColumn<String>(
    'desc',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _circleLevelMeta = const VerificationMeta(
    'circleLevel',
  );
  @override
  late final GeneratedColumn<int> circleLevel = GeneratedColumn<int>(
    'circle_level',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _typeIndexMeta = const VerificationMeta(
    'typeIndex',
  );
  @override
  late final GeneratedColumn<int> typeIndex = GeneratedColumn<int>(
    'type_index',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _schoolIndexMeta = const VerificationMeta(
    'schoolIndex',
  );
  @override
  late final GeneratedColumn<int> schoolIndex = GeneratedColumn<int>(
    'school_index',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _executionIndexMeta = const VerificationMeta(
    'executionIndex',
  );
  @override
  late final GeneratedColumn<int> executionIndex = GeneratedColumn<int>(
    'execution_index',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _durationIndexMeta = const VerificationMeta(
    'durationIndex',
  );
  @override
  late final GeneratedColumn<int> durationIndex = GeneratedColumn<int>(
    'duration_index',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _rangeIndexMeta = const VerificationMeta(
    'rangeIndex',
  );
  @override
  late final GeneratedColumn<int> rangeIndex = GeneratedColumn<int>(
    'range_index',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _resistenceMeta = const VerificationMeta(
    'resistence',
  );
  @override
  late final GeneratedColumn<String> resistence = GeneratedColumn<String>(
    'resistence',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _targetAreaEfectMeta = const VerificationMeta(
    'targetAreaEfect',
  );
  @override
  late final GeneratedColumn<String> targetAreaEfect = GeneratedColumn<String>(
    'target_area_efect',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _publicationMeta = const VerificationMeta(
    'publication',
  );
  @override
  late final GeneratedColumn<String> publication = GeneratedColumn<String>(
    'publication',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _pmMeta = const VerificationMeta('pm');
  @override
  late final GeneratedColumn<int> pm = GeneratedColumn<int>(
    'pm',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _cdMeta = const VerificationMeta('cd');
  @override
  late final GeneratedColumn<int> cd = GeneratedColumn<int>(
    'cd',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _mediumDamageValueMeta = const VerificationMeta(
    'mediumDamageValue',
  );
  @override
  late final GeneratedColumn<int> mediumDamageValue = GeneratedColumn<int>(
    'medium_damage_value',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _damageDicesMeta = const VerificationMeta(
    'damageDices',
  );
  @override
  late final GeneratedColumn<String> damageDices = GeneratedColumn<String>(
    'damage_dices',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _extraDamageDicesMeta = const VerificationMeta(
    'extraDamageDices',
  );
  @override
  late final GeneratedColumn<String> extraDamageDices = GeneratedColumn<String>(
    'extra_damage_dices',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  @override
  List<GeneratedColumn> get $columns => [
    magicId,
    uuid,
    grimoireUUid,
    name,
    desc,
    circleLevel,
    typeIndex,
    schoolIndex,
    executionIndex,
    durationIndex,
    rangeIndex,
    resistence,
    targetAreaEfect,
    publication,
    pm,
    cd,
    mediumDamageValue,
    damageDices,
    extraDamageDices,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'magic_character_table';
  @override
  VerificationContext validateIntegrity(
    Insertable<MagicCharacterTableData> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('magic_id')) {
      context.handle(
        _magicIdMeta,
        magicId.isAcceptableOrUnknown(data['magic_id']!, _magicIdMeta),
      );
    } else if (isInserting) {
      context.missing(_magicIdMeta);
    }
    if (data.containsKey('uuid')) {
      context.handle(
        _uuidMeta,
        uuid.isAcceptableOrUnknown(data['uuid']!, _uuidMeta),
      );
    } else if (isInserting) {
      context.missing(_uuidMeta);
    }
    if (data.containsKey('grimoire_u_uid')) {
      context.handle(
        _grimoireUUidMeta,
        grimoireUUid.isAcceptableOrUnknown(
          data['grimoire_u_uid']!,
          _grimoireUUidMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_grimoireUUidMeta);
    }
    if (data.containsKey('name')) {
      context.handle(
        _nameMeta,
        name.isAcceptableOrUnknown(data['name']!, _nameMeta),
      );
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    if (data.containsKey('desc')) {
      context.handle(
        _descMeta,
        desc.isAcceptableOrUnknown(data['desc']!, _descMeta),
      );
    } else if (isInserting) {
      context.missing(_descMeta);
    }
    if (data.containsKey('circle_level')) {
      context.handle(
        _circleLevelMeta,
        circleLevel.isAcceptableOrUnknown(
          data['circle_level']!,
          _circleLevelMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_circleLevelMeta);
    }
    if (data.containsKey('type_index')) {
      context.handle(
        _typeIndexMeta,
        typeIndex.isAcceptableOrUnknown(data['type_index']!, _typeIndexMeta),
      );
    } else if (isInserting) {
      context.missing(_typeIndexMeta);
    }
    if (data.containsKey('school_index')) {
      context.handle(
        _schoolIndexMeta,
        schoolIndex.isAcceptableOrUnknown(
          data['school_index']!,
          _schoolIndexMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_schoolIndexMeta);
    }
    if (data.containsKey('execution_index')) {
      context.handle(
        _executionIndexMeta,
        executionIndex.isAcceptableOrUnknown(
          data['execution_index']!,
          _executionIndexMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_executionIndexMeta);
    }
    if (data.containsKey('duration_index')) {
      context.handle(
        _durationIndexMeta,
        durationIndex.isAcceptableOrUnknown(
          data['duration_index']!,
          _durationIndexMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_durationIndexMeta);
    }
    if (data.containsKey('range_index')) {
      context.handle(
        _rangeIndexMeta,
        rangeIndex.isAcceptableOrUnknown(data['range_index']!, _rangeIndexMeta),
      );
    } else if (isInserting) {
      context.missing(_rangeIndexMeta);
    }
    if (data.containsKey('resistence')) {
      context.handle(
        _resistenceMeta,
        resistence.isAcceptableOrUnknown(data['resistence']!, _resistenceMeta),
      );
    } else if (isInserting) {
      context.missing(_resistenceMeta);
    }
    if (data.containsKey('target_area_efect')) {
      context.handle(
        _targetAreaEfectMeta,
        targetAreaEfect.isAcceptableOrUnknown(
          data['target_area_efect']!,
          _targetAreaEfectMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_targetAreaEfectMeta);
    }
    if (data.containsKey('publication')) {
      context.handle(
        _publicationMeta,
        publication.isAcceptableOrUnknown(
          data['publication']!,
          _publicationMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_publicationMeta);
    }
    if (data.containsKey('pm')) {
      context.handle(_pmMeta, pm.isAcceptableOrUnknown(data['pm']!, _pmMeta));
    }
    if (data.containsKey('cd')) {
      context.handle(_cdMeta, cd.isAcceptableOrUnknown(data['cd']!, _cdMeta));
    }
    if (data.containsKey('medium_damage_value')) {
      context.handle(
        _mediumDamageValueMeta,
        mediumDamageValue.isAcceptableOrUnknown(
          data['medium_damage_value']!,
          _mediumDamageValueMeta,
        ),
      );
    }
    if (data.containsKey('damage_dices')) {
      context.handle(
        _damageDicesMeta,
        damageDices.isAcceptableOrUnknown(
          data['damage_dices']!,
          _damageDicesMeta,
        ),
      );
    }
    if (data.containsKey('extra_damage_dices')) {
      context.handle(
        _extraDamageDicesMeta,
        extraDamageDices.isAcceptableOrUnknown(
          data['extra_damage_dices']!,
          _extraDamageDicesMeta,
        ),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {uuid};
  @override
  MagicCharacterTableData map(
    Map<String, dynamic> data, {
    String? tablePrefix,
  }) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return MagicCharacterTableData(
      magicId: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}magic_id'],
      )!,
      uuid: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}uuid'],
      )!,
      grimoireUUid: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}grimoire_u_uid'],
      )!,
      name: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}name'],
      )!,
      desc: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}desc'],
      )!,
      circleLevel: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}circle_level'],
      )!,
      typeIndex: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}type_index'],
      )!,
      schoolIndex: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}school_index'],
      )!,
      executionIndex: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}execution_index'],
      )!,
      durationIndex: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}duration_index'],
      )!,
      rangeIndex: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}range_index'],
      )!,
      resistence: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}resistence'],
      )!,
      targetAreaEfect: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}target_area_efect'],
      )!,
      publication: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}publication'],
      )!,
      pm: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}pm'],
      ),
      cd: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}cd'],
      ),
      mediumDamageValue: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}medium_damage_value'],
      ),
      damageDices: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}damage_dices'],
      ),
      extraDamageDices: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}extra_damage_dices'],
      ),
    );
  }

  @override
  $MagicCharacterTableTable createAlias(String alias) {
    return $MagicCharacterTableTable(attachedDatabase, alias);
  }
}

class MagicCharacterTableData extends DataClass
    implements Insertable<MagicCharacterTableData> {
  final int magicId;
  final String uuid;
  final String grimoireUUid;
  final String name;
  final String desc;
  final int circleLevel;
  final int typeIndex;
  final int schoolIndex;
  final int executionIndex;
  final int durationIndex;
  final int rangeIndex;
  final String resistence;
  final String targetAreaEfect;
  final String publication;
  final int? pm;
  final int? cd;
  final int? mediumDamageValue;
  final String? damageDices;
  final String? extraDamageDices;
  const MagicCharacterTableData({
    required this.magicId,
    required this.uuid,
    required this.grimoireUUid,
    required this.name,
    required this.desc,
    required this.circleLevel,
    required this.typeIndex,
    required this.schoolIndex,
    required this.executionIndex,
    required this.durationIndex,
    required this.rangeIndex,
    required this.resistence,
    required this.targetAreaEfect,
    required this.publication,
    this.pm,
    this.cd,
    this.mediumDamageValue,
    this.damageDices,
    this.extraDamageDices,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['magic_id'] = Variable<int>(magicId);
    map['uuid'] = Variable<String>(uuid);
    map['grimoire_u_uid'] = Variable<String>(grimoireUUid);
    map['name'] = Variable<String>(name);
    map['desc'] = Variable<String>(desc);
    map['circle_level'] = Variable<int>(circleLevel);
    map['type_index'] = Variable<int>(typeIndex);
    map['school_index'] = Variable<int>(schoolIndex);
    map['execution_index'] = Variable<int>(executionIndex);
    map['duration_index'] = Variable<int>(durationIndex);
    map['range_index'] = Variable<int>(rangeIndex);
    map['resistence'] = Variable<String>(resistence);
    map['target_area_efect'] = Variable<String>(targetAreaEfect);
    map['publication'] = Variable<String>(publication);
    if (!nullToAbsent || pm != null) {
      map['pm'] = Variable<int>(pm);
    }
    if (!nullToAbsent || cd != null) {
      map['cd'] = Variable<int>(cd);
    }
    if (!nullToAbsent || mediumDamageValue != null) {
      map['medium_damage_value'] = Variable<int>(mediumDamageValue);
    }
    if (!nullToAbsent || damageDices != null) {
      map['damage_dices'] = Variable<String>(damageDices);
    }
    if (!nullToAbsent || extraDamageDices != null) {
      map['extra_damage_dices'] = Variable<String>(extraDamageDices);
    }
    return map;
  }

  MagicCharacterTableCompanion toCompanion(bool nullToAbsent) {
    return MagicCharacterTableCompanion(
      magicId: Value(magicId),
      uuid: Value(uuid),
      grimoireUUid: Value(grimoireUUid),
      name: Value(name),
      desc: Value(desc),
      circleLevel: Value(circleLevel),
      typeIndex: Value(typeIndex),
      schoolIndex: Value(schoolIndex),
      executionIndex: Value(executionIndex),
      durationIndex: Value(durationIndex),
      rangeIndex: Value(rangeIndex),
      resistence: Value(resistence),
      targetAreaEfect: Value(targetAreaEfect),
      publication: Value(publication),
      pm: pm == null && nullToAbsent ? const Value.absent() : Value(pm),
      cd: cd == null && nullToAbsent ? const Value.absent() : Value(cd),
      mediumDamageValue: mediumDamageValue == null && nullToAbsent
          ? const Value.absent()
          : Value(mediumDamageValue),
      damageDices: damageDices == null && nullToAbsent
          ? const Value.absent()
          : Value(damageDices),
      extraDamageDices: extraDamageDices == null && nullToAbsent
          ? const Value.absent()
          : Value(extraDamageDices),
    );
  }

  factory MagicCharacterTableData.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return MagicCharacterTableData(
      magicId: serializer.fromJson<int>(json['magicId']),
      uuid: serializer.fromJson<String>(json['uuid']),
      grimoireUUid: serializer.fromJson<String>(json['grimoireUUid']),
      name: serializer.fromJson<String>(json['name']),
      desc: serializer.fromJson<String>(json['desc']),
      circleLevel: serializer.fromJson<int>(json['circleLevel']),
      typeIndex: serializer.fromJson<int>(json['typeIndex']),
      schoolIndex: serializer.fromJson<int>(json['schoolIndex']),
      executionIndex: serializer.fromJson<int>(json['executionIndex']),
      durationIndex: serializer.fromJson<int>(json['durationIndex']),
      rangeIndex: serializer.fromJson<int>(json['rangeIndex']),
      resistence: serializer.fromJson<String>(json['resistence']),
      targetAreaEfect: serializer.fromJson<String>(json['targetAreaEfect']),
      publication: serializer.fromJson<String>(json['publication']),
      pm: serializer.fromJson<int?>(json['pm']),
      cd: serializer.fromJson<int?>(json['cd']),
      mediumDamageValue: serializer.fromJson<int?>(json['mediumDamageValue']),
      damageDices: serializer.fromJson<String?>(json['damageDices']),
      extraDamageDices: serializer.fromJson<String?>(json['extraDamageDices']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'magicId': serializer.toJson<int>(magicId),
      'uuid': serializer.toJson<String>(uuid),
      'grimoireUUid': serializer.toJson<String>(grimoireUUid),
      'name': serializer.toJson<String>(name),
      'desc': serializer.toJson<String>(desc),
      'circleLevel': serializer.toJson<int>(circleLevel),
      'typeIndex': serializer.toJson<int>(typeIndex),
      'schoolIndex': serializer.toJson<int>(schoolIndex),
      'executionIndex': serializer.toJson<int>(executionIndex),
      'durationIndex': serializer.toJson<int>(durationIndex),
      'rangeIndex': serializer.toJson<int>(rangeIndex),
      'resistence': serializer.toJson<String>(resistence),
      'targetAreaEfect': serializer.toJson<String>(targetAreaEfect),
      'publication': serializer.toJson<String>(publication),
      'pm': serializer.toJson<int?>(pm),
      'cd': serializer.toJson<int?>(cd),
      'mediumDamageValue': serializer.toJson<int?>(mediumDamageValue),
      'damageDices': serializer.toJson<String?>(damageDices),
      'extraDamageDices': serializer.toJson<String?>(extraDamageDices),
    };
  }

  MagicCharacterTableData copyWith({
    int? magicId,
    String? uuid,
    String? grimoireUUid,
    String? name,
    String? desc,
    int? circleLevel,
    int? typeIndex,
    int? schoolIndex,
    int? executionIndex,
    int? durationIndex,
    int? rangeIndex,
    String? resistence,
    String? targetAreaEfect,
    String? publication,
    Value<int?> pm = const Value.absent(),
    Value<int?> cd = const Value.absent(),
    Value<int?> mediumDamageValue = const Value.absent(),
    Value<String?> damageDices = const Value.absent(),
    Value<String?> extraDamageDices = const Value.absent(),
  }) => MagicCharacterTableData(
    magicId: magicId ?? this.magicId,
    uuid: uuid ?? this.uuid,
    grimoireUUid: grimoireUUid ?? this.grimoireUUid,
    name: name ?? this.name,
    desc: desc ?? this.desc,
    circleLevel: circleLevel ?? this.circleLevel,
    typeIndex: typeIndex ?? this.typeIndex,
    schoolIndex: schoolIndex ?? this.schoolIndex,
    executionIndex: executionIndex ?? this.executionIndex,
    durationIndex: durationIndex ?? this.durationIndex,
    rangeIndex: rangeIndex ?? this.rangeIndex,
    resistence: resistence ?? this.resistence,
    targetAreaEfect: targetAreaEfect ?? this.targetAreaEfect,
    publication: publication ?? this.publication,
    pm: pm.present ? pm.value : this.pm,
    cd: cd.present ? cd.value : this.cd,
    mediumDamageValue: mediumDamageValue.present
        ? mediumDamageValue.value
        : this.mediumDamageValue,
    damageDices: damageDices.present ? damageDices.value : this.damageDices,
    extraDamageDices: extraDamageDices.present
        ? extraDamageDices.value
        : this.extraDamageDices,
  );
  MagicCharacterTableData copyWithCompanion(MagicCharacterTableCompanion data) {
    return MagicCharacterTableData(
      magicId: data.magicId.present ? data.magicId.value : this.magicId,
      uuid: data.uuid.present ? data.uuid.value : this.uuid,
      grimoireUUid: data.grimoireUUid.present
          ? data.grimoireUUid.value
          : this.grimoireUUid,
      name: data.name.present ? data.name.value : this.name,
      desc: data.desc.present ? data.desc.value : this.desc,
      circleLevel: data.circleLevel.present
          ? data.circleLevel.value
          : this.circleLevel,
      typeIndex: data.typeIndex.present ? data.typeIndex.value : this.typeIndex,
      schoolIndex: data.schoolIndex.present
          ? data.schoolIndex.value
          : this.schoolIndex,
      executionIndex: data.executionIndex.present
          ? data.executionIndex.value
          : this.executionIndex,
      durationIndex: data.durationIndex.present
          ? data.durationIndex.value
          : this.durationIndex,
      rangeIndex: data.rangeIndex.present
          ? data.rangeIndex.value
          : this.rangeIndex,
      resistence: data.resistence.present
          ? data.resistence.value
          : this.resistence,
      targetAreaEfect: data.targetAreaEfect.present
          ? data.targetAreaEfect.value
          : this.targetAreaEfect,
      publication: data.publication.present
          ? data.publication.value
          : this.publication,
      pm: data.pm.present ? data.pm.value : this.pm,
      cd: data.cd.present ? data.cd.value : this.cd,
      mediumDamageValue: data.mediumDamageValue.present
          ? data.mediumDamageValue.value
          : this.mediumDamageValue,
      damageDices: data.damageDices.present
          ? data.damageDices.value
          : this.damageDices,
      extraDamageDices: data.extraDamageDices.present
          ? data.extraDamageDices.value
          : this.extraDamageDices,
    );
  }

  @override
  String toString() {
    return (StringBuffer('MagicCharacterTableData(')
          ..write('magicId: $magicId, ')
          ..write('uuid: $uuid, ')
          ..write('grimoireUUid: $grimoireUUid, ')
          ..write('name: $name, ')
          ..write('desc: $desc, ')
          ..write('circleLevel: $circleLevel, ')
          ..write('typeIndex: $typeIndex, ')
          ..write('schoolIndex: $schoolIndex, ')
          ..write('executionIndex: $executionIndex, ')
          ..write('durationIndex: $durationIndex, ')
          ..write('rangeIndex: $rangeIndex, ')
          ..write('resistence: $resistence, ')
          ..write('targetAreaEfect: $targetAreaEfect, ')
          ..write('publication: $publication, ')
          ..write('pm: $pm, ')
          ..write('cd: $cd, ')
          ..write('mediumDamageValue: $mediumDamageValue, ')
          ..write('damageDices: $damageDices, ')
          ..write('extraDamageDices: $extraDamageDices')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    magicId,
    uuid,
    grimoireUUid,
    name,
    desc,
    circleLevel,
    typeIndex,
    schoolIndex,
    executionIndex,
    durationIndex,
    rangeIndex,
    resistence,
    targetAreaEfect,
    publication,
    pm,
    cd,
    mediumDamageValue,
    damageDices,
    extraDamageDices,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is MagicCharacterTableData &&
          other.magicId == this.magicId &&
          other.uuid == this.uuid &&
          other.grimoireUUid == this.grimoireUUid &&
          other.name == this.name &&
          other.desc == this.desc &&
          other.circleLevel == this.circleLevel &&
          other.typeIndex == this.typeIndex &&
          other.schoolIndex == this.schoolIndex &&
          other.executionIndex == this.executionIndex &&
          other.durationIndex == this.durationIndex &&
          other.rangeIndex == this.rangeIndex &&
          other.resistence == this.resistence &&
          other.targetAreaEfect == this.targetAreaEfect &&
          other.publication == this.publication &&
          other.pm == this.pm &&
          other.cd == this.cd &&
          other.mediumDamageValue == this.mediumDamageValue &&
          other.damageDices == this.damageDices &&
          other.extraDamageDices == this.extraDamageDices);
}

class MagicCharacterTableCompanion
    extends UpdateCompanion<MagicCharacterTableData> {
  final Value<int> magicId;
  final Value<String> uuid;
  final Value<String> grimoireUUid;
  final Value<String> name;
  final Value<String> desc;
  final Value<int> circleLevel;
  final Value<int> typeIndex;
  final Value<int> schoolIndex;
  final Value<int> executionIndex;
  final Value<int> durationIndex;
  final Value<int> rangeIndex;
  final Value<String> resistence;
  final Value<String> targetAreaEfect;
  final Value<String> publication;
  final Value<int?> pm;
  final Value<int?> cd;
  final Value<int?> mediumDamageValue;
  final Value<String?> damageDices;
  final Value<String?> extraDamageDices;
  final Value<int> rowid;
  const MagicCharacterTableCompanion({
    this.magicId = const Value.absent(),
    this.uuid = const Value.absent(),
    this.grimoireUUid = const Value.absent(),
    this.name = const Value.absent(),
    this.desc = const Value.absent(),
    this.circleLevel = const Value.absent(),
    this.typeIndex = const Value.absent(),
    this.schoolIndex = const Value.absent(),
    this.executionIndex = const Value.absent(),
    this.durationIndex = const Value.absent(),
    this.rangeIndex = const Value.absent(),
    this.resistence = const Value.absent(),
    this.targetAreaEfect = const Value.absent(),
    this.publication = const Value.absent(),
    this.pm = const Value.absent(),
    this.cd = const Value.absent(),
    this.mediumDamageValue = const Value.absent(),
    this.damageDices = const Value.absent(),
    this.extraDamageDices = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  MagicCharacterTableCompanion.insert({
    required int magicId,
    required String uuid,
    required String grimoireUUid,
    required String name,
    required String desc,
    required int circleLevel,
    required int typeIndex,
    required int schoolIndex,
    required int executionIndex,
    required int durationIndex,
    required int rangeIndex,
    required String resistence,
    required String targetAreaEfect,
    required String publication,
    this.pm = const Value.absent(),
    this.cd = const Value.absent(),
    this.mediumDamageValue = const Value.absent(),
    this.damageDices = const Value.absent(),
    this.extraDamageDices = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : magicId = Value(magicId),
       uuid = Value(uuid),
       grimoireUUid = Value(grimoireUUid),
       name = Value(name),
       desc = Value(desc),
       circleLevel = Value(circleLevel),
       typeIndex = Value(typeIndex),
       schoolIndex = Value(schoolIndex),
       executionIndex = Value(executionIndex),
       durationIndex = Value(durationIndex),
       rangeIndex = Value(rangeIndex),
       resistence = Value(resistence),
       targetAreaEfect = Value(targetAreaEfect),
       publication = Value(publication);
  static Insertable<MagicCharacterTableData> custom({
    Expression<int>? magicId,
    Expression<String>? uuid,
    Expression<String>? grimoireUUid,
    Expression<String>? name,
    Expression<String>? desc,
    Expression<int>? circleLevel,
    Expression<int>? typeIndex,
    Expression<int>? schoolIndex,
    Expression<int>? executionIndex,
    Expression<int>? durationIndex,
    Expression<int>? rangeIndex,
    Expression<String>? resistence,
    Expression<String>? targetAreaEfect,
    Expression<String>? publication,
    Expression<int>? pm,
    Expression<int>? cd,
    Expression<int>? mediumDamageValue,
    Expression<String>? damageDices,
    Expression<String>? extraDamageDices,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (magicId != null) 'magic_id': magicId,
      if (uuid != null) 'uuid': uuid,
      if (grimoireUUid != null) 'grimoire_u_uid': grimoireUUid,
      if (name != null) 'name': name,
      if (desc != null) 'desc': desc,
      if (circleLevel != null) 'circle_level': circleLevel,
      if (typeIndex != null) 'type_index': typeIndex,
      if (schoolIndex != null) 'school_index': schoolIndex,
      if (executionIndex != null) 'execution_index': executionIndex,
      if (durationIndex != null) 'duration_index': durationIndex,
      if (rangeIndex != null) 'range_index': rangeIndex,
      if (resistence != null) 'resistence': resistence,
      if (targetAreaEfect != null) 'target_area_efect': targetAreaEfect,
      if (publication != null) 'publication': publication,
      if (pm != null) 'pm': pm,
      if (cd != null) 'cd': cd,
      if (mediumDamageValue != null) 'medium_damage_value': mediumDamageValue,
      if (damageDices != null) 'damage_dices': damageDices,
      if (extraDamageDices != null) 'extra_damage_dices': extraDamageDices,
      if (rowid != null) 'rowid': rowid,
    });
  }

  MagicCharacterTableCompanion copyWith({
    Value<int>? magicId,
    Value<String>? uuid,
    Value<String>? grimoireUUid,
    Value<String>? name,
    Value<String>? desc,
    Value<int>? circleLevel,
    Value<int>? typeIndex,
    Value<int>? schoolIndex,
    Value<int>? executionIndex,
    Value<int>? durationIndex,
    Value<int>? rangeIndex,
    Value<String>? resistence,
    Value<String>? targetAreaEfect,
    Value<String>? publication,
    Value<int?>? pm,
    Value<int?>? cd,
    Value<int?>? mediumDamageValue,
    Value<String?>? damageDices,
    Value<String?>? extraDamageDices,
    Value<int>? rowid,
  }) {
    return MagicCharacterTableCompanion(
      magicId: magicId ?? this.magicId,
      uuid: uuid ?? this.uuid,
      grimoireUUid: grimoireUUid ?? this.grimoireUUid,
      name: name ?? this.name,
      desc: desc ?? this.desc,
      circleLevel: circleLevel ?? this.circleLevel,
      typeIndex: typeIndex ?? this.typeIndex,
      schoolIndex: schoolIndex ?? this.schoolIndex,
      executionIndex: executionIndex ?? this.executionIndex,
      durationIndex: durationIndex ?? this.durationIndex,
      rangeIndex: rangeIndex ?? this.rangeIndex,
      resistence: resistence ?? this.resistence,
      targetAreaEfect: targetAreaEfect ?? this.targetAreaEfect,
      publication: publication ?? this.publication,
      pm: pm ?? this.pm,
      cd: cd ?? this.cd,
      mediumDamageValue: mediumDamageValue ?? this.mediumDamageValue,
      damageDices: damageDices ?? this.damageDices,
      extraDamageDices: extraDamageDices ?? this.extraDamageDices,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (magicId.present) {
      map['magic_id'] = Variable<int>(magicId.value);
    }
    if (uuid.present) {
      map['uuid'] = Variable<String>(uuid.value);
    }
    if (grimoireUUid.present) {
      map['grimoire_u_uid'] = Variable<String>(grimoireUUid.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    if (desc.present) {
      map['desc'] = Variable<String>(desc.value);
    }
    if (circleLevel.present) {
      map['circle_level'] = Variable<int>(circleLevel.value);
    }
    if (typeIndex.present) {
      map['type_index'] = Variable<int>(typeIndex.value);
    }
    if (schoolIndex.present) {
      map['school_index'] = Variable<int>(schoolIndex.value);
    }
    if (executionIndex.present) {
      map['execution_index'] = Variable<int>(executionIndex.value);
    }
    if (durationIndex.present) {
      map['duration_index'] = Variable<int>(durationIndex.value);
    }
    if (rangeIndex.present) {
      map['range_index'] = Variable<int>(rangeIndex.value);
    }
    if (resistence.present) {
      map['resistence'] = Variable<String>(resistence.value);
    }
    if (targetAreaEfect.present) {
      map['target_area_efect'] = Variable<String>(targetAreaEfect.value);
    }
    if (publication.present) {
      map['publication'] = Variable<String>(publication.value);
    }
    if (pm.present) {
      map['pm'] = Variable<int>(pm.value);
    }
    if (cd.present) {
      map['cd'] = Variable<int>(cd.value);
    }
    if (mediumDamageValue.present) {
      map['medium_damage_value'] = Variable<int>(mediumDamageValue.value);
    }
    if (damageDices.present) {
      map['damage_dices'] = Variable<String>(damageDices.value);
    }
    if (extraDamageDices.present) {
      map['extra_damage_dices'] = Variable<String>(extraDamageDices.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('MagicCharacterTableCompanion(')
          ..write('magicId: $magicId, ')
          ..write('uuid: $uuid, ')
          ..write('grimoireUUid: $grimoireUUid, ')
          ..write('name: $name, ')
          ..write('desc: $desc, ')
          ..write('circleLevel: $circleLevel, ')
          ..write('typeIndex: $typeIndex, ')
          ..write('schoolIndex: $schoolIndex, ')
          ..write('executionIndex: $executionIndex, ')
          ..write('durationIndex: $durationIndex, ')
          ..write('rangeIndex: $rangeIndex, ')
          ..write('resistence: $resistence, ')
          ..write('targetAreaEfect: $targetAreaEfect, ')
          ..write('publication: $publication, ')
          ..write('pm: $pm, ')
          ..write('cd: $cd, ')
          ..write('mediumDamageValue: $mediumDamageValue, ')
          ..write('damageDices: $damageDices, ')
          ..write('extraDamageDices: $extraDamageDices, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $BoardTableTable extends BoardTable
    with TableInfo<$BoardTableTable, BoardTableData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $BoardTableTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _uuidMeta = const VerificationMeta('uuid');
  @override
  late final GeneratedColumn<String> uuid = GeneratedColumn<String>(
    'uuid',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
    'name',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _levelMeta = const VerificationMeta('level');
  @override
  late final GeneratedColumn<int> level = GeneratedColumn<int>(
    'level',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _modeIndexMeta = const VerificationMeta(
    'modeIndex',
  );
  @override
  late final GeneratedColumn<int> modeIndex = GeneratedColumn<int>(
    'mode_index',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _adventureNameMeta = const VerificationMeta(
    'adventureName',
  );
  @override
  late final GeneratedColumn<String> adventureName = GeneratedColumn<String>(
    'adventure_name',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _bannerPathMeta = const VerificationMeta(
    'bannerPath',
  );
  @override
  late final GeneratedColumn<String> bannerPath = GeneratedColumn<String>(
    'banner_path',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _descMeta = const VerificationMeta('desc');
  @override
  late final GeneratedColumn<String> desc = GeneratedColumn<String>(
    'desc',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<int> createdAt = GeneratedColumn<int>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _updatedAtMeta = const VerificationMeta(
    'updatedAt',
  );
  @override
  late final GeneratedColumn<int> updatedAt = GeneratedColumn<int>(
    'updated_at',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _whatsGroupLinkMeta = const VerificationMeta(
    'whatsGroupLink',
  );
  @override
  late final GeneratedColumn<String> whatsGroupLink = GeneratedColumn<String>(
    'whats_group_link',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _telegramGroupLinkMeta = const VerificationMeta(
    'telegramGroupLink',
  );
  @override
  late final GeneratedColumn<String> telegramGroupLink =
      GeneratedColumn<String>(
        'telegram_group_link',
        aliasedName,
        true,
        type: DriftSqlType.string,
        requiredDuringInsert: false,
      );
  static const VerificationMeta _discordServerLinkMeta = const VerificationMeta(
    'discordServerLink',
  );
  @override
  late final GeneratedColumn<String> discordServerLink =
      GeneratedColumn<String>(
        'discord_server_link',
        aliasedName,
        true,
        type: DriftSqlType.string,
        requiredDuringInsert: false,
      );
  static const VerificationMeta _driveFilesLinkMeta = const VerificationMeta(
    'driveFilesLink',
  );
  @override
  late final GeneratedColumn<String> driveFilesLink = GeneratedColumn<String>(
    'drive_files_link',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _isFavoritedMeta = const VerificationMeta(
    'isFavorited',
  );
  @override
  late final GeneratedColumn<bool> isFavorited = GeneratedColumn<bool>(
    'is_favorited',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_favorited" IN (0, 1))',
    ),
  );
  @override
  List<GeneratedColumn> get $columns => [
    uuid,
    name,
    level,
    modeIndex,
    adventureName,
    bannerPath,
    desc,
    createdAt,
    updatedAt,
    whatsGroupLink,
    telegramGroupLink,
    discordServerLink,
    driveFilesLink,
    isFavorited,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'board_table';
  @override
  VerificationContext validateIntegrity(
    Insertable<BoardTableData> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('uuid')) {
      context.handle(
        _uuidMeta,
        uuid.isAcceptableOrUnknown(data['uuid']!, _uuidMeta),
      );
    } else if (isInserting) {
      context.missing(_uuidMeta);
    }
    if (data.containsKey('name')) {
      context.handle(
        _nameMeta,
        name.isAcceptableOrUnknown(data['name']!, _nameMeta),
      );
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    if (data.containsKey('level')) {
      context.handle(
        _levelMeta,
        level.isAcceptableOrUnknown(data['level']!, _levelMeta),
      );
    } else if (isInserting) {
      context.missing(_levelMeta);
    }
    if (data.containsKey('mode_index')) {
      context.handle(
        _modeIndexMeta,
        modeIndex.isAcceptableOrUnknown(data['mode_index']!, _modeIndexMeta),
      );
    } else if (isInserting) {
      context.missing(_modeIndexMeta);
    }
    if (data.containsKey('adventure_name')) {
      context.handle(
        _adventureNameMeta,
        adventureName.isAcceptableOrUnknown(
          data['adventure_name']!,
          _adventureNameMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_adventureNameMeta);
    }
    if (data.containsKey('banner_path')) {
      context.handle(
        _bannerPathMeta,
        bannerPath.isAcceptableOrUnknown(data['banner_path']!, _bannerPathMeta),
      );
    }
    if (data.containsKey('desc')) {
      context.handle(
        _descMeta,
        desc.isAcceptableOrUnknown(data['desc']!, _descMeta),
      );
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    } else if (isInserting) {
      context.missing(_createdAtMeta);
    }
    if (data.containsKey('updated_at')) {
      context.handle(
        _updatedAtMeta,
        updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta),
      );
    } else if (isInserting) {
      context.missing(_updatedAtMeta);
    }
    if (data.containsKey('whats_group_link')) {
      context.handle(
        _whatsGroupLinkMeta,
        whatsGroupLink.isAcceptableOrUnknown(
          data['whats_group_link']!,
          _whatsGroupLinkMeta,
        ),
      );
    }
    if (data.containsKey('telegram_group_link')) {
      context.handle(
        _telegramGroupLinkMeta,
        telegramGroupLink.isAcceptableOrUnknown(
          data['telegram_group_link']!,
          _telegramGroupLinkMeta,
        ),
      );
    }
    if (data.containsKey('discord_server_link')) {
      context.handle(
        _discordServerLinkMeta,
        discordServerLink.isAcceptableOrUnknown(
          data['discord_server_link']!,
          _discordServerLinkMeta,
        ),
      );
    }
    if (data.containsKey('drive_files_link')) {
      context.handle(
        _driveFilesLinkMeta,
        driveFilesLink.isAcceptableOrUnknown(
          data['drive_files_link']!,
          _driveFilesLinkMeta,
        ),
      );
    }
    if (data.containsKey('is_favorited')) {
      context.handle(
        _isFavoritedMeta,
        isFavorited.isAcceptableOrUnknown(
          data['is_favorited']!,
          _isFavoritedMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_isFavoritedMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {uuid};
  @override
  BoardTableData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return BoardTableData(
      uuid: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}uuid'],
      )!,
      name: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}name'],
      )!,
      level: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}level'],
      )!,
      modeIndex: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}mode_index'],
      )!,
      adventureName: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}adventure_name'],
      )!,
      bannerPath: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}banner_path'],
      ),
      desc: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}desc'],
      ),
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}created_at'],
      )!,
      updatedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}updated_at'],
      )!,
      whatsGroupLink: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}whats_group_link'],
      ),
      telegramGroupLink: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}telegram_group_link'],
      ),
      discordServerLink: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}discord_server_link'],
      ),
      driveFilesLink: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}drive_files_link'],
      ),
      isFavorited: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_favorited'],
      )!,
    );
  }

  @override
  $BoardTableTable createAlias(String alias) {
    return $BoardTableTable(attachedDatabase, alias);
  }
}

class BoardTableData extends DataClass implements Insertable<BoardTableData> {
  final String uuid;
  final String name;
  final int level;
  final int modeIndex;
  final String adventureName;
  final String? bannerPath;
  final String? desc;
  final int createdAt;
  final int updatedAt;
  final String? whatsGroupLink;
  final String? telegramGroupLink;
  final String? discordServerLink;
  final String? driveFilesLink;
  final bool isFavorited;
  const BoardTableData({
    required this.uuid,
    required this.name,
    required this.level,
    required this.modeIndex,
    required this.adventureName,
    this.bannerPath,
    this.desc,
    required this.createdAt,
    required this.updatedAt,
    this.whatsGroupLink,
    this.telegramGroupLink,
    this.discordServerLink,
    this.driveFilesLink,
    required this.isFavorited,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['uuid'] = Variable<String>(uuid);
    map['name'] = Variable<String>(name);
    map['level'] = Variable<int>(level);
    map['mode_index'] = Variable<int>(modeIndex);
    map['adventure_name'] = Variable<String>(adventureName);
    if (!nullToAbsent || bannerPath != null) {
      map['banner_path'] = Variable<String>(bannerPath);
    }
    if (!nullToAbsent || desc != null) {
      map['desc'] = Variable<String>(desc);
    }
    map['created_at'] = Variable<int>(createdAt);
    map['updated_at'] = Variable<int>(updatedAt);
    if (!nullToAbsent || whatsGroupLink != null) {
      map['whats_group_link'] = Variable<String>(whatsGroupLink);
    }
    if (!nullToAbsent || telegramGroupLink != null) {
      map['telegram_group_link'] = Variable<String>(telegramGroupLink);
    }
    if (!nullToAbsent || discordServerLink != null) {
      map['discord_server_link'] = Variable<String>(discordServerLink);
    }
    if (!nullToAbsent || driveFilesLink != null) {
      map['drive_files_link'] = Variable<String>(driveFilesLink);
    }
    map['is_favorited'] = Variable<bool>(isFavorited);
    return map;
  }

  BoardTableCompanion toCompanion(bool nullToAbsent) {
    return BoardTableCompanion(
      uuid: Value(uuid),
      name: Value(name),
      level: Value(level),
      modeIndex: Value(modeIndex),
      adventureName: Value(adventureName),
      bannerPath: bannerPath == null && nullToAbsent
          ? const Value.absent()
          : Value(bannerPath),
      desc: desc == null && nullToAbsent ? const Value.absent() : Value(desc),
      createdAt: Value(createdAt),
      updatedAt: Value(updatedAt),
      whatsGroupLink: whatsGroupLink == null && nullToAbsent
          ? const Value.absent()
          : Value(whatsGroupLink),
      telegramGroupLink: telegramGroupLink == null && nullToAbsent
          ? const Value.absent()
          : Value(telegramGroupLink),
      discordServerLink: discordServerLink == null && nullToAbsent
          ? const Value.absent()
          : Value(discordServerLink),
      driveFilesLink: driveFilesLink == null && nullToAbsent
          ? const Value.absent()
          : Value(driveFilesLink),
      isFavorited: Value(isFavorited),
    );
  }

  factory BoardTableData.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return BoardTableData(
      uuid: serializer.fromJson<String>(json['uuid']),
      name: serializer.fromJson<String>(json['name']),
      level: serializer.fromJson<int>(json['level']),
      modeIndex: serializer.fromJson<int>(json['modeIndex']),
      adventureName: serializer.fromJson<String>(json['adventureName']),
      bannerPath: serializer.fromJson<String?>(json['bannerPath']),
      desc: serializer.fromJson<String?>(json['desc']),
      createdAt: serializer.fromJson<int>(json['createdAt']),
      updatedAt: serializer.fromJson<int>(json['updatedAt']),
      whatsGroupLink: serializer.fromJson<String?>(json['whatsGroupLink']),
      telegramGroupLink: serializer.fromJson<String?>(
        json['telegramGroupLink'],
      ),
      discordServerLink: serializer.fromJson<String?>(
        json['discordServerLink'],
      ),
      driveFilesLink: serializer.fromJson<String?>(json['driveFilesLink']),
      isFavorited: serializer.fromJson<bool>(json['isFavorited']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'uuid': serializer.toJson<String>(uuid),
      'name': serializer.toJson<String>(name),
      'level': serializer.toJson<int>(level),
      'modeIndex': serializer.toJson<int>(modeIndex),
      'adventureName': serializer.toJson<String>(adventureName),
      'bannerPath': serializer.toJson<String?>(bannerPath),
      'desc': serializer.toJson<String?>(desc),
      'createdAt': serializer.toJson<int>(createdAt),
      'updatedAt': serializer.toJson<int>(updatedAt),
      'whatsGroupLink': serializer.toJson<String?>(whatsGroupLink),
      'telegramGroupLink': serializer.toJson<String?>(telegramGroupLink),
      'discordServerLink': serializer.toJson<String?>(discordServerLink),
      'driveFilesLink': serializer.toJson<String?>(driveFilesLink),
      'isFavorited': serializer.toJson<bool>(isFavorited),
    };
  }

  BoardTableData copyWith({
    String? uuid,
    String? name,
    int? level,
    int? modeIndex,
    String? adventureName,
    Value<String?> bannerPath = const Value.absent(),
    Value<String?> desc = const Value.absent(),
    int? createdAt,
    int? updatedAt,
    Value<String?> whatsGroupLink = const Value.absent(),
    Value<String?> telegramGroupLink = const Value.absent(),
    Value<String?> discordServerLink = const Value.absent(),
    Value<String?> driveFilesLink = const Value.absent(),
    bool? isFavorited,
  }) => BoardTableData(
    uuid: uuid ?? this.uuid,
    name: name ?? this.name,
    level: level ?? this.level,
    modeIndex: modeIndex ?? this.modeIndex,
    adventureName: adventureName ?? this.adventureName,
    bannerPath: bannerPath.present ? bannerPath.value : this.bannerPath,
    desc: desc.present ? desc.value : this.desc,
    createdAt: createdAt ?? this.createdAt,
    updatedAt: updatedAt ?? this.updatedAt,
    whatsGroupLink: whatsGroupLink.present
        ? whatsGroupLink.value
        : this.whatsGroupLink,
    telegramGroupLink: telegramGroupLink.present
        ? telegramGroupLink.value
        : this.telegramGroupLink,
    discordServerLink: discordServerLink.present
        ? discordServerLink.value
        : this.discordServerLink,
    driveFilesLink: driveFilesLink.present
        ? driveFilesLink.value
        : this.driveFilesLink,
    isFavorited: isFavorited ?? this.isFavorited,
  );
  BoardTableData copyWithCompanion(BoardTableCompanion data) {
    return BoardTableData(
      uuid: data.uuid.present ? data.uuid.value : this.uuid,
      name: data.name.present ? data.name.value : this.name,
      level: data.level.present ? data.level.value : this.level,
      modeIndex: data.modeIndex.present ? data.modeIndex.value : this.modeIndex,
      adventureName: data.adventureName.present
          ? data.adventureName.value
          : this.adventureName,
      bannerPath: data.bannerPath.present
          ? data.bannerPath.value
          : this.bannerPath,
      desc: data.desc.present ? data.desc.value : this.desc,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
      whatsGroupLink: data.whatsGroupLink.present
          ? data.whatsGroupLink.value
          : this.whatsGroupLink,
      telegramGroupLink: data.telegramGroupLink.present
          ? data.telegramGroupLink.value
          : this.telegramGroupLink,
      discordServerLink: data.discordServerLink.present
          ? data.discordServerLink.value
          : this.discordServerLink,
      driveFilesLink: data.driveFilesLink.present
          ? data.driveFilesLink.value
          : this.driveFilesLink,
      isFavorited: data.isFavorited.present
          ? data.isFavorited.value
          : this.isFavorited,
    );
  }

  @override
  String toString() {
    return (StringBuffer('BoardTableData(')
          ..write('uuid: $uuid, ')
          ..write('name: $name, ')
          ..write('level: $level, ')
          ..write('modeIndex: $modeIndex, ')
          ..write('adventureName: $adventureName, ')
          ..write('bannerPath: $bannerPath, ')
          ..write('desc: $desc, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('whatsGroupLink: $whatsGroupLink, ')
          ..write('telegramGroupLink: $telegramGroupLink, ')
          ..write('discordServerLink: $discordServerLink, ')
          ..write('driveFilesLink: $driveFilesLink, ')
          ..write('isFavorited: $isFavorited')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    uuid,
    name,
    level,
    modeIndex,
    adventureName,
    bannerPath,
    desc,
    createdAt,
    updatedAt,
    whatsGroupLink,
    telegramGroupLink,
    discordServerLink,
    driveFilesLink,
    isFavorited,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is BoardTableData &&
          other.uuid == this.uuid &&
          other.name == this.name &&
          other.level == this.level &&
          other.modeIndex == this.modeIndex &&
          other.adventureName == this.adventureName &&
          other.bannerPath == this.bannerPath &&
          other.desc == this.desc &&
          other.createdAt == this.createdAt &&
          other.updatedAt == this.updatedAt &&
          other.whatsGroupLink == this.whatsGroupLink &&
          other.telegramGroupLink == this.telegramGroupLink &&
          other.discordServerLink == this.discordServerLink &&
          other.driveFilesLink == this.driveFilesLink &&
          other.isFavorited == this.isFavorited);
}

class BoardTableCompanion extends UpdateCompanion<BoardTableData> {
  final Value<String> uuid;
  final Value<String> name;
  final Value<int> level;
  final Value<int> modeIndex;
  final Value<String> adventureName;
  final Value<String?> bannerPath;
  final Value<String?> desc;
  final Value<int> createdAt;
  final Value<int> updatedAt;
  final Value<String?> whatsGroupLink;
  final Value<String?> telegramGroupLink;
  final Value<String?> discordServerLink;
  final Value<String?> driveFilesLink;
  final Value<bool> isFavorited;
  final Value<int> rowid;
  const BoardTableCompanion({
    this.uuid = const Value.absent(),
    this.name = const Value.absent(),
    this.level = const Value.absent(),
    this.modeIndex = const Value.absent(),
    this.adventureName = const Value.absent(),
    this.bannerPath = const Value.absent(),
    this.desc = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.whatsGroupLink = const Value.absent(),
    this.telegramGroupLink = const Value.absent(),
    this.discordServerLink = const Value.absent(),
    this.driveFilesLink = const Value.absent(),
    this.isFavorited = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  BoardTableCompanion.insert({
    required String uuid,
    required String name,
    required int level,
    required int modeIndex,
    required String adventureName,
    this.bannerPath = const Value.absent(),
    this.desc = const Value.absent(),
    required int createdAt,
    required int updatedAt,
    this.whatsGroupLink = const Value.absent(),
    this.telegramGroupLink = const Value.absent(),
    this.discordServerLink = const Value.absent(),
    this.driveFilesLink = const Value.absent(),
    required bool isFavorited,
    this.rowid = const Value.absent(),
  }) : uuid = Value(uuid),
       name = Value(name),
       level = Value(level),
       modeIndex = Value(modeIndex),
       adventureName = Value(adventureName),
       createdAt = Value(createdAt),
       updatedAt = Value(updatedAt),
       isFavorited = Value(isFavorited);
  static Insertable<BoardTableData> custom({
    Expression<String>? uuid,
    Expression<String>? name,
    Expression<int>? level,
    Expression<int>? modeIndex,
    Expression<String>? adventureName,
    Expression<String>? bannerPath,
    Expression<String>? desc,
    Expression<int>? createdAt,
    Expression<int>? updatedAt,
    Expression<String>? whatsGroupLink,
    Expression<String>? telegramGroupLink,
    Expression<String>? discordServerLink,
    Expression<String>? driveFilesLink,
    Expression<bool>? isFavorited,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (uuid != null) 'uuid': uuid,
      if (name != null) 'name': name,
      if (level != null) 'level': level,
      if (modeIndex != null) 'mode_index': modeIndex,
      if (adventureName != null) 'adventure_name': adventureName,
      if (bannerPath != null) 'banner_path': bannerPath,
      if (desc != null) 'desc': desc,
      if (createdAt != null) 'created_at': createdAt,
      if (updatedAt != null) 'updated_at': updatedAt,
      if (whatsGroupLink != null) 'whats_group_link': whatsGroupLink,
      if (telegramGroupLink != null) 'telegram_group_link': telegramGroupLink,
      if (discordServerLink != null) 'discord_server_link': discordServerLink,
      if (driveFilesLink != null) 'drive_files_link': driveFilesLink,
      if (isFavorited != null) 'is_favorited': isFavorited,
      if (rowid != null) 'rowid': rowid,
    });
  }

  BoardTableCompanion copyWith({
    Value<String>? uuid,
    Value<String>? name,
    Value<int>? level,
    Value<int>? modeIndex,
    Value<String>? adventureName,
    Value<String?>? bannerPath,
    Value<String?>? desc,
    Value<int>? createdAt,
    Value<int>? updatedAt,
    Value<String?>? whatsGroupLink,
    Value<String?>? telegramGroupLink,
    Value<String?>? discordServerLink,
    Value<String?>? driveFilesLink,
    Value<bool>? isFavorited,
    Value<int>? rowid,
  }) {
    return BoardTableCompanion(
      uuid: uuid ?? this.uuid,
      name: name ?? this.name,
      level: level ?? this.level,
      modeIndex: modeIndex ?? this.modeIndex,
      adventureName: adventureName ?? this.adventureName,
      bannerPath: bannerPath ?? this.bannerPath,
      desc: desc ?? this.desc,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
      whatsGroupLink: whatsGroupLink ?? this.whatsGroupLink,
      telegramGroupLink: telegramGroupLink ?? this.telegramGroupLink,
      discordServerLink: discordServerLink ?? this.discordServerLink,
      driveFilesLink: driveFilesLink ?? this.driveFilesLink,
      isFavorited: isFavorited ?? this.isFavorited,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (uuid.present) {
      map['uuid'] = Variable<String>(uuid.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    if (level.present) {
      map['level'] = Variable<int>(level.value);
    }
    if (modeIndex.present) {
      map['mode_index'] = Variable<int>(modeIndex.value);
    }
    if (adventureName.present) {
      map['adventure_name'] = Variable<String>(adventureName.value);
    }
    if (bannerPath.present) {
      map['banner_path'] = Variable<String>(bannerPath.value);
    }
    if (desc.present) {
      map['desc'] = Variable<String>(desc.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<int>(createdAt.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<int>(updatedAt.value);
    }
    if (whatsGroupLink.present) {
      map['whats_group_link'] = Variable<String>(whatsGroupLink.value);
    }
    if (telegramGroupLink.present) {
      map['telegram_group_link'] = Variable<String>(telegramGroupLink.value);
    }
    if (discordServerLink.present) {
      map['discord_server_link'] = Variable<String>(discordServerLink.value);
    }
    if (driveFilesLink.present) {
      map['drive_files_link'] = Variable<String>(driveFilesLink.value);
    }
    if (isFavorited.present) {
      map['is_favorited'] = Variable<bool>(isFavorited.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('BoardTableCompanion(')
          ..write('uuid: $uuid, ')
          ..write('name: $name, ')
          ..write('level: $level, ')
          ..write('modeIndex: $modeIndex, ')
          ..write('adventureName: $adventureName, ')
          ..write('bannerPath: $bannerPath, ')
          ..write('desc: $desc, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('whatsGroupLink: $whatsGroupLink, ')
          ..write('telegramGroupLink: $telegramGroupLink, ')
          ..write('discordServerLink: $discordServerLink, ')
          ..write('driveFilesLink: $driveFilesLink, ')
          ..write('isFavorited: $isFavorited, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $BoardMaterialTableTable extends BoardMaterialTable
    with TableInfo<$BoardMaterialTableTable, BoardMaterialTableData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $BoardMaterialTableTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _uuidMeta = const VerificationMeta('uuid');
  @override
  late final GeneratedColumn<String> uuid = GeneratedColumn<String>(
    'uuid',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _typeIndexMeta = const VerificationMeta(
    'typeIndex',
  );
  @override
  late final GeneratedColumn<int> typeIndex = GeneratedColumn<int>(
    'type_index',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _pathMeta = const VerificationMeta('path');
  @override
  late final GeneratedColumn<String> path = GeneratedColumn<String>(
    'path',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _boardUuidMeta = const VerificationMeta(
    'boardUuid',
  );
  @override
  late final GeneratedColumn<String> boardUuid = GeneratedColumn<String>(
    'board_uuid',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<int> createdAt = GeneratedColumn<int>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  @override
  List<GeneratedColumn> get $columns => [
    uuid,
    typeIndex,
    path,
    boardUuid,
    createdAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'board_material_table';
  @override
  VerificationContext validateIntegrity(
    Insertable<BoardMaterialTableData> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('uuid')) {
      context.handle(
        _uuidMeta,
        uuid.isAcceptableOrUnknown(data['uuid']!, _uuidMeta),
      );
    } else if (isInserting) {
      context.missing(_uuidMeta);
    }
    if (data.containsKey('type_index')) {
      context.handle(
        _typeIndexMeta,
        typeIndex.isAcceptableOrUnknown(data['type_index']!, _typeIndexMeta),
      );
    } else if (isInserting) {
      context.missing(_typeIndexMeta);
    }
    if (data.containsKey('path')) {
      context.handle(
        _pathMeta,
        path.isAcceptableOrUnknown(data['path']!, _pathMeta),
      );
    } else if (isInserting) {
      context.missing(_pathMeta);
    }
    if (data.containsKey('board_uuid')) {
      context.handle(
        _boardUuidMeta,
        boardUuid.isAcceptableOrUnknown(data['board_uuid']!, _boardUuidMeta),
      );
    } else if (isInserting) {
      context.missing(_boardUuidMeta);
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    } else if (isInserting) {
      context.missing(_createdAtMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {uuid};
  @override
  BoardMaterialTableData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return BoardMaterialTableData(
      uuid: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}uuid'],
      )!,
      typeIndex: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}type_index'],
      )!,
      path: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}path'],
      )!,
      boardUuid: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}board_uuid'],
      )!,
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}created_at'],
      )!,
    );
  }

  @override
  $BoardMaterialTableTable createAlias(String alias) {
    return $BoardMaterialTableTable(attachedDatabase, alias);
  }
}

class BoardMaterialTableData extends DataClass
    implements Insertable<BoardMaterialTableData> {
  final String uuid;
  final int typeIndex;
  final String path;
  final String boardUuid;
  final int createdAt;
  const BoardMaterialTableData({
    required this.uuid,
    required this.typeIndex,
    required this.path,
    required this.boardUuid,
    required this.createdAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['uuid'] = Variable<String>(uuid);
    map['type_index'] = Variable<int>(typeIndex);
    map['path'] = Variable<String>(path);
    map['board_uuid'] = Variable<String>(boardUuid);
    map['created_at'] = Variable<int>(createdAt);
    return map;
  }

  BoardMaterialTableCompanion toCompanion(bool nullToAbsent) {
    return BoardMaterialTableCompanion(
      uuid: Value(uuid),
      typeIndex: Value(typeIndex),
      path: Value(path),
      boardUuid: Value(boardUuid),
      createdAt: Value(createdAt),
    );
  }

  factory BoardMaterialTableData.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return BoardMaterialTableData(
      uuid: serializer.fromJson<String>(json['uuid']),
      typeIndex: serializer.fromJson<int>(json['typeIndex']),
      path: serializer.fromJson<String>(json['path']),
      boardUuid: serializer.fromJson<String>(json['boardUuid']),
      createdAt: serializer.fromJson<int>(json['createdAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'uuid': serializer.toJson<String>(uuid),
      'typeIndex': serializer.toJson<int>(typeIndex),
      'path': serializer.toJson<String>(path),
      'boardUuid': serializer.toJson<String>(boardUuid),
      'createdAt': serializer.toJson<int>(createdAt),
    };
  }

  BoardMaterialTableData copyWith({
    String? uuid,
    int? typeIndex,
    String? path,
    String? boardUuid,
    int? createdAt,
  }) => BoardMaterialTableData(
    uuid: uuid ?? this.uuid,
    typeIndex: typeIndex ?? this.typeIndex,
    path: path ?? this.path,
    boardUuid: boardUuid ?? this.boardUuid,
    createdAt: createdAt ?? this.createdAt,
  );
  BoardMaterialTableData copyWithCompanion(BoardMaterialTableCompanion data) {
    return BoardMaterialTableData(
      uuid: data.uuid.present ? data.uuid.value : this.uuid,
      typeIndex: data.typeIndex.present ? data.typeIndex.value : this.typeIndex,
      path: data.path.present ? data.path.value : this.path,
      boardUuid: data.boardUuid.present ? data.boardUuid.value : this.boardUuid,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('BoardMaterialTableData(')
          ..write('uuid: $uuid, ')
          ..write('typeIndex: $typeIndex, ')
          ..write('path: $path, ')
          ..write('boardUuid: $boardUuid, ')
          ..write('createdAt: $createdAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(uuid, typeIndex, path, boardUuid, createdAt);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is BoardMaterialTableData &&
          other.uuid == this.uuid &&
          other.typeIndex == this.typeIndex &&
          other.path == this.path &&
          other.boardUuid == this.boardUuid &&
          other.createdAt == this.createdAt);
}

class BoardMaterialTableCompanion
    extends UpdateCompanion<BoardMaterialTableData> {
  final Value<String> uuid;
  final Value<int> typeIndex;
  final Value<String> path;
  final Value<String> boardUuid;
  final Value<int> createdAt;
  final Value<int> rowid;
  const BoardMaterialTableCompanion({
    this.uuid = const Value.absent(),
    this.typeIndex = const Value.absent(),
    this.path = const Value.absent(),
    this.boardUuid = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  BoardMaterialTableCompanion.insert({
    required String uuid,
    required int typeIndex,
    required String path,
    required String boardUuid,
    required int createdAt,
    this.rowid = const Value.absent(),
  }) : uuid = Value(uuid),
       typeIndex = Value(typeIndex),
       path = Value(path),
       boardUuid = Value(boardUuid),
       createdAt = Value(createdAt);
  static Insertable<BoardMaterialTableData> custom({
    Expression<String>? uuid,
    Expression<int>? typeIndex,
    Expression<String>? path,
    Expression<String>? boardUuid,
    Expression<int>? createdAt,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (uuid != null) 'uuid': uuid,
      if (typeIndex != null) 'type_index': typeIndex,
      if (path != null) 'path': path,
      if (boardUuid != null) 'board_uuid': boardUuid,
      if (createdAt != null) 'created_at': createdAt,
      if (rowid != null) 'rowid': rowid,
    });
  }

  BoardMaterialTableCompanion copyWith({
    Value<String>? uuid,
    Value<int>? typeIndex,
    Value<String>? path,
    Value<String>? boardUuid,
    Value<int>? createdAt,
    Value<int>? rowid,
  }) {
    return BoardMaterialTableCompanion(
      uuid: uuid ?? this.uuid,
      typeIndex: typeIndex ?? this.typeIndex,
      path: path ?? this.path,
      boardUuid: boardUuid ?? this.boardUuid,
      createdAt: createdAt ?? this.createdAt,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (uuid.present) {
      map['uuid'] = Variable<String>(uuid.value);
    }
    if (typeIndex.present) {
      map['type_index'] = Variable<int>(typeIndex.value);
    }
    if (path.present) {
      map['path'] = Variable<String>(path.value);
    }
    if (boardUuid.present) {
      map['board_uuid'] = Variable<String>(boardUuid.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<int>(createdAt.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('BoardMaterialTableCompanion(')
          ..write('uuid: $uuid, ')
          ..write('typeIndex: $typeIndex, ')
          ..write('path: $path, ')
          ..write('boardUuid: $boardUuid, ')
          ..write('createdAt: $createdAt, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $BoardSessionTableTable extends BoardSessionTable
    with TableInfo<$BoardSessionTableTable, BoardSessionTableData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $BoardSessionTableTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _uuidMeta = const VerificationMeta('uuid');
  @override
  late final GeneratedColumn<String> uuid = GeneratedColumn<String>(
    'uuid',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _boardUuidMeta = const VerificationMeta(
    'boardUuid',
  );
  @override
  late final GeneratedColumn<String> boardUuid = GeneratedColumn<String>(
    'board_uuid',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _environmentIndexMeta = const VerificationMeta(
    'environmentIndex',
  );
  @override
  late final GeneratedColumn<int> environmentIndex = GeneratedColumn<int>(
    'environment_index',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _startedAtMeta = const VerificationMeta(
    'startedAt',
  );
  @override
  late final GeneratedColumn<int> startedAt = GeneratedColumn<int>(
    'started_at',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _endAtMeta = const VerificationMeta('endAt');
  @override
  late final GeneratedColumn<int> endAt = GeneratedColumn<int>(
    'end_at',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _updatedAtMeta = const VerificationMeta(
    'updatedAt',
  );
  @override
  late final GeneratedColumn<int> updatedAt = GeneratedColumn<int>(
    'updated_at',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  @override
  List<GeneratedColumn> get $columns => [
    uuid,
    boardUuid,
    environmentIndex,
    startedAt,
    endAt,
    updatedAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'board_session_table';
  @override
  VerificationContext validateIntegrity(
    Insertable<BoardSessionTableData> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('uuid')) {
      context.handle(
        _uuidMeta,
        uuid.isAcceptableOrUnknown(data['uuid']!, _uuidMeta),
      );
    } else if (isInserting) {
      context.missing(_uuidMeta);
    }
    if (data.containsKey('board_uuid')) {
      context.handle(
        _boardUuidMeta,
        boardUuid.isAcceptableOrUnknown(data['board_uuid']!, _boardUuidMeta),
      );
    } else if (isInserting) {
      context.missing(_boardUuidMeta);
    }
    if (data.containsKey('environment_index')) {
      context.handle(
        _environmentIndexMeta,
        environmentIndex.isAcceptableOrUnknown(
          data['environment_index']!,
          _environmentIndexMeta,
        ),
      );
    }
    if (data.containsKey('started_at')) {
      context.handle(
        _startedAtMeta,
        startedAt.isAcceptableOrUnknown(data['started_at']!, _startedAtMeta),
      );
    } else if (isInserting) {
      context.missing(_startedAtMeta);
    }
    if (data.containsKey('end_at')) {
      context.handle(
        _endAtMeta,
        endAt.isAcceptableOrUnknown(data['end_at']!, _endAtMeta),
      );
    }
    if (data.containsKey('updated_at')) {
      context.handle(
        _updatedAtMeta,
        updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta),
      );
    } else if (isInserting) {
      context.missing(_updatedAtMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {uuid};
  @override
  BoardSessionTableData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return BoardSessionTableData(
      uuid: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}uuid'],
      )!,
      boardUuid: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}board_uuid'],
      )!,
      environmentIndex: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}environment_index'],
      ),
      startedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}started_at'],
      )!,
      endAt: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}end_at'],
      ),
      updatedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}updated_at'],
      )!,
    );
  }

  @override
  $BoardSessionTableTable createAlias(String alias) {
    return $BoardSessionTableTable(attachedDatabase, alias);
  }
}

class BoardSessionTableData extends DataClass
    implements Insertable<BoardSessionTableData> {
  final String uuid;
  final String boardUuid;
  final int? environmentIndex;
  final int startedAt;
  final int? endAt;
  final int updatedAt;
  const BoardSessionTableData({
    required this.uuid,
    required this.boardUuid,
    this.environmentIndex,
    required this.startedAt,
    this.endAt,
    required this.updatedAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['uuid'] = Variable<String>(uuid);
    map['board_uuid'] = Variable<String>(boardUuid);
    if (!nullToAbsent || environmentIndex != null) {
      map['environment_index'] = Variable<int>(environmentIndex);
    }
    map['started_at'] = Variable<int>(startedAt);
    if (!nullToAbsent || endAt != null) {
      map['end_at'] = Variable<int>(endAt);
    }
    map['updated_at'] = Variable<int>(updatedAt);
    return map;
  }

  BoardSessionTableCompanion toCompanion(bool nullToAbsent) {
    return BoardSessionTableCompanion(
      uuid: Value(uuid),
      boardUuid: Value(boardUuid),
      environmentIndex: environmentIndex == null && nullToAbsent
          ? const Value.absent()
          : Value(environmentIndex),
      startedAt: Value(startedAt),
      endAt: endAt == null && nullToAbsent
          ? const Value.absent()
          : Value(endAt),
      updatedAt: Value(updatedAt),
    );
  }

  factory BoardSessionTableData.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return BoardSessionTableData(
      uuid: serializer.fromJson<String>(json['uuid']),
      boardUuid: serializer.fromJson<String>(json['boardUuid']),
      environmentIndex: serializer.fromJson<int?>(json['environmentIndex']),
      startedAt: serializer.fromJson<int>(json['startedAt']),
      endAt: serializer.fromJson<int?>(json['endAt']),
      updatedAt: serializer.fromJson<int>(json['updatedAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'uuid': serializer.toJson<String>(uuid),
      'boardUuid': serializer.toJson<String>(boardUuid),
      'environmentIndex': serializer.toJson<int?>(environmentIndex),
      'startedAt': serializer.toJson<int>(startedAt),
      'endAt': serializer.toJson<int?>(endAt),
      'updatedAt': serializer.toJson<int>(updatedAt),
    };
  }

  BoardSessionTableData copyWith({
    String? uuid,
    String? boardUuid,
    Value<int?> environmentIndex = const Value.absent(),
    int? startedAt,
    Value<int?> endAt = const Value.absent(),
    int? updatedAt,
  }) => BoardSessionTableData(
    uuid: uuid ?? this.uuid,
    boardUuid: boardUuid ?? this.boardUuid,
    environmentIndex: environmentIndex.present
        ? environmentIndex.value
        : this.environmentIndex,
    startedAt: startedAt ?? this.startedAt,
    endAt: endAt.present ? endAt.value : this.endAt,
    updatedAt: updatedAt ?? this.updatedAt,
  );
  BoardSessionTableData copyWithCompanion(BoardSessionTableCompanion data) {
    return BoardSessionTableData(
      uuid: data.uuid.present ? data.uuid.value : this.uuid,
      boardUuid: data.boardUuid.present ? data.boardUuid.value : this.boardUuid,
      environmentIndex: data.environmentIndex.present
          ? data.environmentIndex.value
          : this.environmentIndex,
      startedAt: data.startedAt.present ? data.startedAt.value : this.startedAt,
      endAt: data.endAt.present ? data.endAt.value : this.endAt,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('BoardSessionTableData(')
          ..write('uuid: $uuid, ')
          ..write('boardUuid: $boardUuid, ')
          ..write('environmentIndex: $environmentIndex, ')
          ..write('startedAt: $startedAt, ')
          ..write('endAt: $endAt, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    uuid,
    boardUuid,
    environmentIndex,
    startedAt,
    endAt,
    updatedAt,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is BoardSessionTableData &&
          other.uuid == this.uuid &&
          other.boardUuid == this.boardUuid &&
          other.environmentIndex == this.environmentIndex &&
          other.startedAt == this.startedAt &&
          other.endAt == this.endAt &&
          other.updatedAt == this.updatedAt);
}

class BoardSessionTableCompanion
    extends UpdateCompanion<BoardSessionTableData> {
  final Value<String> uuid;
  final Value<String> boardUuid;
  final Value<int?> environmentIndex;
  final Value<int> startedAt;
  final Value<int?> endAt;
  final Value<int> updatedAt;
  final Value<int> rowid;
  const BoardSessionTableCompanion({
    this.uuid = const Value.absent(),
    this.boardUuid = const Value.absent(),
    this.environmentIndex = const Value.absent(),
    this.startedAt = const Value.absent(),
    this.endAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  BoardSessionTableCompanion.insert({
    required String uuid,
    required String boardUuid,
    this.environmentIndex = const Value.absent(),
    required int startedAt,
    this.endAt = const Value.absent(),
    required int updatedAt,
    this.rowid = const Value.absent(),
  }) : uuid = Value(uuid),
       boardUuid = Value(boardUuid),
       startedAt = Value(startedAt),
       updatedAt = Value(updatedAt);
  static Insertable<BoardSessionTableData> custom({
    Expression<String>? uuid,
    Expression<String>? boardUuid,
    Expression<int>? environmentIndex,
    Expression<int>? startedAt,
    Expression<int>? endAt,
    Expression<int>? updatedAt,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (uuid != null) 'uuid': uuid,
      if (boardUuid != null) 'board_uuid': boardUuid,
      if (environmentIndex != null) 'environment_index': environmentIndex,
      if (startedAt != null) 'started_at': startedAt,
      if (endAt != null) 'end_at': endAt,
      if (updatedAt != null) 'updated_at': updatedAt,
      if (rowid != null) 'rowid': rowid,
    });
  }

  BoardSessionTableCompanion copyWith({
    Value<String>? uuid,
    Value<String>? boardUuid,
    Value<int?>? environmentIndex,
    Value<int>? startedAt,
    Value<int?>? endAt,
    Value<int>? updatedAt,
    Value<int>? rowid,
  }) {
    return BoardSessionTableCompanion(
      uuid: uuid ?? this.uuid,
      boardUuid: boardUuid ?? this.boardUuid,
      environmentIndex: environmentIndex ?? this.environmentIndex,
      startedAt: startedAt ?? this.startedAt,
      endAt: endAt ?? this.endAt,
      updatedAt: updatedAt ?? this.updatedAt,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (uuid.present) {
      map['uuid'] = Variable<String>(uuid.value);
    }
    if (boardUuid.present) {
      map['board_uuid'] = Variable<String>(boardUuid.value);
    }
    if (environmentIndex.present) {
      map['environment_index'] = Variable<int>(environmentIndex.value);
    }
    if (startedAt.present) {
      map['started_at'] = Variable<int>(startedAt.value);
    }
    if (endAt.present) {
      map['end_at'] = Variable<int>(endAt.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<int>(updatedAt.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('BoardSessionTableCompanion(')
          ..write('uuid: $uuid, ')
          ..write('boardUuid: $boardUuid, ')
          ..write('environmentIndex: $environmentIndex, ')
          ..write('startedAt: $startedAt, ')
          ..write('endAt: $endAt, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $BoardLinkTableTable extends BoardLinkTable
    with TableInfo<$BoardLinkTableTable, BoardLinkTableData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $BoardLinkTableTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _uuidMeta = const VerificationMeta('uuid');
  @override
  late final GeneratedColumn<String> uuid = GeneratedColumn<String>(
    'uuid',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _linkMeta = const VerificationMeta('link');
  @override
  late final GeneratedColumn<String> link = GeneratedColumn<String>(
    'link',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _boardUuidMeta = const VerificationMeta(
    'boardUuid',
  );
  @override
  late final GeneratedColumn<String> boardUuid = GeneratedColumn<String>(
    'board_uuid',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _titleMeta = const VerificationMeta('title');
  @override
  late final GeneratedColumn<String> title = GeneratedColumn<String>(
    'title',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<int> createdAt = GeneratedColumn<int>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _updatedAtMeta = const VerificationMeta(
    'updatedAt',
  );
  @override
  late final GeneratedColumn<int> updatedAt = GeneratedColumn<int>(
    'updated_at',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  @override
  List<GeneratedColumn> get $columns => [
    uuid,
    link,
    boardUuid,
    title,
    createdAt,
    updatedAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'board_link_table';
  @override
  VerificationContext validateIntegrity(
    Insertable<BoardLinkTableData> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('uuid')) {
      context.handle(
        _uuidMeta,
        uuid.isAcceptableOrUnknown(data['uuid']!, _uuidMeta),
      );
    } else if (isInserting) {
      context.missing(_uuidMeta);
    }
    if (data.containsKey('link')) {
      context.handle(
        _linkMeta,
        link.isAcceptableOrUnknown(data['link']!, _linkMeta),
      );
    } else if (isInserting) {
      context.missing(_linkMeta);
    }
    if (data.containsKey('board_uuid')) {
      context.handle(
        _boardUuidMeta,
        boardUuid.isAcceptableOrUnknown(data['board_uuid']!, _boardUuidMeta),
      );
    } else if (isInserting) {
      context.missing(_boardUuidMeta);
    }
    if (data.containsKey('title')) {
      context.handle(
        _titleMeta,
        title.isAcceptableOrUnknown(data['title']!, _titleMeta),
      );
    } else if (isInserting) {
      context.missing(_titleMeta);
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    } else if (isInserting) {
      context.missing(_createdAtMeta);
    }
    if (data.containsKey('updated_at')) {
      context.handle(
        _updatedAtMeta,
        updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta),
      );
    } else if (isInserting) {
      context.missing(_updatedAtMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {uuid};
  @override
  BoardLinkTableData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return BoardLinkTableData(
      uuid: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}uuid'],
      )!,
      link: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}link'],
      )!,
      boardUuid: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}board_uuid'],
      )!,
      title: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}title'],
      )!,
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}created_at'],
      )!,
      updatedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}updated_at'],
      )!,
    );
  }

  @override
  $BoardLinkTableTable createAlias(String alias) {
    return $BoardLinkTableTable(attachedDatabase, alias);
  }
}

class BoardLinkTableData extends DataClass
    implements Insertable<BoardLinkTableData> {
  final String uuid;
  final String link;
  final String boardUuid;
  final String title;
  final int createdAt;
  final int updatedAt;
  const BoardLinkTableData({
    required this.uuid,
    required this.link,
    required this.boardUuid,
    required this.title,
    required this.createdAt,
    required this.updatedAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['uuid'] = Variable<String>(uuid);
    map['link'] = Variable<String>(link);
    map['board_uuid'] = Variable<String>(boardUuid);
    map['title'] = Variable<String>(title);
    map['created_at'] = Variable<int>(createdAt);
    map['updated_at'] = Variable<int>(updatedAt);
    return map;
  }

  BoardLinkTableCompanion toCompanion(bool nullToAbsent) {
    return BoardLinkTableCompanion(
      uuid: Value(uuid),
      link: Value(link),
      boardUuid: Value(boardUuid),
      title: Value(title),
      createdAt: Value(createdAt),
      updatedAt: Value(updatedAt),
    );
  }

  factory BoardLinkTableData.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return BoardLinkTableData(
      uuid: serializer.fromJson<String>(json['uuid']),
      link: serializer.fromJson<String>(json['link']),
      boardUuid: serializer.fromJson<String>(json['boardUuid']),
      title: serializer.fromJson<String>(json['title']),
      createdAt: serializer.fromJson<int>(json['createdAt']),
      updatedAt: serializer.fromJson<int>(json['updatedAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'uuid': serializer.toJson<String>(uuid),
      'link': serializer.toJson<String>(link),
      'boardUuid': serializer.toJson<String>(boardUuid),
      'title': serializer.toJson<String>(title),
      'createdAt': serializer.toJson<int>(createdAt),
      'updatedAt': serializer.toJson<int>(updatedAt),
    };
  }

  BoardLinkTableData copyWith({
    String? uuid,
    String? link,
    String? boardUuid,
    String? title,
    int? createdAt,
    int? updatedAt,
  }) => BoardLinkTableData(
    uuid: uuid ?? this.uuid,
    link: link ?? this.link,
    boardUuid: boardUuid ?? this.boardUuid,
    title: title ?? this.title,
    createdAt: createdAt ?? this.createdAt,
    updatedAt: updatedAt ?? this.updatedAt,
  );
  BoardLinkTableData copyWithCompanion(BoardLinkTableCompanion data) {
    return BoardLinkTableData(
      uuid: data.uuid.present ? data.uuid.value : this.uuid,
      link: data.link.present ? data.link.value : this.link,
      boardUuid: data.boardUuid.present ? data.boardUuid.value : this.boardUuid,
      title: data.title.present ? data.title.value : this.title,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('BoardLinkTableData(')
          ..write('uuid: $uuid, ')
          ..write('link: $link, ')
          ..write('boardUuid: $boardUuid, ')
          ..write('title: $title, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode =>
      Object.hash(uuid, link, boardUuid, title, createdAt, updatedAt);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is BoardLinkTableData &&
          other.uuid == this.uuid &&
          other.link == this.link &&
          other.boardUuid == this.boardUuid &&
          other.title == this.title &&
          other.createdAt == this.createdAt &&
          other.updatedAt == this.updatedAt);
}

class BoardLinkTableCompanion extends UpdateCompanion<BoardLinkTableData> {
  final Value<String> uuid;
  final Value<String> link;
  final Value<String> boardUuid;
  final Value<String> title;
  final Value<int> createdAt;
  final Value<int> updatedAt;
  final Value<int> rowid;
  const BoardLinkTableCompanion({
    this.uuid = const Value.absent(),
    this.link = const Value.absent(),
    this.boardUuid = const Value.absent(),
    this.title = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  BoardLinkTableCompanion.insert({
    required String uuid,
    required String link,
    required String boardUuid,
    required String title,
    required int createdAt,
    required int updatedAt,
    this.rowid = const Value.absent(),
  }) : uuid = Value(uuid),
       link = Value(link),
       boardUuid = Value(boardUuid),
       title = Value(title),
       createdAt = Value(createdAt),
       updatedAt = Value(updatedAt);
  static Insertable<BoardLinkTableData> custom({
    Expression<String>? uuid,
    Expression<String>? link,
    Expression<String>? boardUuid,
    Expression<String>? title,
    Expression<int>? createdAt,
    Expression<int>? updatedAt,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (uuid != null) 'uuid': uuid,
      if (link != null) 'link': link,
      if (boardUuid != null) 'board_uuid': boardUuid,
      if (title != null) 'title': title,
      if (createdAt != null) 'created_at': createdAt,
      if (updatedAt != null) 'updated_at': updatedAt,
      if (rowid != null) 'rowid': rowid,
    });
  }

  BoardLinkTableCompanion copyWith({
    Value<String>? uuid,
    Value<String>? link,
    Value<String>? boardUuid,
    Value<String>? title,
    Value<int>? createdAt,
    Value<int>? updatedAt,
    Value<int>? rowid,
  }) {
    return BoardLinkTableCompanion(
      uuid: uuid ?? this.uuid,
      link: link ?? this.link,
      boardUuid: boardUuid ?? this.boardUuid,
      title: title ?? this.title,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (uuid.present) {
      map['uuid'] = Variable<String>(uuid.value);
    }
    if (link.present) {
      map['link'] = Variable<String>(link.value);
    }
    if (boardUuid.present) {
      map['board_uuid'] = Variable<String>(boardUuid.value);
    }
    if (title.present) {
      map['title'] = Variable<String>(title.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<int>(createdAt.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<int>(updatedAt.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('BoardLinkTableCompanion(')
          ..write('uuid: $uuid, ')
          ..write('link: $link, ')
          ..write('boardUuid: $boardUuid, ')
          ..write('title: $title, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $BoardPlayerTableTable extends BoardPlayerTable
    with TableInfo<$BoardPlayerTableTable, BoardPlayerTableData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $BoardPlayerTableTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _uuidMeta = const VerificationMeta('uuid');
  @override
  late final GeneratedColumn<String> uuid = GeneratedColumn<String>(
    'uuid',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _boardUuidMeta = const VerificationMeta(
    'boardUuid',
  );
  @override
  late final GeneratedColumn<String> boardUuid = GeneratedColumn<String>(
    'board_uuid',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _characterNameMeta = const VerificationMeta(
    'characterName',
  );
  @override
  late final GeneratedColumn<String> characterName = GeneratedColumn<String>(
    'character_name',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _playerNameMeta = const VerificationMeta(
    'playerName',
  );
  @override
  late final GeneratedColumn<String> playerName = GeneratedColumn<String>(
    'player_name',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _imagePathMeta = const VerificationMeta(
    'imagePath',
  );
  @override
  late final GeneratedColumn<String> imagePath = GeneratedColumn<String>(
    'image_path',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _imageAssetMeta = const VerificationMeta(
    'imageAsset',
  );
  @override
  late final GeneratedColumn<String> imageAsset = GeneratedColumn<String>(
    'image_asset',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _broodIndexMeta = const VerificationMeta(
    'broodIndex',
  );
  @override
  late final GeneratedColumn<int> broodIndex = GeneratedColumn<int>(
    'brood_index',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<int> createdAt = GeneratedColumn<int>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _updatedAtMeta = const VerificationMeta(
    'updatedAt',
  );
  @override
  late final GeneratedColumn<int> updatedAt = GeneratedColumn<int>(
    'updated_at',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _lifeMeta = const VerificationMeta('life');
  @override
  late final GeneratedColumn<int> life = GeneratedColumn<int>(
    'life',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _manaMeta = const VerificationMeta('mana');
  @override
  late final GeneratedColumn<int> mana = GeneratedColumn<int>(
    'mana',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _defenseMeta = const VerificationMeta(
    'defense',
  );
  @override
  late final GeneratedColumn<int> defense = GeneratedColumn<int>(
    'defense',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _initiativeMeta = const VerificationMeta(
    'initiative',
  );
  @override
  late final GeneratedColumn<int> initiative = GeneratedColumn<int>(
    'initiative',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _isAliveMeta = const VerificationMeta(
    'isAlive',
  );
  @override
  late final GeneratedColumn<bool> isAlive = GeneratedColumn<bool>(
    'is_alive',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_alive" IN (0, 1))',
    ),
  );
  static const VerificationMeta _classeIndexesMeta = const VerificationMeta(
    'classeIndexes',
  );
  @override
  late final GeneratedColumn<String> classeIndexes = GeneratedColumn<String>(
    'classe_indexes',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  @override
  List<GeneratedColumn> get $columns => [
    uuid,
    boardUuid,
    characterName,
    playerName,
    imagePath,
    imageAsset,
    broodIndex,
    createdAt,
    updatedAt,
    life,
    mana,
    defense,
    initiative,
    isAlive,
    classeIndexes,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'board_player_table';
  @override
  VerificationContext validateIntegrity(
    Insertable<BoardPlayerTableData> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('uuid')) {
      context.handle(
        _uuidMeta,
        uuid.isAcceptableOrUnknown(data['uuid']!, _uuidMeta),
      );
    } else if (isInserting) {
      context.missing(_uuidMeta);
    }
    if (data.containsKey('board_uuid')) {
      context.handle(
        _boardUuidMeta,
        boardUuid.isAcceptableOrUnknown(data['board_uuid']!, _boardUuidMeta),
      );
    } else if (isInserting) {
      context.missing(_boardUuidMeta);
    }
    if (data.containsKey('character_name')) {
      context.handle(
        _characterNameMeta,
        characterName.isAcceptableOrUnknown(
          data['character_name']!,
          _characterNameMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_characterNameMeta);
    }
    if (data.containsKey('player_name')) {
      context.handle(
        _playerNameMeta,
        playerName.isAcceptableOrUnknown(data['player_name']!, _playerNameMeta),
      );
    } else if (isInserting) {
      context.missing(_playerNameMeta);
    }
    if (data.containsKey('image_path')) {
      context.handle(
        _imagePathMeta,
        imagePath.isAcceptableOrUnknown(data['image_path']!, _imagePathMeta),
      );
    }
    if (data.containsKey('image_asset')) {
      context.handle(
        _imageAssetMeta,
        imageAsset.isAcceptableOrUnknown(data['image_asset']!, _imageAssetMeta),
      );
    }
    if (data.containsKey('brood_index')) {
      context.handle(
        _broodIndexMeta,
        broodIndex.isAcceptableOrUnknown(data['brood_index']!, _broodIndexMeta),
      );
    } else if (isInserting) {
      context.missing(_broodIndexMeta);
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    } else if (isInserting) {
      context.missing(_createdAtMeta);
    }
    if (data.containsKey('updated_at')) {
      context.handle(
        _updatedAtMeta,
        updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta),
      );
    } else if (isInserting) {
      context.missing(_updatedAtMeta);
    }
    if (data.containsKey('life')) {
      context.handle(
        _lifeMeta,
        life.isAcceptableOrUnknown(data['life']!, _lifeMeta),
      );
    } else if (isInserting) {
      context.missing(_lifeMeta);
    }
    if (data.containsKey('mana')) {
      context.handle(
        _manaMeta,
        mana.isAcceptableOrUnknown(data['mana']!, _manaMeta),
      );
    } else if (isInserting) {
      context.missing(_manaMeta);
    }
    if (data.containsKey('defense')) {
      context.handle(
        _defenseMeta,
        defense.isAcceptableOrUnknown(data['defense']!, _defenseMeta),
      );
    } else if (isInserting) {
      context.missing(_defenseMeta);
    }
    if (data.containsKey('initiative')) {
      context.handle(
        _initiativeMeta,
        initiative.isAcceptableOrUnknown(data['initiative']!, _initiativeMeta),
      );
    } else if (isInserting) {
      context.missing(_initiativeMeta);
    }
    if (data.containsKey('is_alive')) {
      context.handle(
        _isAliveMeta,
        isAlive.isAcceptableOrUnknown(data['is_alive']!, _isAliveMeta),
      );
    } else if (isInserting) {
      context.missing(_isAliveMeta);
    }
    if (data.containsKey('classe_indexes')) {
      context.handle(
        _classeIndexesMeta,
        classeIndexes.isAcceptableOrUnknown(
          data['classe_indexes']!,
          _classeIndexesMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_classeIndexesMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {uuid};
  @override
  BoardPlayerTableData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return BoardPlayerTableData(
      uuid: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}uuid'],
      )!,
      boardUuid: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}board_uuid'],
      )!,
      characterName: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}character_name'],
      )!,
      playerName: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}player_name'],
      )!,
      imagePath: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}image_path'],
      ),
      imageAsset: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}image_asset'],
      ),
      broodIndex: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}brood_index'],
      )!,
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}created_at'],
      )!,
      updatedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}updated_at'],
      )!,
      life: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}life'],
      )!,
      mana: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}mana'],
      )!,
      defense: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}defense'],
      )!,
      initiative: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}initiative'],
      )!,
      isAlive: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_alive'],
      )!,
      classeIndexes: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}classe_indexes'],
      )!,
    );
  }

  @override
  $BoardPlayerTableTable createAlias(String alias) {
    return $BoardPlayerTableTable(attachedDatabase, alias);
  }
}

class BoardPlayerTableData extends DataClass
    implements Insertable<BoardPlayerTableData> {
  final String uuid;
  final String boardUuid;
  final String characterName;
  final String playerName;
  final String? imagePath;
  final String? imageAsset;
  final int broodIndex;
  final int createdAt;
  final int updatedAt;
  final int life;
  final int mana;
  final int defense;
  final int initiative;
  final bool isAlive;
  final String classeIndexes;
  const BoardPlayerTableData({
    required this.uuid,
    required this.boardUuid,
    required this.characterName,
    required this.playerName,
    this.imagePath,
    this.imageAsset,
    required this.broodIndex,
    required this.createdAt,
    required this.updatedAt,
    required this.life,
    required this.mana,
    required this.defense,
    required this.initiative,
    required this.isAlive,
    required this.classeIndexes,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['uuid'] = Variable<String>(uuid);
    map['board_uuid'] = Variable<String>(boardUuid);
    map['character_name'] = Variable<String>(characterName);
    map['player_name'] = Variable<String>(playerName);
    if (!nullToAbsent || imagePath != null) {
      map['image_path'] = Variable<String>(imagePath);
    }
    if (!nullToAbsent || imageAsset != null) {
      map['image_asset'] = Variable<String>(imageAsset);
    }
    map['brood_index'] = Variable<int>(broodIndex);
    map['created_at'] = Variable<int>(createdAt);
    map['updated_at'] = Variable<int>(updatedAt);
    map['life'] = Variable<int>(life);
    map['mana'] = Variable<int>(mana);
    map['defense'] = Variable<int>(defense);
    map['initiative'] = Variable<int>(initiative);
    map['is_alive'] = Variable<bool>(isAlive);
    map['classe_indexes'] = Variable<String>(classeIndexes);
    return map;
  }

  BoardPlayerTableCompanion toCompanion(bool nullToAbsent) {
    return BoardPlayerTableCompanion(
      uuid: Value(uuid),
      boardUuid: Value(boardUuid),
      characterName: Value(characterName),
      playerName: Value(playerName),
      imagePath: imagePath == null && nullToAbsent
          ? const Value.absent()
          : Value(imagePath),
      imageAsset: imageAsset == null && nullToAbsent
          ? const Value.absent()
          : Value(imageAsset),
      broodIndex: Value(broodIndex),
      createdAt: Value(createdAt),
      updatedAt: Value(updatedAt),
      life: Value(life),
      mana: Value(mana),
      defense: Value(defense),
      initiative: Value(initiative),
      isAlive: Value(isAlive),
      classeIndexes: Value(classeIndexes),
    );
  }

  factory BoardPlayerTableData.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return BoardPlayerTableData(
      uuid: serializer.fromJson<String>(json['uuid']),
      boardUuid: serializer.fromJson<String>(json['boardUuid']),
      characterName: serializer.fromJson<String>(json['characterName']),
      playerName: serializer.fromJson<String>(json['playerName']),
      imagePath: serializer.fromJson<String?>(json['imagePath']),
      imageAsset: serializer.fromJson<String?>(json['imageAsset']),
      broodIndex: serializer.fromJson<int>(json['broodIndex']),
      createdAt: serializer.fromJson<int>(json['createdAt']),
      updatedAt: serializer.fromJson<int>(json['updatedAt']),
      life: serializer.fromJson<int>(json['life']),
      mana: serializer.fromJson<int>(json['mana']),
      defense: serializer.fromJson<int>(json['defense']),
      initiative: serializer.fromJson<int>(json['initiative']),
      isAlive: serializer.fromJson<bool>(json['isAlive']),
      classeIndexes: serializer.fromJson<String>(json['classeIndexes']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'uuid': serializer.toJson<String>(uuid),
      'boardUuid': serializer.toJson<String>(boardUuid),
      'characterName': serializer.toJson<String>(characterName),
      'playerName': serializer.toJson<String>(playerName),
      'imagePath': serializer.toJson<String?>(imagePath),
      'imageAsset': serializer.toJson<String?>(imageAsset),
      'broodIndex': serializer.toJson<int>(broodIndex),
      'createdAt': serializer.toJson<int>(createdAt),
      'updatedAt': serializer.toJson<int>(updatedAt),
      'life': serializer.toJson<int>(life),
      'mana': serializer.toJson<int>(mana),
      'defense': serializer.toJson<int>(defense),
      'initiative': serializer.toJson<int>(initiative),
      'isAlive': serializer.toJson<bool>(isAlive),
      'classeIndexes': serializer.toJson<String>(classeIndexes),
    };
  }

  BoardPlayerTableData copyWith({
    String? uuid,
    String? boardUuid,
    String? characterName,
    String? playerName,
    Value<String?> imagePath = const Value.absent(),
    Value<String?> imageAsset = const Value.absent(),
    int? broodIndex,
    int? createdAt,
    int? updatedAt,
    int? life,
    int? mana,
    int? defense,
    int? initiative,
    bool? isAlive,
    String? classeIndexes,
  }) => BoardPlayerTableData(
    uuid: uuid ?? this.uuid,
    boardUuid: boardUuid ?? this.boardUuid,
    characterName: characterName ?? this.characterName,
    playerName: playerName ?? this.playerName,
    imagePath: imagePath.present ? imagePath.value : this.imagePath,
    imageAsset: imageAsset.present ? imageAsset.value : this.imageAsset,
    broodIndex: broodIndex ?? this.broodIndex,
    createdAt: createdAt ?? this.createdAt,
    updatedAt: updatedAt ?? this.updatedAt,
    life: life ?? this.life,
    mana: mana ?? this.mana,
    defense: defense ?? this.defense,
    initiative: initiative ?? this.initiative,
    isAlive: isAlive ?? this.isAlive,
    classeIndexes: classeIndexes ?? this.classeIndexes,
  );
  BoardPlayerTableData copyWithCompanion(BoardPlayerTableCompanion data) {
    return BoardPlayerTableData(
      uuid: data.uuid.present ? data.uuid.value : this.uuid,
      boardUuid: data.boardUuid.present ? data.boardUuid.value : this.boardUuid,
      characterName: data.characterName.present
          ? data.characterName.value
          : this.characterName,
      playerName: data.playerName.present
          ? data.playerName.value
          : this.playerName,
      imagePath: data.imagePath.present ? data.imagePath.value : this.imagePath,
      imageAsset: data.imageAsset.present
          ? data.imageAsset.value
          : this.imageAsset,
      broodIndex: data.broodIndex.present
          ? data.broodIndex.value
          : this.broodIndex,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
      life: data.life.present ? data.life.value : this.life,
      mana: data.mana.present ? data.mana.value : this.mana,
      defense: data.defense.present ? data.defense.value : this.defense,
      initiative: data.initiative.present
          ? data.initiative.value
          : this.initiative,
      isAlive: data.isAlive.present ? data.isAlive.value : this.isAlive,
      classeIndexes: data.classeIndexes.present
          ? data.classeIndexes.value
          : this.classeIndexes,
    );
  }

  @override
  String toString() {
    return (StringBuffer('BoardPlayerTableData(')
          ..write('uuid: $uuid, ')
          ..write('boardUuid: $boardUuid, ')
          ..write('characterName: $characterName, ')
          ..write('playerName: $playerName, ')
          ..write('imagePath: $imagePath, ')
          ..write('imageAsset: $imageAsset, ')
          ..write('broodIndex: $broodIndex, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('life: $life, ')
          ..write('mana: $mana, ')
          ..write('defense: $defense, ')
          ..write('initiative: $initiative, ')
          ..write('isAlive: $isAlive, ')
          ..write('classeIndexes: $classeIndexes')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    uuid,
    boardUuid,
    characterName,
    playerName,
    imagePath,
    imageAsset,
    broodIndex,
    createdAt,
    updatedAt,
    life,
    mana,
    defense,
    initiative,
    isAlive,
    classeIndexes,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is BoardPlayerTableData &&
          other.uuid == this.uuid &&
          other.boardUuid == this.boardUuid &&
          other.characterName == this.characterName &&
          other.playerName == this.playerName &&
          other.imagePath == this.imagePath &&
          other.imageAsset == this.imageAsset &&
          other.broodIndex == this.broodIndex &&
          other.createdAt == this.createdAt &&
          other.updatedAt == this.updatedAt &&
          other.life == this.life &&
          other.mana == this.mana &&
          other.defense == this.defense &&
          other.initiative == this.initiative &&
          other.isAlive == this.isAlive &&
          other.classeIndexes == this.classeIndexes);
}

class BoardPlayerTableCompanion extends UpdateCompanion<BoardPlayerTableData> {
  final Value<String> uuid;
  final Value<String> boardUuid;
  final Value<String> characterName;
  final Value<String> playerName;
  final Value<String?> imagePath;
  final Value<String?> imageAsset;
  final Value<int> broodIndex;
  final Value<int> createdAt;
  final Value<int> updatedAt;
  final Value<int> life;
  final Value<int> mana;
  final Value<int> defense;
  final Value<int> initiative;
  final Value<bool> isAlive;
  final Value<String> classeIndexes;
  final Value<int> rowid;
  const BoardPlayerTableCompanion({
    this.uuid = const Value.absent(),
    this.boardUuid = const Value.absent(),
    this.characterName = const Value.absent(),
    this.playerName = const Value.absent(),
    this.imagePath = const Value.absent(),
    this.imageAsset = const Value.absent(),
    this.broodIndex = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.life = const Value.absent(),
    this.mana = const Value.absent(),
    this.defense = const Value.absent(),
    this.initiative = const Value.absent(),
    this.isAlive = const Value.absent(),
    this.classeIndexes = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  BoardPlayerTableCompanion.insert({
    required String uuid,
    required String boardUuid,
    required String characterName,
    required String playerName,
    this.imagePath = const Value.absent(),
    this.imageAsset = const Value.absent(),
    required int broodIndex,
    required int createdAt,
    required int updatedAt,
    required int life,
    required int mana,
    required int defense,
    required int initiative,
    required bool isAlive,
    required String classeIndexes,
    this.rowid = const Value.absent(),
  }) : uuid = Value(uuid),
       boardUuid = Value(boardUuid),
       characterName = Value(characterName),
       playerName = Value(playerName),
       broodIndex = Value(broodIndex),
       createdAt = Value(createdAt),
       updatedAt = Value(updatedAt),
       life = Value(life),
       mana = Value(mana),
       defense = Value(defense),
       initiative = Value(initiative),
       isAlive = Value(isAlive),
       classeIndexes = Value(classeIndexes);
  static Insertable<BoardPlayerTableData> custom({
    Expression<String>? uuid,
    Expression<String>? boardUuid,
    Expression<String>? characterName,
    Expression<String>? playerName,
    Expression<String>? imagePath,
    Expression<String>? imageAsset,
    Expression<int>? broodIndex,
    Expression<int>? createdAt,
    Expression<int>? updatedAt,
    Expression<int>? life,
    Expression<int>? mana,
    Expression<int>? defense,
    Expression<int>? initiative,
    Expression<bool>? isAlive,
    Expression<String>? classeIndexes,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (uuid != null) 'uuid': uuid,
      if (boardUuid != null) 'board_uuid': boardUuid,
      if (characterName != null) 'character_name': characterName,
      if (playerName != null) 'player_name': playerName,
      if (imagePath != null) 'image_path': imagePath,
      if (imageAsset != null) 'image_asset': imageAsset,
      if (broodIndex != null) 'brood_index': broodIndex,
      if (createdAt != null) 'created_at': createdAt,
      if (updatedAt != null) 'updated_at': updatedAt,
      if (life != null) 'life': life,
      if (mana != null) 'mana': mana,
      if (defense != null) 'defense': defense,
      if (initiative != null) 'initiative': initiative,
      if (isAlive != null) 'is_alive': isAlive,
      if (classeIndexes != null) 'classe_indexes': classeIndexes,
      if (rowid != null) 'rowid': rowid,
    });
  }

  BoardPlayerTableCompanion copyWith({
    Value<String>? uuid,
    Value<String>? boardUuid,
    Value<String>? characterName,
    Value<String>? playerName,
    Value<String?>? imagePath,
    Value<String?>? imageAsset,
    Value<int>? broodIndex,
    Value<int>? createdAt,
    Value<int>? updatedAt,
    Value<int>? life,
    Value<int>? mana,
    Value<int>? defense,
    Value<int>? initiative,
    Value<bool>? isAlive,
    Value<String>? classeIndexes,
    Value<int>? rowid,
  }) {
    return BoardPlayerTableCompanion(
      uuid: uuid ?? this.uuid,
      boardUuid: boardUuid ?? this.boardUuid,
      characterName: characterName ?? this.characterName,
      playerName: playerName ?? this.playerName,
      imagePath: imagePath ?? this.imagePath,
      imageAsset: imageAsset ?? this.imageAsset,
      broodIndex: broodIndex ?? this.broodIndex,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
      life: life ?? this.life,
      mana: mana ?? this.mana,
      defense: defense ?? this.defense,
      initiative: initiative ?? this.initiative,
      isAlive: isAlive ?? this.isAlive,
      classeIndexes: classeIndexes ?? this.classeIndexes,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (uuid.present) {
      map['uuid'] = Variable<String>(uuid.value);
    }
    if (boardUuid.present) {
      map['board_uuid'] = Variable<String>(boardUuid.value);
    }
    if (characterName.present) {
      map['character_name'] = Variable<String>(characterName.value);
    }
    if (playerName.present) {
      map['player_name'] = Variable<String>(playerName.value);
    }
    if (imagePath.present) {
      map['image_path'] = Variable<String>(imagePath.value);
    }
    if (imageAsset.present) {
      map['image_asset'] = Variable<String>(imageAsset.value);
    }
    if (broodIndex.present) {
      map['brood_index'] = Variable<int>(broodIndex.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<int>(createdAt.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<int>(updatedAt.value);
    }
    if (life.present) {
      map['life'] = Variable<int>(life.value);
    }
    if (mana.present) {
      map['mana'] = Variable<int>(mana.value);
    }
    if (defense.present) {
      map['defense'] = Variable<int>(defense.value);
    }
    if (initiative.present) {
      map['initiative'] = Variable<int>(initiative.value);
    }
    if (isAlive.present) {
      map['is_alive'] = Variable<bool>(isAlive.value);
    }
    if (classeIndexes.present) {
      map['classe_indexes'] = Variable<String>(classeIndexes.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('BoardPlayerTableCompanion(')
          ..write('uuid: $uuid, ')
          ..write('boardUuid: $boardUuid, ')
          ..write('characterName: $characterName, ')
          ..write('playerName: $playerName, ')
          ..write('imagePath: $imagePath, ')
          ..write('imageAsset: $imageAsset, ')
          ..write('broodIndex: $broodIndex, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('life: $life, ')
          ..write('mana: $mana, ')
          ..write('defense: $defense, ')
          ..write('initiative: $initiative, ')
          ..write('isAlive: $isAlive, ')
          ..write('classeIndexes: $classeIndexes, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $BoardNoteTableTable extends BoardNoteTable
    with TableInfo<$BoardNoteTableTable, BoardNoteTableData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $BoardNoteTableTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _uuidMeta = const VerificationMeta('uuid');
  @override
  late final GeneratedColumn<String> uuid = GeneratedColumn<String>(
    'uuid',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _boardUuidMeta = const VerificationMeta(
    'boardUuid',
  );
  @override
  late final GeneratedColumn<String> boardUuid = GeneratedColumn<String>(
    'board_uuid',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _noteMeta = const VerificationMeta('note');
  @override
  late final GeneratedColumn<String> note = GeneratedColumn<String>(
    'note',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _isFavoritedMeta = const VerificationMeta(
    'isFavorited',
  );
  @override
  late final GeneratedColumn<bool> isFavorited = GeneratedColumn<bool>(
    'is_favorited',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_favorited" IN (0, 1))',
    ),
  );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<int> createdAt = GeneratedColumn<int>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _updatedAtMeta = const VerificationMeta(
    'updatedAt',
  );
  @override
  late final GeneratedColumn<int> updatedAt = GeneratedColumn<int>(
    'updated_at',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  @override
  List<GeneratedColumn> get $columns => [
    uuid,
    boardUuid,
    note,
    isFavorited,
    createdAt,
    updatedAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'board_note_table';
  @override
  VerificationContext validateIntegrity(
    Insertable<BoardNoteTableData> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('uuid')) {
      context.handle(
        _uuidMeta,
        uuid.isAcceptableOrUnknown(data['uuid']!, _uuidMeta),
      );
    } else if (isInserting) {
      context.missing(_uuidMeta);
    }
    if (data.containsKey('board_uuid')) {
      context.handle(
        _boardUuidMeta,
        boardUuid.isAcceptableOrUnknown(data['board_uuid']!, _boardUuidMeta),
      );
    } else if (isInserting) {
      context.missing(_boardUuidMeta);
    }
    if (data.containsKey('note')) {
      context.handle(
        _noteMeta,
        note.isAcceptableOrUnknown(data['note']!, _noteMeta),
      );
    } else if (isInserting) {
      context.missing(_noteMeta);
    }
    if (data.containsKey('is_favorited')) {
      context.handle(
        _isFavoritedMeta,
        isFavorited.isAcceptableOrUnknown(
          data['is_favorited']!,
          _isFavoritedMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_isFavoritedMeta);
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    } else if (isInserting) {
      context.missing(_createdAtMeta);
    }
    if (data.containsKey('updated_at')) {
      context.handle(
        _updatedAtMeta,
        updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta),
      );
    } else if (isInserting) {
      context.missing(_updatedAtMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {uuid};
  @override
  BoardNoteTableData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return BoardNoteTableData(
      uuid: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}uuid'],
      )!,
      boardUuid: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}board_uuid'],
      )!,
      note: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}note'],
      )!,
      isFavorited: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_favorited'],
      )!,
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}created_at'],
      )!,
      updatedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}updated_at'],
      )!,
    );
  }

  @override
  $BoardNoteTableTable createAlias(String alias) {
    return $BoardNoteTableTable(attachedDatabase, alias);
  }
}

class BoardNoteTableData extends DataClass
    implements Insertable<BoardNoteTableData> {
  final String uuid;
  final String boardUuid;
  final String note;
  final bool isFavorited;
  final int createdAt;
  final int updatedAt;
  const BoardNoteTableData({
    required this.uuid,
    required this.boardUuid,
    required this.note,
    required this.isFavorited,
    required this.createdAt,
    required this.updatedAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['uuid'] = Variable<String>(uuid);
    map['board_uuid'] = Variable<String>(boardUuid);
    map['note'] = Variable<String>(note);
    map['is_favorited'] = Variable<bool>(isFavorited);
    map['created_at'] = Variable<int>(createdAt);
    map['updated_at'] = Variable<int>(updatedAt);
    return map;
  }

  BoardNoteTableCompanion toCompanion(bool nullToAbsent) {
    return BoardNoteTableCompanion(
      uuid: Value(uuid),
      boardUuid: Value(boardUuid),
      note: Value(note),
      isFavorited: Value(isFavorited),
      createdAt: Value(createdAt),
      updatedAt: Value(updatedAt),
    );
  }

  factory BoardNoteTableData.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return BoardNoteTableData(
      uuid: serializer.fromJson<String>(json['uuid']),
      boardUuid: serializer.fromJson<String>(json['boardUuid']),
      note: serializer.fromJson<String>(json['note']),
      isFavorited: serializer.fromJson<bool>(json['isFavorited']),
      createdAt: serializer.fromJson<int>(json['createdAt']),
      updatedAt: serializer.fromJson<int>(json['updatedAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'uuid': serializer.toJson<String>(uuid),
      'boardUuid': serializer.toJson<String>(boardUuid),
      'note': serializer.toJson<String>(note),
      'isFavorited': serializer.toJson<bool>(isFavorited),
      'createdAt': serializer.toJson<int>(createdAt),
      'updatedAt': serializer.toJson<int>(updatedAt),
    };
  }

  BoardNoteTableData copyWith({
    String? uuid,
    String? boardUuid,
    String? note,
    bool? isFavorited,
    int? createdAt,
    int? updatedAt,
  }) => BoardNoteTableData(
    uuid: uuid ?? this.uuid,
    boardUuid: boardUuid ?? this.boardUuid,
    note: note ?? this.note,
    isFavorited: isFavorited ?? this.isFavorited,
    createdAt: createdAt ?? this.createdAt,
    updatedAt: updatedAt ?? this.updatedAt,
  );
  BoardNoteTableData copyWithCompanion(BoardNoteTableCompanion data) {
    return BoardNoteTableData(
      uuid: data.uuid.present ? data.uuid.value : this.uuid,
      boardUuid: data.boardUuid.present ? data.boardUuid.value : this.boardUuid,
      note: data.note.present ? data.note.value : this.note,
      isFavorited: data.isFavorited.present
          ? data.isFavorited.value
          : this.isFavorited,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('BoardNoteTableData(')
          ..write('uuid: $uuid, ')
          ..write('boardUuid: $boardUuid, ')
          ..write('note: $note, ')
          ..write('isFavorited: $isFavorited, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode =>
      Object.hash(uuid, boardUuid, note, isFavorited, createdAt, updatedAt);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is BoardNoteTableData &&
          other.uuid == this.uuid &&
          other.boardUuid == this.boardUuid &&
          other.note == this.note &&
          other.isFavorited == this.isFavorited &&
          other.createdAt == this.createdAt &&
          other.updatedAt == this.updatedAt);
}

class BoardNoteTableCompanion extends UpdateCompanion<BoardNoteTableData> {
  final Value<String> uuid;
  final Value<String> boardUuid;
  final Value<String> note;
  final Value<bool> isFavorited;
  final Value<int> createdAt;
  final Value<int> updatedAt;
  final Value<int> rowid;
  const BoardNoteTableCompanion({
    this.uuid = const Value.absent(),
    this.boardUuid = const Value.absent(),
    this.note = const Value.absent(),
    this.isFavorited = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  BoardNoteTableCompanion.insert({
    required String uuid,
    required String boardUuid,
    required String note,
    required bool isFavorited,
    required int createdAt,
    required int updatedAt,
    this.rowid = const Value.absent(),
  }) : uuid = Value(uuid),
       boardUuid = Value(boardUuid),
       note = Value(note),
       isFavorited = Value(isFavorited),
       createdAt = Value(createdAt),
       updatedAt = Value(updatedAt);
  static Insertable<BoardNoteTableData> custom({
    Expression<String>? uuid,
    Expression<String>? boardUuid,
    Expression<String>? note,
    Expression<bool>? isFavorited,
    Expression<int>? createdAt,
    Expression<int>? updatedAt,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (uuid != null) 'uuid': uuid,
      if (boardUuid != null) 'board_uuid': boardUuid,
      if (note != null) 'note': note,
      if (isFavorited != null) 'is_favorited': isFavorited,
      if (createdAt != null) 'created_at': createdAt,
      if (updatedAt != null) 'updated_at': updatedAt,
      if (rowid != null) 'rowid': rowid,
    });
  }

  BoardNoteTableCompanion copyWith({
    Value<String>? uuid,
    Value<String>? boardUuid,
    Value<String>? note,
    Value<bool>? isFavorited,
    Value<int>? createdAt,
    Value<int>? updatedAt,
    Value<int>? rowid,
  }) {
    return BoardNoteTableCompanion(
      uuid: uuid ?? this.uuid,
      boardUuid: boardUuid ?? this.boardUuid,
      note: note ?? this.note,
      isFavorited: isFavorited ?? this.isFavorited,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (uuid.present) {
      map['uuid'] = Variable<String>(uuid.value);
    }
    if (boardUuid.present) {
      map['board_uuid'] = Variable<String>(boardUuid.value);
    }
    if (note.present) {
      map['note'] = Variable<String>(note.value);
    }
    if (isFavorited.present) {
      map['is_favorited'] = Variable<bool>(isFavorited.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<int>(createdAt.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<int>(updatedAt.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('BoardNoteTableCompanion(')
          ..write('uuid: $uuid, ')
          ..write('boardUuid: $boardUuid, ')
          ..write('note: $note, ')
          ..write('isFavorited: $isFavorited, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $BoardCombatTableTable extends BoardCombatTable
    with TableInfo<$BoardCombatTableTable, BoardCombatTableData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $BoardCombatTableTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _uuidMeta = const VerificationMeta('uuid');
  @override
  late final GeneratedColumn<String> uuid = GeneratedColumn<String>(
    'uuid',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _boardUuidMeta = const VerificationMeta(
    'boardUuid',
  );
  @override
  late final GeneratedColumn<String> boardUuid = GeneratedColumn<String>(
    'board_uuid',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _sessionUuidMeta = const VerificationMeta(
    'sessionUuid',
  );
  @override
  late final GeneratedColumn<String> sessionUuid = GeneratedColumn<String>(
    'session_uuid',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _turnMeta = const VerificationMeta('turn');
  @override
  late final GeneratedColumn<int> turn = GeneratedColumn<int>(
    'turn',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _startedAtMeta = const VerificationMeta(
    'startedAt',
  );
  @override
  late final GeneratedColumn<int> startedAt = GeneratedColumn<int>(
    'started_at',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _endAtMeta = const VerificationMeta('endAt');
  @override
  late final GeneratedColumn<int> endAt = GeneratedColumn<int>(
    'end_at',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  @override
  List<GeneratedColumn> get $columns => [
    uuid,
    boardUuid,
    sessionUuid,
    turn,
    startedAt,
    endAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'board_combat_table';
  @override
  VerificationContext validateIntegrity(
    Insertable<BoardCombatTableData> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('uuid')) {
      context.handle(
        _uuidMeta,
        uuid.isAcceptableOrUnknown(data['uuid']!, _uuidMeta),
      );
    } else if (isInserting) {
      context.missing(_uuidMeta);
    }
    if (data.containsKey('board_uuid')) {
      context.handle(
        _boardUuidMeta,
        boardUuid.isAcceptableOrUnknown(data['board_uuid']!, _boardUuidMeta),
      );
    } else if (isInserting) {
      context.missing(_boardUuidMeta);
    }
    if (data.containsKey('session_uuid')) {
      context.handle(
        _sessionUuidMeta,
        sessionUuid.isAcceptableOrUnknown(
          data['session_uuid']!,
          _sessionUuidMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_sessionUuidMeta);
    }
    if (data.containsKey('turn')) {
      context.handle(
        _turnMeta,
        turn.isAcceptableOrUnknown(data['turn']!, _turnMeta),
      );
    } else if (isInserting) {
      context.missing(_turnMeta);
    }
    if (data.containsKey('started_at')) {
      context.handle(
        _startedAtMeta,
        startedAt.isAcceptableOrUnknown(data['started_at']!, _startedAtMeta),
      );
    } else if (isInserting) {
      context.missing(_startedAtMeta);
    }
    if (data.containsKey('end_at')) {
      context.handle(
        _endAtMeta,
        endAt.isAcceptableOrUnknown(data['end_at']!, _endAtMeta),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {uuid};
  @override
  BoardCombatTableData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return BoardCombatTableData(
      uuid: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}uuid'],
      )!,
      boardUuid: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}board_uuid'],
      )!,
      sessionUuid: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}session_uuid'],
      )!,
      turn: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}turn'],
      )!,
      startedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}started_at'],
      )!,
      endAt: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}end_at'],
      ),
    );
  }

  @override
  $BoardCombatTableTable createAlias(String alias) {
    return $BoardCombatTableTable(attachedDatabase, alias);
  }
}

class BoardCombatTableData extends DataClass
    implements Insertable<BoardCombatTableData> {
  final String uuid;
  final String boardUuid;
  final String sessionUuid;
  final int turn;
  final int startedAt;
  final int? endAt;
  const BoardCombatTableData({
    required this.uuid,
    required this.boardUuid,
    required this.sessionUuid,
    required this.turn,
    required this.startedAt,
    this.endAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['uuid'] = Variable<String>(uuid);
    map['board_uuid'] = Variable<String>(boardUuid);
    map['session_uuid'] = Variable<String>(sessionUuid);
    map['turn'] = Variable<int>(turn);
    map['started_at'] = Variable<int>(startedAt);
    if (!nullToAbsent || endAt != null) {
      map['end_at'] = Variable<int>(endAt);
    }
    return map;
  }

  BoardCombatTableCompanion toCompanion(bool nullToAbsent) {
    return BoardCombatTableCompanion(
      uuid: Value(uuid),
      boardUuid: Value(boardUuid),
      sessionUuid: Value(sessionUuid),
      turn: Value(turn),
      startedAt: Value(startedAt),
      endAt: endAt == null && nullToAbsent
          ? const Value.absent()
          : Value(endAt),
    );
  }

  factory BoardCombatTableData.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return BoardCombatTableData(
      uuid: serializer.fromJson<String>(json['uuid']),
      boardUuid: serializer.fromJson<String>(json['boardUuid']),
      sessionUuid: serializer.fromJson<String>(json['sessionUuid']),
      turn: serializer.fromJson<int>(json['turn']),
      startedAt: serializer.fromJson<int>(json['startedAt']),
      endAt: serializer.fromJson<int?>(json['endAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'uuid': serializer.toJson<String>(uuid),
      'boardUuid': serializer.toJson<String>(boardUuid),
      'sessionUuid': serializer.toJson<String>(sessionUuid),
      'turn': serializer.toJson<int>(turn),
      'startedAt': serializer.toJson<int>(startedAt),
      'endAt': serializer.toJson<int?>(endAt),
    };
  }

  BoardCombatTableData copyWith({
    String? uuid,
    String? boardUuid,
    String? sessionUuid,
    int? turn,
    int? startedAt,
    Value<int?> endAt = const Value.absent(),
  }) => BoardCombatTableData(
    uuid: uuid ?? this.uuid,
    boardUuid: boardUuid ?? this.boardUuid,
    sessionUuid: sessionUuid ?? this.sessionUuid,
    turn: turn ?? this.turn,
    startedAt: startedAt ?? this.startedAt,
    endAt: endAt.present ? endAt.value : this.endAt,
  );
  BoardCombatTableData copyWithCompanion(BoardCombatTableCompanion data) {
    return BoardCombatTableData(
      uuid: data.uuid.present ? data.uuid.value : this.uuid,
      boardUuid: data.boardUuid.present ? data.boardUuid.value : this.boardUuid,
      sessionUuid: data.sessionUuid.present
          ? data.sessionUuid.value
          : this.sessionUuid,
      turn: data.turn.present ? data.turn.value : this.turn,
      startedAt: data.startedAt.present ? data.startedAt.value : this.startedAt,
      endAt: data.endAt.present ? data.endAt.value : this.endAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('BoardCombatTableData(')
          ..write('uuid: $uuid, ')
          ..write('boardUuid: $boardUuid, ')
          ..write('sessionUuid: $sessionUuid, ')
          ..write('turn: $turn, ')
          ..write('startedAt: $startedAt, ')
          ..write('endAt: $endAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode =>
      Object.hash(uuid, boardUuid, sessionUuid, turn, startedAt, endAt);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is BoardCombatTableData &&
          other.uuid == this.uuid &&
          other.boardUuid == this.boardUuid &&
          other.sessionUuid == this.sessionUuid &&
          other.turn == this.turn &&
          other.startedAt == this.startedAt &&
          other.endAt == this.endAt);
}

class BoardCombatTableCompanion extends UpdateCompanion<BoardCombatTableData> {
  final Value<String> uuid;
  final Value<String> boardUuid;
  final Value<String> sessionUuid;
  final Value<int> turn;
  final Value<int> startedAt;
  final Value<int?> endAt;
  final Value<int> rowid;
  const BoardCombatTableCompanion({
    this.uuid = const Value.absent(),
    this.boardUuid = const Value.absent(),
    this.sessionUuid = const Value.absent(),
    this.turn = const Value.absent(),
    this.startedAt = const Value.absent(),
    this.endAt = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  BoardCombatTableCompanion.insert({
    required String uuid,
    required String boardUuid,
    required String sessionUuid,
    required int turn,
    required int startedAt,
    this.endAt = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : uuid = Value(uuid),
       boardUuid = Value(boardUuid),
       sessionUuid = Value(sessionUuid),
       turn = Value(turn),
       startedAt = Value(startedAt);
  static Insertable<BoardCombatTableData> custom({
    Expression<String>? uuid,
    Expression<String>? boardUuid,
    Expression<String>? sessionUuid,
    Expression<int>? turn,
    Expression<int>? startedAt,
    Expression<int>? endAt,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (uuid != null) 'uuid': uuid,
      if (boardUuid != null) 'board_uuid': boardUuid,
      if (sessionUuid != null) 'session_uuid': sessionUuid,
      if (turn != null) 'turn': turn,
      if (startedAt != null) 'started_at': startedAt,
      if (endAt != null) 'end_at': endAt,
      if (rowid != null) 'rowid': rowid,
    });
  }

  BoardCombatTableCompanion copyWith({
    Value<String>? uuid,
    Value<String>? boardUuid,
    Value<String>? sessionUuid,
    Value<int>? turn,
    Value<int>? startedAt,
    Value<int?>? endAt,
    Value<int>? rowid,
  }) {
    return BoardCombatTableCompanion(
      uuid: uuid ?? this.uuid,
      boardUuid: boardUuid ?? this.boardUuid,
      sessionUuid: sessionUuid ?? this.sessionUuid,
      turn: turn ?? this.turn,
      startedAt: startedAt ?? this.startedAt,
      endAt: endAt ?? this.endAt,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (uuid.present) {
      map['uuid'] = Variable<String>(uuid.value);
    }
    if (boardUuid.present) {
      map['board_uuid'] = Variable<String>(boardUuid.value);
    }
    if (sessionUuid.present) {
      map['session_uuid'] = Variable<String>(sessionUuid.value);
    }
    if (turn.present) {
      map['turn'] = Variable<int>(turn.value);
    }
    if (startedAt.present) {
      map['started_at'] = Variable<int>(startedAt.value);
    }
    if (endAt.present) {
      map['end_at'] = Variable<int>(endAt.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('BoardCombatTableCompanion(')
          ..write('uuid: $uuid, ')
          ..write('boardUuid: $boardUuid, ')
          ..write('sessionUuid: $sessionUuid, ')
          ..write('turn: $turn, ')
          ..write('startedAt: $startedAt, ')
          ..write('endAt: $endAt, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $MenaceTableTable extends MenaceTable
    with TableInfo<$MenaceTableTable, MenaceTableData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $MenaceTableTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _uuidMeta = const VerificationMeta('uuid');
  @override
  late final GeneratedColumn<String> uuid = GeneratedColumn<String>(
    'uuid',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
    'name',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _imagePathMeta = const VerificationMeta(
    'imagePath',
  );
  @override
  late final GeneratedColumn<String> imagePath = GeneratedColumn<String>(
    'image_path',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _imageAssetMeta = const VerificationMeta(
    'imageAsset',
  );
  @override
  late final GeneratedColumn<String> imageAsset = GeneratedColumn<String>(
    'image_asset',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _displacementMeta = const VerificationMeta(
    'displacement',
  );
  @override
  late final GeneratedColumn<String> displacement = GeneratedColumn<String>(
    'displacement',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _casterInfosMeta = const VerificationMeta(
    'casterInfos',
  );
  @override
  late final GeneratedColumn<String> casterInfos = GeneratedColumn<String>(
    'caster_infos',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _descMeta = const VerificationMeta('desc');
  @override
  late final GeneratedColumn<String> desc = GeneratedColumn<String>(
    'desc',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _extraInfosMeta = const VerificationMeta(
    'extraInfos',
  );
  @override
  late final GeneratedColumn<String> extraInfos = GeneratedColumn<String>(
    'extra_infos',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _sensesMeta = const VerificationMeta('senses');
  @override
  late final GeneratedColumn<String> senses = GeneratedColumn<String>(
    'senses',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _ndMeta = const VerificationMeta('nd');
  @override
  late final GeneratedColumn<String> nd = GeneratedColumn<String>(
    'nd',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _divinityIdMeta = const VerificationMeta(
    'divinityId',
  );
  @override
  late final GeneratedColumn<int> divinityId = GeneratedColumn<int>(
    'divinity_id',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _initiativeMeta = const VerificationMeta(
    'initiative',
  );
  @override
  late final GeneratedColumn<int> initiative = GeneratedColumn<int>(
    'initiative',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _perceptionMeta = const VerificationMeta(
    'perception',
  );
  @override
  late final GeneratedColumn<int> perception = GeneratedColumn<int>(
    'perception',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _defenseMeta = const VerificationMeta(
    'defense',
  );
  @override
  late final GeneratedColumn<int> defense = GeneratedColumn<int>(
    'defense',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _lifeMeta = const VerificationMeta('life');
  @override
  late final GeneratedColumn<int> life = GeneratedColumn<int>(
    'life',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _manaMeta = const VerificationMeta('mana');
  @override
  late final GeneratedColumn<int> mana = GeneratedColumn<int>(
    'mana',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _fortResistenceMeta = const VerificationMeta(
    'fortResistence',
  );
  @override
  late final GeneratedColumn<int> fortResistence = GeneratedColumn<int>(
    'fort_resistence',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _refResistenceMeta = const VerificationMeta(
    'refResistence',
  );
  @override
  late final GeneratedColumn<int> refResistence = GeneratedColumn<int>(
    'ref_resistence',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _vonResistenceMeta = const VerificationMeta(
    'vonResistence',
  );
  @override
  late final GeneratedColumn<int> vonResistence = GeneratedColumn<int>(
    'von_resistence',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _strengthMeta = const VerificationMeta(
    'strength',
  );
  @override
  late final GeneratedColumn<int> strength = GeneratedColumn<int>(
    'strength',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _dexterityMeta = const VerificationMeta(
    'dexterity',
  );
  @override
  late final GeneratedColumn<int> dexterity = GeneratedColumn<int>(
    'dexterity',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _constitutionMeta = const VerificationMeta(
    'constitution',
  );
  @override
  late final GeneratedColumn<int> constitution = GeneratedColumn<int>(
    'constitution',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _intelligenceMeta = const VerificationMeta(
    'intelligence',
  );
  @override
  late final GeneratedColumn<int> intelligence = GeneratedColumn<int>(
    'intelligence',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _wisdomMeta = const VerificationMeta('wisdom');
  @override
  late final GeneratedColumn<int> wisdom = GeneratedColumn<int>(
    'wisdom',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _charismaMeta = const VerificationMeta(
    'charisma',
  );
  @override
  late final GeneratedColumn<int> charisma = GeneratedColumn<int>(
    'charisma',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _typeIndexMeta = const VerificationMeta(
    'typeIndex',
  );
  @override
  late final GeneratedColumn<int> typeIndex = GeneratedColumn<int>(
    'type_index',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _creatureSizeIndexMeta = const VerificationMeta(
    'creatureSizeIndex',
  );
  @override
  late final GeneratedColumn<int> creatureSizeIndex = GeneratedColumn<int>(
    'creature_size_index',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _combateRoleIndexMeta = const VerificationMeta(
    'combateRoleIndex',
  );
  @override
  late final GeneratedColumn<int> combateRoleIndex = GeneratedColumn<int>(
    'combate_role_index',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _treasureTypeIndexMeta = const VerificationMeta(
    'treasureTypeIndex',
  );
  @override
  late final GeneratedColumn<int> treasureTypeIndex = GeneratedColumn<int>(
    'treasure_type_index',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<int> createdAt = GeneratedColumn<int>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _updatedAtMeta = const VerificationMeta(
    'updatedAt',
  );
  @override
  late final GeneratedColumn<int> updatedAt = GeneratedColumn<int>(
    'updated_at',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  @override
  List<GeneratedColumn> get $columns => [
    uuid,
    name,
    imagePath,
    imageAsset,
    displacement,
    casterInfos,
    desc,
    extraInfos,
    senses,
    nd,
    divinityId,
    initiative,
    perception,
    defense,
    life,
    mana,
    fortResistence,
    refResistence,
    vonResistence,
    strength,
    dexterity,
    constitution,
    intelligence,
    wisdom,
    charisma,
    typeIndex,
    creatureSizeIndex,
    combateRoleIndex,
    treasureTypeIndex,
    createdAt,
    updatedAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'menace_table';
  @override
  VerificationContext validateIntegrity(
    Insertable<MenaceTableData> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('uuid')) {
      context.handle(
        _uuidMeta,
        uuid.isAcceptableOrUnknown(data['uuid']!, _uuidMeta),
      );
    } else if (isInserting) {
      context.missing(_uuidMeta);
    }
    if (data.containsKey('name')) {
      context.handle(
        _nameMeta,
        name.isAcceptableOrUnknown(data['name']!, _nameMeta),
      );
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    if (data.containsKey('image_path')) {
      context.handle(
        _imagePathMeta,
        imagePath.isAcceptableOrUnknown(data['image_path']!, _imagePathMeta),
      );
    }
    if (data.containsKey('image_asset')) {
      context.handle(
        _imageAssetMeta,
        imageAsset.isAcceptableOrUnknown(data['image_asset']!, _imageAssetMeta),
      );
    }
    if (data.containsKey('displacement')) {
      context.handle(
        _displacementMeta,
        displacement.isAcceptableOrUnknown(
          data['displacement']!,
          _displacementMeta,
        ),
      );
    }
    if (data.containsKey('caster_infos')) {
      context.handle(
        _casterInfosMeta,
        casterInfos.isAcceptableOrUnknown(
          data['caster_infos']!,
          _casterInfosMeta,
        ),
      );
    }
    if (data.containsKey('desc')) {
      context.handle(
        _descMeta,
        desc.isAcceptableOrUnknown(data['desc']!, _descMeta),
      );
    }
    if (data.containsKey('extra_infos')) {
      context.handle(
        _extraInfosMeta,
        extraInfos.isAcceptableOrUnknown(data['extra_infos']!, _extraInfosMeta),
      );
    }
    if (data.containsKey('senses')) {
      context.handle(
        _sensesMeta,
        senses.isAcceptableOrUnknown(data['senses']!, _sensesMeta),
      );
    }
    if (data.containsKey('nd')) {
      context.handle(_ndMeta, nd.isAcceptableOrUnknown(data['nd']!, _ndMeta));
    } else if (isInserting) {
      context.missing(_ndMeta);
    }
    if (data.containsKey('divinity_id')) {
      context.handle(
        _divinityIdMeta,
        divinityId.isAcceptableOrUnknown(data['divinity_id']!, _divinityIdMeta),
      );
    }
    if (data.containsKey('initiative')) {
      context.handle(
        _initiativeMeta,
        initiative.isAcceptableOrUnknown(data['initiative']!, _initiativeMeta),
      );
    } else if (isInserting) {
      context.missing(_initiativeMeta);
    }
    if (data.containsKey('perception')) {
      context.handle(
        _perceptionMeta,
        perception.isAcceptableOrUnknown(data['perception']!, _perceptionMeta),
      );
    } else if (isInserting) {
      context.missing(_perceptionMeta);
    }
    if (data.containsKey('defense')) {
      context.handle(
        _defenseMeta,
        defense.isAcceptableOrUnknown(data['defense']!, _defenseMeta),
      );
    } else if (isInserting) {
      context.missing(_defenseMeta);
    }
    if (data.containsKey('life')) {
      context.handle(
        _lifeMeta,
        life.isAcceptableOrUnknown(data['life']!, _lifeMeta),
      );
    } else if (isInserting) {
      context.missing(_lifeMeta);
    }
    if (data.containsKey('mana')) {
      context.handle(
        _manaMeta,
        mana.isAcceptableOrUnknown(data['mana']!, _manaMeta),
      );
    } else if (isInserting) {
      context.missing(_manaMeta);
    }
    if (data.containsKey('fort_resistence')) {
      context.handle(
        _fortResistenceMeta,
        fortResistence.isAcceptableOrUnknown(
          data['fort_resistence']!,
          _fortResistenceMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_fortResistenceMeta);
    }
    if (data.containsKey('ref_resistence')) {
      context.handle(
        _refResistenceMeta,
        refResistence.isAcceptableOrUnknown(
          data['ref_resistence']!,
          _refResistenceMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_refResistenceMeta);
    }
    if (data.containsKey('von_resistence')) {
      context.handle(
        _vonResistenceMeta,
        vonResistence.isAcceptableOrUnknown(
          data['von_resistence']!,
          _vonResistenceMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_vonResistenceMeta);
    }
    if (data.containsKey('strength')) {
      context.handle(
        _strengthMeta,
        strength.isAcceptableOrUnknown(data['strength']!, _strengthMeta),
      );
    } else if (isInserting) {
      context.missing(_strengthMeta);
    }
    if (data.containsKey('dexterity')) {
      context.handle(
        _dexterityMeta,
        dexterity.isAcceptableOrUnknown(data['dexterity']!, _dexterityMeta),
      );
    } else if (isInserting) {
      context.missing(_dexterityMeta);
    }
    if (data.containsKey('constitution')) {
      context.handle(
        _constitutionMeta,
        constitution.isAcceptableOrUnknown(
          data['constitution']!,
          _constitutionMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_constitutionMeta);
    }
    if (data.containsKey('intelligence')) {
      context.handle(
        _intelligenceMeta,
        intelligence.isAcceptableOrUnknown(
          data['intelligence']!,
          _intelligenceMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_intelligenceMeta);
    }
    if (data.containsKey('wisdom')) {
      context.handle(
        _wisdomMeta,
        wisdom.isAcceptableOrUnknown(data['wisdom']!, _wisdomMeta),
      );
    } else if (isInserting) {
      context.missing(_wisdomMeta);
    }
    if (data.containsKey('charisma')) {
      context.handle(
        _charismaMeta,
        charisma.isAcceptableOrUnknown(data['charisma']!, _charismaMeta),
      );
    } else if (isInserting) {
      context.missing(_charismaMeta);
    }
    if (data.containsKey('type_index')) {
      context.handle(
        _typeIndexMeta,
        typeIndex.isAcceptableOrUnknown(data['type_index']!, _typeIndexMeta),
      );
    } else if (isInserting) {
      context.missing(_typeIndexMeta);
    }
    if (data.containsKey('creature_size_index')) {
      context.handle(
        _creatureSizeIndexMeta,
        creatureSizeIndex.isAcceptableOrUnknown(
          data['creature_size_index']!,
          _creatureSizeIndexMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_creatureSizeIndexMeta);
    }
    if (data.containsKey('combate_role_index')) {
      context.handle(
        _combateRoleIndexMeta,
        combateRoleIndex.isAcceptableOrUnknown(
          data['combate_role_index']!,
          _combateRoleIndexMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_combateRoleIndexMeta);
    }
    if (data.containsKey('treasure_type_index')) {
      context.handle(
        _treasureTypeIndexMeta,
        treasureTypeIndex.isAcceptableOrUnknown(
          data['treasure_type_index']!,
          _treasureTypeIndexMeta,
        ),
      );
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    } else if (isInserting) {
      context.missing(_createdAtMeta);
    }
    if (data.containsKey('updated_at')) {
      context.handle(
        _updatedAtMeta,
        updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta),
      );
    } else if (isInserting) {
      context.missing(_updatedAtMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {uuid};
  @override
  MenaceTableData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return MenaceTableData(
      uuid: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}uuid'],
      )!,
      name: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}name'],
      )!,
      imagePath: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}image_path'],
      ),
      imageAsset: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}image_asset'],
      ),
      displacement: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}displacement'],
      ),
      casterInfos: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}caster_infos'],
      ),
      desc: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}desc'],
      ),
      extraInfos: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}extra_infos'],
      ),
      senses: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}senses'],
      ),
      nd: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}nd'],
      )!,
      divinityId: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}divinity_id'],
      ),
      initiative: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}initiative'],
      )!,
      perception: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}perception'],
      )!,
      defense: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}defense'],
      )!,
      life: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}life'],
      )!,
      mana: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}mana'],
      )!,
      fortResistence: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}fort_resistence'],
      )!,
      refResistence: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}ref_resistence'],
      )!,
      vonResistence: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}von_resistence'],
      )!,
      strength: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}strength'],
      )!,
      dexterity: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}dexterity'],
      )!,
      constitution: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}constitution'],
      )!,
      intelligence: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}intelligence'],
      )!,
      wisdom: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}wisdom'],
      )!,
      charisma: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}charisma'],
      )!,
      typeIndex: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}type_index'],
      )!,
      creatureSizeIndex: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}creature_size_index'],
      )!,
      combateRoleIndex: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}combate_role_index'],
      )!,
      treasureTypeIndex: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}treasure_type_index'],
      ),
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}created_at'],
      )!,
      updatedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}updated_at'],
      )!,
    );
  }

  @override
  $MenaceTableTable createAlias(String alias) {
    return $MenaceTableTable(attachedDatabase, alias);
  }
}

class MenaceTableData extends DataClass implements Insertable<MenaceTableData> {
  final String uuid;
  final String name;
  final String? imagePath;
  final String? imageAsset;
  final String? displacement;
  final String? casterInfos;
  final String? desc;
  final String? extraInfos;
  final String? senses;
  final String nd;
  final int? divinityId;
  final int initiative;
  final int perception;
  final int defense;
  final int life;
  final int mana;
  final int fortResistence;
  final int refResistence;
  final int vonResistence;
  final int strength;
  final int dexterity;
  final int constitution;
  final int intelligence;
  final int wisdom;
  final int charisma;
  final int typeIndex;
  final int creatureSizeIndex;
  final int combateRoleIndex;
  final int? treasureTypeIndex;
  final int createdAt;
  final int updatedAt;
  const MenaceTableData({
    required this.uuid,
    required this.name,
    this.imagePath,
    this.imageAsset,
    this.displacement,
    this.casterInfos,
    this.desc,
    this.extraInfos,
    this.senses,
    required this.nd,
    this.divinityId,
    required this.initiative,
    required this.perception,
    required this.defense,
    required this.life,
    required this.mana,
    required this.fortResistence,
    required this.refResistence,
    required this.vonResistence,
    required this.strength,
    required this.dexterity,
    required this.constitution,
    required this.intelligence,
    required this.wisdom,
    required this.charisma,
    required this.typeIndex,
    required this.creatureSizeIndex,
    required this.combateRoleIndex,
    this.treasureTypeIndex,
    required this.createdAt,
    required this.updatedAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['uuid'] = Variable<String>(uuid);
    map['name'] = Variable<String>(name);
    if (!nullToAbsent || imagePath != null) {
      map['image_path'] = Variable<String>(imagePath);
    }
    if (!nullToAbsent || imageAsset != null) {
      map['image_asset'] = Variable<String>(imageAsset);
    }
    if (!nullToAbsent || displacement != null) {
      map['displacement'] = Variable<String>(displacement);
    }
    if (!nullToAbsent || casterInfos != null) {
      map['caster_infos'] = Variable<String>(casterInfos);
    }
    if (!nullToAbsent || desc != null) {
      map['desc'] = Variable<String>(desc);
    }
    if (!nullToAbsent || extraInfos != null) {
      map['extra_infos'] = Variable<String>(extraInfos);
    }
    if (!nullToAbsent || senses != null) {
      map['senses'] = Variable<String>(senses);
    }
    map['nd'] = Variable<String>(nd);
    if (!nullToAbsent || divinityId != null) {
      map['divinity_id'] = Variable<int>(divinityId);
    }
    map['initiative'] = Variable<int>(initiative);
    map['perception'] = Variable<int>(perception);
    map['defense'] = Variable<int>(defense);
    map['life'] = Variable<int>(life);
    map['mana'] = Variable<int>(mana);
    map['fort_resistence'] = Variable<int>(fortResistence);
    map['ref_resistence'] = Variable<int>(refResistence);
    map['von_resistence'] = Variable<int>(vonResistence);
    map['strength'] = Variable<int>(strength);
    map['dexterity'] = Variable<int>(dexterity);
    map['constitution'] = Variable<int>(constitution);
    map['intelligence'] = Variable<int>(intelligence);
    map['wisdom'] = Variable<int>(wisdom);
    map['charisma'] = Variable<int>(charisma);
    map['type_index'] = Variable<int>(typeIndex);
    map['creature_size_index'] = Variable<int>(creatureSizeIndex);
    map['combate_role_index'] = Variable<int>(combateRoleIndex);
    if (!nullToAbsent || treasureTypeIndex != null) {
      map['treasure_type_index'] = Variable<int>(treasureTypeIndex);
    }
    map['created_at'] = Variable<int>(createdAt);
    map['updated_at'] = Variable<int>(updatedAt);
    return map;
  }

  MenaceTableCompanion toCompanion(bool nullToAbsent) {
    return MenaceTableCompanion(
      uuid: Value(uuid),
      name: Value(name),
      imagePath: imagePath == null && nullToAbsent
          ? const Value.absent()
          : Value(imagePath),
      imageAsset: imageAsset == null && nullToAbsent
          ? const Value.absent()
          : Value(imageAsset),
      displacement: displacement == null && nullToAbsent
          ? const Value.absent()
          : Value(displacement),
      casterInfos: casterInfos == null && nullToAbsent
          ? const Value.absent()
          : Value(casterInfos),
      desc: desc == null && nullToAbsent ? const Value.absent() : Value(desc),
      extraInfos: extraInfos == null && nullToAbsent
          ? const Value.absent()
          : Value(extraInfos),
      senses: senses == null && nullToAbsent
          ? const Value.absent()
          : Value(senses),
      nd: Value(nd),
      divinityId: divinityId == null && nullToAbsent
          ? const Value.absent()
          : Value(divinityId),
      initiative: Value(initiative),
      perception: Value(perception),
      defense: Value(defense),
      life: Value(life),
      mana: Value(mana),
      fortResistence: Value(fortResistence),
      refResistence: Value(refResistence),
      vonResistence: Value(vonResistence),
      strength: Value(strength),
      dexterity: Value(dexterity),
      constitution: Value(constitution),
      intelligence: Value(intelligence),
      wisdom: Value(wisdom),
      charisma: Value(charisma),
      typeIndex: Value(typeIndex),
      creatureSizeIndex: Value(creatureSizeIndex),
      combateRoleIndex: Value(combateRoleIndex),
      treasureTypeIndex: treasureTypeIndex == null && nullToAbsent
          ? const Value.absent()
          : Value(treasureTypeIndex),
      createdAt: Value(createdAt),
      updatedAt: Value(updatedAt),
    );
  }

  factory MenaceTableData.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return MenaceTableData(
      uuid: serializer.fromJson<String>(json['uuid']),
      name: serializer.fromJson<String>(json['name']),
      imagePath: serializer.fromJson<String?>(json['imagePath']),
      imageAsset: serializer.fromJson<String?>(json['imageAsset']),
      displacement: serializer.fromJson<String?>(json['displacement']),
      casterInfos: serializer.fromJson<String?>(json['casterInfos']),
      desc: serializer.fromJson<String?>(json['desc']),
      extraInfos: serializer.fromJson<String?>(json['extraInfos']),
      senses: serializer.fromJson<String?>(json['senses']),
      nd: serializer.fromJson<String>(json['nd']),
      divinityId: serializer.fromJson<int?>(json['divinityId']),
      initiative: serializer.fromJson<int>(json['initiative']),
      perception: serializer.fromJson<int>(json['perception']),
      defense: serializer.fromJson<int>(json['defense']),
      life: serializer.fromJson<int>(json['life']),
      mana: serializer.fromJson<int>(json['mana']),
      fortResistence: serializer.fromJson<int>(json['fortResistence']),
      refResistence: serializer.fromJson<int>(json['refResistence']),
      vonResistence: serializer.fromJson<int>(json['vonResistence']),
      strength: serializer.fromJson<int>(json['strength']),
      dexterity: serializer.fromJson<int>(json['dexterity']),
      constitution: serializer.fromJson<int>(json['constitution']),
      intelligence: serializer.fromJson<int>(json['intelligence']),
      wisdom: serializer.fromJson<int>(json['wisdom']),
      charisma: serializer.fromJson<int>(json['charisma']),
      typeIndex: serializer.fromJson<int>(json['typeIndex']),
      creatureSizeIndex: serializer.fromJson<int>(json['creatureSizeIndex']),
      combateRoleIndex: serializer.fromJson<int>(json['combateRoleIndex']),
      treasureTypeIndex: serializer.fromJson<int?>(json['treasureTypeIndex']),
      createdAt: serializer.fromJson<int>(json['createdAt']),
      updatedAt: serializer.fromJson<int>(json['updatedAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'uuid': serializer.toJson<String>(uuid),
      'name': serializer.toJson<String>(name),
      'imagePath': serializer.toJson<String?>(imagePath),
      'imageAsset': serializer.toJson<String?>(imageAsset),
      'displacement': serializer.toJson<String?>(displacement),
      'casterInfos': serializer.toJson<String?>(casterInfos),
      'desc': serializer.toJson<String?>(desc),
      'extraInfos': serializer.toJson<String?>(extraInfos),
      'senses': serializer.toJson<String?>(senses),
      'nd': serializer.toJson<String>(nd),
      'divinityId': serializer.toJson<int?>(divinityId),
      'initiative': serializer.toJson<int>(initiative),
      'perception': serializer.toJson<int>(perception),
      'defense': serializer.toJson<int>(defense),
      'life': serializer.toJson<int>(life),
      'mana': serializer.toJson<int>(mana),
      'fortResistence': serializer.toJson<int>(fortResistence),
      'refResistence': serializer.toJson<int>(refResistence),
      'vonResistence': serializer.toJson<int>(vonResistence),
      'strength': serializer.toJson<int>(strength),
      'dexterity': serializer.toJson<int>(dexterity),
      'constitution': serializer.toJson<int>(constitution),
      'intelligence': serializer.toJson<int>(intelligence),
      'wisdom': serializer.toJson<int>(wisdom),
      'charisma': serializer.toJson<int>(charisma),
      'typeIndex': serializer.toJson<int>(typeIndex),
      'creatureSizeIndex': serializer.toJson<int>(creatureSizeIndex),
      'combateRoleIndex': serializer.toJson<int>(combateRoleIndex),
      'treasureTypeIndex': serializer.toJson<int?>(treasureTypeIndex),
      'createdAt': serializer.toJson<int>(createdAt),
      'updatedAt': serializer.toJson<int>(updatedAt),
    };
  }

  MenaceTableData copyWith({
    String? uuid,
    String? name,
    Value<String?> imagePath = const Value.absent(),
    Value<String?> imageAsset = const Value.absent(),
    Value<String?> displacement = const Value.absent(),
    Value<String?> casterInfos = const Value.absent(),
    Value<String?> desc = const Value.absent(),
    Value<String?> extraInfos = const Value.absent(),
    Value<String?> senses = const Value.absent(),
    String? nd,
    Value<int?> divinityId = const Value.absent(),
    int? initiative,
    int? perception,
    int? defense,
    int? life,
    int? mana,
    int? fortResistence,
    int? refResistence,
    int? vonResistence,
    int? strength,
    int? dexterity,
    int? constitution,
    int? intelligence,
    int? wisdom,
    int? charisma,
    int? typeIndex,
    int? creatureSizeIndex,
    int? combateRoleIndex,
    Value<int?> treasureTypeIndex = const Value.absent(),
    int? createdAt,
    int? updatedAt,
  }) => MenaceTableData(
    uuid: uuid ?? this.uuid,
    name: name ?? this.name,
    imagePath: imagePath.present ? imagePath.value : this.imagePath,
    imageAsset: imageAsset.present ? imageAsset.value : this.imageAsset,
    displacement: displacement.present ? displacement.value : this.displacement,
    casterInfos: casterInfos.present ? casterInfos.value : this.casterInfos,
    desc: desc.present ? desc.value : this.desc,
    extraInfos: extraInfos.present ? extraInfos.value : this.extraInfos,
    senses: senses.present ? senses.value : this.senses,
    nd: nd ?? this.nd,
    divinityId: divinityId.present ? divinityId.value : this.divinityId,
    initiative: initiative ?? this.initiative,
    perception: perception ?? this.perception,
    defense: defense ?? this.defense,
    life: life ?? this.life,
    mana: mana ?? this.mana,
    fortResistence: fortResistence ?? this.fortResistence,
    refResistence: refResistence ?? this.refResistence,
    vonResistence: vonResistence ?? this.vonResistence,
    strength: strength ?? this.strength,
    dexterity: dexterity ?? this.dexterity,
    constitution: constitution ?? this.constitution,
    intelligence: intelligence ?? this.intelligence,
    wisdom: wisdom ?? this.wisdom,
    charisma: charisma ?? this.charisma,
    typeIndex: typeIndex ?? this.typeIndex,
    creatureSizeIndex: creatureSizeIndex ?? this.creatureSizeIndex,
    combateRoleIndex: combateRoleIndex ?? this.combateRoleIndex,
    treasureTypeIndex: treasureTypeIndex.present
        ? treasureTypeIndex.value
        : this.treasureTypeIndex,
    createdAt: createdAt ?? this.createdAt,
    updatedAt: updatedAt ?? this.updatedAt,
  );
  MenaceTableData copyWithCompanion(MenaceTableCompanion data) {
    return MenaceTableData(
      uuid: data.uuid.present ? data.uuid.value : this.uuid,
      name: data.name.present ? data.name.value : this.name,
      imagePath: data.imagePath.present ? data.imagePath.value : this.imagePath,
      imageAsset: data.imageAsset.present
          ? data.imageAsset.value
          : this.imageAsset,
      displacement: data.displacement.present
          ? data.displacement.value
          : this.displacement,
      casterInfos: data.casterInfos.present
          ? data.casterInfos.value
          : this.casterInfos,
      desc: data.desc.present ? data.desc.value : this.desc,
      extraInfos: data.extraInfos.present
          ? data.extraInfos.value
          : this.extraInfos,
      senses: data.senses.present ? data.senses.value : this.senses,
      nd: data.nd.present ? data.nd.value : this.nd,
      divinityId: data.divinityId.present
          ? data.divinityId.value
          : this.divinityId,
      initiative: data.initiative.present
          ? data.initiative.value
          : this.initiative,
      perception: data.perception.present
          ? data.perception.value
          : this.perception,
      defense: data.defense.present ? data.defense.value : this.defense,
      life: data.life.present ? data.life.value : this.life,
      mana: data.mana.present ? data.mana.value : this.mana,
      fortResistence: data.fortResistence.present
          ? data.fortResistence.value
          : this.fortResistence,
      refResistence: data.refResistence.present
          ? data.refResistence.value
          : this.refResistence,
      vonResistence: data.vonResistence.present
          ? data.vonResistence.value
          : this.vonResistence,
      strength: data.strength.present ? data.strength.value : this.strength,
      dexterity: data.dexterity.present ? data.dexterity.value : this.dexterity,
      constitution: data.constitution.present
          ? data.constitution.value
          : this.constitution,
      intelligence: data.intelligence.present
          ? data.intelligence.value
          : this.intelligence,
      wisdom: data.wisdom.present ? data.wisdom.value : this.wisdom,
      charisma: data.charisma.present ? data.charisma.value : this.charisma,
      typeIndex: data.typeIndex.present ? data.typeIndex.value : this.typeIndex,
      creatureSizeIndex: data.creatureSizeIndex.present
          ? data.creatureSizeIndex.value
          : this.creatureSizeIndex,
      combateRoleIndex: data.combateRoleIndex.present
          ? data.combateRoleIndex.value
          : this.combateRoleIndex,
      treasureTypeIndex: data.treasureTypeIndex.present
          ? data.treasureTypeIndex.value
          : this.treasureTypeIndex,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('MenaceTableData(')
          ..write('uuid: $uuid, ')
          ..write('name: $name, ')
          ..write('imagePath: $imagePath, ')
          ..write('imageAsset: $imageAsset, ')
          ..write('displacement: $displacement, ')
          ..write('casterInfos: $casterInfos, ')
          ..write('desc: $desc, ')
          ..write('extraInfos: $extraInfos, ')
          ..write('senses: $senses, ')
          ..write('nd: $nd, ')
          ..write('divinityId: $divinityId, ')
          ..write('initiative: $initiative, ')
          ..write('perception: $perception, ')
          ..write('defense: $defense, ')
          ..write('life: $life, ')
          ..write('mana: $mana, ')
          ..write('fortResistence: $fortResistence, ')
          ..write('refResistence: $refResistence, ')
          ..write('vonResistence: $vonResistence, ')
          ..write('strength: $strength, ')
          ..write('dexterity: $dexterity, ')
          ..write('constitution: $constitution, ')
          ..write('intelligence: $intelligence, ')
          ..write('wisdom: $wisdom, ')
          ..write('charisma: $charisma, ')
          ..write('typeIndex: $typeIndex, ')
          ..write('creatureSizeIndex: $creatureSizeIndex, ')
          ..write('combateRoleIndex: $combateRoleIndex, ')
          ..write('treasureTypeIndex: $treasureTypeIndex, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hashAll([
    uuid,
    name,
    imagePath,
    imageAsset,
    displacement,
    casterInfos,
    desc,
    extraInfos,
    senses,
    nd,
    divinityId,
    initiative,
    perception,
    defense,
    life,
    mana,
    fortResistence,
    refResistence,
    vonResistence,
    strength,
    dexterity,
    constitution,
    intelligence,
    wisdom,
    charisma,
    typeIndex,
    creatureSizeIndex,
    combateRoleIndex,
    treasureTypeIndex,
    createdAt,
    updatedAt,
  ]);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is MenaceTableData &&
          other.uuid == this.uuid &&
          other.name == this.name &&
          other.imagePath == this.imagePath &&
          other.imageAsset == this.imageAsset &&
          other.displacement == this.displacement &&
          other.casterInfos == this.casterInfos &&
          other.desc == this.desc &&
          other.extraInfos == this.extraInfos &&
          other.senses == this.senses &&
          other.nd == this.nd &&
          other.divinityId == this.divinityId &&
          other.initiative == this.initiative &&
          other.perception == this.perception &&
          other.defense == this.defense &&
          other.life == this.life &&
          other.mana == this.mana &&
          other.fortResistence == this.fortResistence &&
          other.refResistence == this.refResistence &&
          other.vonResistence == this.vonResistence &&
          other.strength == this.strength &&
          other.dexterity == this.dexterity &&
          other.constitution == this.constitution &&
          other.intelligence == this.intelligence &&
          other.wisdom == this.wisdom &&
          other.charisma == this.charisma &&
          other.typeIndex == this.typeIndex &&
          other.creatureSizeIndex == this.creatureSizeIndex &&
          other.combateRoleIndex == this.combateRoleIndex &&
          other.treasureTypeIndex == this.treasureTypeIndex &&
          other.createdAt == this.createdAt &&
          other.updatedAt == this.updatedAt);
}

class MenaceTableCompanion extends UpdateCompanion<MenaceTableData> {
  final Value<String> uuid;
  final Value<String> name;
  final Value<String?> imagePath;
  final Value<String?> imageAsset;
  final Value<String?> displacement;
  final Value<String?> casterInfos;
  final Value<String?> desc;
  final Value<String?> extraInfos;
  final Value<String?> senses;
  final Value<String> nd;
  final Value<int?> divinityId;
  final Value<int> initiative;
  final Value<int> perception;
  final Value<int> defense;
  final Value<int> life;
  final Value<int> mana;
  final Value<int> fortResistence;
  final Value<int> refResistence;
  final Value<int> vonResistence;
  final Value<int> strength;
  final Value<int> dexterity;
  final Value<int> constitution;
  final Value<int> intelligence;
  final Value<int> wisdom;
  final Value<int> charisma;
  final Value<int> typeIndex;
  final Value<int> creatureSizeIndex;
  final Value<int> combateRoleIndex;
  final Value<int?> treasureTypeIndex;
  final Value<int> createdAt;
  final Value<int> updatedAt;
  final Value<int> rowid;
  const MenaceTableCompanion({
    this.uuid = const Value.absent(),
    this.name = const Value.absent(),
    this.imagePath = const Value.absent(),
    this.imageAsset = const Value.absent(),
    this.displacement = const Value.absent(),
    this.casterInfos = const Value.absent(),
    this.desc = const Value.absent(),
    this.extraInfos = const Value.absent(),
    this.senses = const Value.absent(),
    this.nd = const Value.absent(),
    this.divinityId = const Value.absent(),
    this.initiative = const Value.absent(),
    this.perception = const Value.absent(),
    this.defense = const Value.absent(),
    this.life = const Value.absent(),
    this.mana = const Value.absent(),
    this.fortResistence = const Value.absent(),
    this.refResistence = const Value.absent(),
    this.vonResistence = const Value.absent(),
    this.strength = const Value.absent(),
    this.dexterity = const Value.absent(),
    this.constitution = const Value.absent(),
    this.intelligence = const Value.absent(),
    this.wisdom = const Value.absent(),
    this.charisma = const Value.absent(),
    this.typeIndex = const Value.absent(),
    this.creatureSizeIndex = const Value.absent(),
    this.combateRoleIndex = const Value.absent(),
    this.treasureTypeIndex = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  MenaceTableCompanion.insert({
    required String uuid,
    required String name,
    this.imagePath = const Value.absent(),
    this.imageAsset = const Value.absent(),
    this.displacement = const Value.absent(),
    this.casterInfos = const Value.absent(),
    this.desc = const Value.absent(),
    this.extraInfos = const Value.absent(),
    this.senses = const Value.absent(),
    required String nd,
    this.divinityId = const Value.absent(),
    required int initiative,
    required int perception,
    required int defense,
    required int life,
    required int mana,
    required int fortResistence,
    required int refResistence,
    required int vonResistence,
    required int strength,
    required int dexterity,
    required int constitution,
    required int intelligence,
    required int wisdom,
    required int charisma,
    required int typeIndex,
    required int creatureSizeIndex,
    required int combateRoleIndex,
    this.treasureTypeIndex = const Value.absent(),
    required int createdAt,
    required int updatedAt,
    this.rowid = const Value.absent(),
  }) : uuid = Value(uuid),
       name = Value(name),
       nd = Value(nd),
       initiative = Value(initiative),
       perception = Value(perception),
       defense = Value(defense),
       life = Value(life),
       mana = Value(mana),
       fortResistence = Value(fortResistence),
       refResistence = Value(refResistence),
       vonResistence = Value(vonResistence),
       strength = Value(strength),
       dexterity = Value(dexterity),
       constitution = Value(constitution),
       intelligence = Value(intelligence),
       wisdom = Value(wisdom),
       charisma = Value(charisma),
       typeIndex = Value(typeIndex),
       creatureSizeIndex = Value(creatureSizeIndex),
       combateRoleIndex = Value(combateRoleIndex),
       createdAt = Value(createdAt),
       updatedAt = Value(updatedAt);
  static Insertable<MenaceTableData> custom({
    Expression<String>? uuid,
    Expression<String>? name,
    Expression<String>? imagePath,
    Expression<String>? imageAsset,
    Expression<String>? displacement,
    Expression<String>? casterInfos,
    Expression<String>? desc,
    Expression<String>? extraInfos,
    Expression<String>? senses,
    Expression<String>? nd,
    Expression<int>? divinityId,
    Expression<int>? initiative,
    Expression<int>? perception,
    Expression<int>? defense,
    Expression<int>? life,
    Expression<int>? mana,
    Expression<int>? fortResistence,
    Expression<int>? refResistence,
    Expression<int>? vonResistence,
    Expression<int>? strength,
    Expression<int>? dexterity,
    Expression<int>? constitution,
    Expression<int>? intelligence,
    Expression<int>? wisdom,
    Expression<int>? charisma,
    Expression<int>? typeIndex,
    Expression<int>? creatureSizeIndex,
    Expression<int>? combateRoleIndex,
    Expression<int>? treasureTypeIndex,
    Expression<int>? createdAt,
    Expression<int>? updatedAt,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (uuid != null) 'uuid': uuid,
      if (name != null) 'name': name,
      if (imagePath != null) 'image_path': imagePath,
      if (imageAsset != null) 'image_asset': imageAsset,
      if (displacement != null) 'displacement': displacement,
      if (casterInfos != null) 'caster_infos': casterInfos,
      if (desc != null) 'desc': desc,
      if (extraInfos != null) 'extra_infos': extraInfos,
      if (senses != null) 'senses': senses,
      if (nd != null) 'nd': nd,
      if (divinityId != null) 'divinity_id': divinityId,
      if (initiative != null) 'initiative': initiative,
      if (perception != null) 'perception': perception,
      if (defense != null) 'defense': defense,
      if (life != null) 'life': life,
      if (mana != null) 'mana': mana,
      if (fortResistence != null) 'fort_resistence': fortResistence,
      if (refResistence != null) 'ref_resistence': refResistence,
      if (vonResistence != null) 'von_resistence': vonResistence,
      if (strength != null) 'strength': strength,
      if (dexterity != null) 'dexterity': dexterity,
      if (constitution != null) 'constitution': constitution,
      if (intelligence != null) 'intelligence': intelligence,
      if (wisdom != null) 'wisdom': wisdom,
      if (charisma != null) 'charisma': charisma,
      if (typeIndex != null) 'type_index': typeIndex,
      if (creatureSizeIndex != null) 'creature_size_index': creatureSizeIndex,
      if (combateRoleIndex != null) 'combate_role_index': combateRoleIndex,
      if (treasureTypeIndex != null) 'treasure_type_index': treasureTypeIndex,
      if (createdAt != null) 'created_at': createdAt,
      if (updatedAt != null) 'updated_at': updatedAt,
      if (rowid != null) 'rowid': rowid,
    });
  }

  MenaceTableCompanion copyWith({
    Value<String>? uuid,
    Value<String>? name,
    Value<String?>? imagePath,
    Value<String?>? imageAsset,
    Value<String?>? displacement,
    Value<String?>? casterInfos,
    Value<String?>? desc,
    Value<String?>? extraInfos,
    Value<String?>? senses,
    Value<String>? nd,
    Value<int?>? divinityId,
    Value<int>? initiative,
    Value<int>? perception,
    Value<int>? defense,
    Value<int>? life,
    Value<int>? mana,
    Value<int>? fortResistence,
    Value<int>? refResistence,
    Value<int>? vonResistence,
    Value<int>? strength,
    Value<int>? dexterity,
    Value<int>? constitution,
    Value<int>? intelligence,
    Value<int>? wisdom,
    Value<int>? charisma,
    Value<int>? typeIndex,
    Value<int>? creatureSizeIndex,
    Value<int>? combateRoleIndex,
    Value<int?>? treasureTypeIndex,
    Value<int>? createdAt,
    Value<int>? updatedAt,
    Value<int>? rowid,
  }) {
    return MenaceTableCompanion(
      uuid: uuid ?? this.uuid,
      name: name ?? this.name,
      imagePath: imagePath ?? this.imagePath,
      imageAsset: imageAsset ?? this.imageAsset,
      displacement: displacement ?? this.displacement,
      casterInfos: casterInfos ?? this.casterInfos,
      desc: desc ?? this.desc,
      extraInfos: extraInfos ?? this.extraInfos,
      senses: senses ?? this.senses,
      nd: nd ?? this.nd,
      divinityId: divinityId ?? this.divinityId,
      initiative: initiative ?? this.initiative,
      perception: perception ?? this.perception,
      defense: defense ?? this.defense,
      life: life ?? this.life,
      mana: mana ?? this.mana,
      fortResistence: fortResistence ?? this.fortResistence,
      refResistence: refResistence ?? this.refResistence,
      vonResistence: vonResistence ?? this.vonResistence,
      strength: strength ?? this.strength,
      dexterity: dexterity ?? this.dexterity,
      constitution: constitution ?? this.constitution,
      intelligence: intelligence ?? this.intelligence,
      wisdom: wisdom ?? this.wisdom,
      charisma: charisma ?? this.charisma,
      typeIndex: typeIndex ?? this.typeIndex,
      creatureSizeIndex: creatureSizeIndex ?? this.creatureSizeIndex,
      combateRoleIndex: combateRoleIndex ?? this.combateRoleIndex,
      treasureTypeIndex: treasureTypeIndex ?? this.treasureTypeIndex,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (uuid.present) {
      map['uuid'] = Variable<String>(uuid.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    if (imagePath.present) {
      map['image_path'] = Variable<String>(imagePath.value);
    }
    if (imageAsset.present) {
      map['image_asset'] = Variable<String>(imageAsset.value);
    }
    if (displacement.present) {
      map['displacement'] = Variable<String>(displacement.value);
    }
    if (casterInfos.present) {
      map['caster_infos'] = Variable<String>(casterInfos.value);
    }
    if (desc.present) {
      map['desc'] = Variable<String>(desc.value);
    }
    if (extraInfos.present) {
      map['extra_infos'] = Variable<String>(extraInfos.value);
    }
    if (senses.present) {
      map['senses'] = Variable<String>(senses.value);
    }
    if (nd.present) {
      map['nd'] = Variable<String>(nd.value);
    }
    if (divinityId.present) {
      map['divinity_id'] = Variable<int>(divinityId.value);
    }
    if (initiative.present) {
      map['initiative'] = Variable<int>(initiative.value);
    }
    if (perception.present) {
      map['perception'] = Variable<int>(perception.value);
    }
    if (defense.present) {
      map['defense'] = Variable<int>(defense.value);
    }
    if (life.present) {
      map['life'] = Variable<int>(life.value);
    }
    if (mana.present) {
      map['mana'] = Variable<int>(mana.value);
    }
    if (fortResistence.present) {
      map['fort_resistence'] = Variable<int>(fortResistence.value);
    }
    if (refResistence.present) {
      map['ref_resistence'] = Variable<int>(refResistence.value);
    }
    if (vonResistence.present) {
      map['von_resistence'] = Variable<int>(vonResistence.value);
    }
    if (strength.present) {
      map['strength'] = Variable<int>(strength.value);
    }
    if (dexterity.present) {
      map['dexterity'] = Variable<int>(dexterity.value);
    }
    if (constitution.present) {
      map['constitution'] = Variable<int>(constitution.value);
    }
    if (intelligence.present) {
      map['intelligence'] = Variable<int>(intelligence.value);
    }
    if (wisdom.present) {
      map['wisdom'] = Variable<int>(wisdom.value);
    }
    if (charisma.present) {
      map['charisma'] = Variable<int>(charisma.value);
    }
    if (typeIndex.present) {
      map['type_index'] = Variable<int>(typeIndex.value);
    }
    if (creatureSizeIndex.present) {
      map['creature_size_index'] = Variable<int>(creatureSizeIndex.value);
    }
    if (combateRoleIndex.present) {
      map['combate_role_index'] = Variable<int>(combateRoleIndex.value);
    }
    if (treasureTypeIndex.present) {
      map['treasure_type_index'] = Variable<int>(treasureTypeIndex.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<int>(createdAt.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<int>(updatedAt.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('MenaceTableCompanion(')
          ..write('uuid: $uuid, ')
          ..write('name: $name, ')
          ..write('imagePath: $imagePath, ')
          ..write('imageAsset: $imageAsset, ')
          ..write('displacement: $displacement, ')
          ..write('casterInfos: $casterInfos, ')
          ..write('desc: $desc, ')
          ..write('extraInfos: $extraInfos, ')
          ..write('senses: $senses, ')
          ..write('nd: $nd, ')
          ..write('divinityId: $divinityId, ')
          ..write('initiative: $initiative, ')
          ..write('perception: $perception, ')
          ..write('defense: $defense, ')
          ..write('life: $life, ')
          ..write('mana: $mana, ')
          ..write('fortResistence: $fortResistence, ')
          ..write('refResistence: $refResistence, ')
          ..write('vonResistence: $vonResistence, ')
          ..write('strength: $strength, ')
          ..write('dexterity: $dexterity, ')
          ..write('constitution: $constitution, ')
          ..write('intelligence: $intelligence, ')
          ..write('wisdom: $wisdom, ')
          ..write('charisma: $charisma, ')
          ..write('typeIndex: $typeIndex, ')
          ..write('creatureSizeIndex: $creatureSizeIndex, ')
          ..write('combateRoleIndex: $combateRoleIndex, ')
          ..write('treasureTypeIndex: $treasureTypeIndex, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $AdventureBackpackTableTable extends AdventureBackpackTable
    with TableInfo<$AdventureBackpackTableTable, AdventureBackpackTableData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $AdventureBackpackTableTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _uuidMeta = const VerificationMeta('uuid');
  @override
  late final GeneratedColumn<String> uuid = GeneratedColumn<String>(
    'uuid',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
    'name',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _parentUuidMeta = const VerificationMeta(
    'parentUuid',
  );
  @override
  late final GeneratedColumn<String> parentUuid = GeneratedColumn<String>(
    'parent_uuid',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _suffixMeta = const VerificationMeta('suffix');
  @override
  late final GeneratedColumn<String> suffix = GeneratedColumn<String>(
    'suffix',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _priceMeta = const VerificationMeta('price');
  @override
  late final GeneratedColumn<double> price = GeneratedColumn<double>(
    'price',
    aliasedName,
    true,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<int> createdAt = GeneratedColumn<int>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _updatedAtMeta = const VerificationMeta(
    'updatedAt',
  );
  @override
  late final GeneratedColumn<int> updatedAt = GeneratedColumn<int>(
    'updated_at',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  @override
  List<GeneratedColumn> get $columns => [
    uuid,
    name,
    parentUuid,
    suffix,
    price,
    createdAt,
    updatedAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'adventure_backpack_table';
  @override
  VerificationContext validateIntegrity(
    Insertable<AdventureBackpackTableData> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('uuid')) {
      context.handle(
        _uuidMeta,
        uuid.isAcceptableOrUnknown(data['uuid']!, _uuidMeta),
      );
    } else if (isInserting) {
      context.missing(_uuidMeta);
    }
    if (data.containsKey('name')) {
      context.handle(
        _nameMeta,
        name.isAcceptableOrUnknown(data['name']!, _nameMeta),
      );
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    if (data.containsKey('parent_uuid')) {
      context.handle(
        _parentUuidMeta,
        parentUuid.isAcceptableOrUnknown(data['parent_uuid']!, _parentUuidMeta),
      );
    } else if (isInserting) {
      context.missing(_parentUuidMeta);
    }
    if (data.containsKey('suffix')) {
      context.handle(
        _suffixMeta,
        suffix.isAcceptableOrUnknown(data['suffix']!, _suffixMeta),
      );
    }
    if (data.containsKey('price')) {
      context.handle(
        _priceMeta,
        price.isAcceptableOrUnknown(data['price']!, _priceMeta),
      );
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    } else if (isInserting) {
      context.missing(_createdAtMeta);
    }
    if (data.containsKey('updated_at')) {
      context.handle(
        _updatedAtMeta,
        updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta),
      );
    } else if (isInserting) {
      context.missing(_updatedAtMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {uuid};
  @override
  AdventureBackpackTableData map(
    Map<String, dynamic> data, {
    String? tablePrefix,
  }) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return AdventureBackpackTableData(
      uuid: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}uuid'],
      )!,
      name: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}name'],
      )!,
      parentUuid: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}parent_uuid'],
      )!,
      suffix: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}suffix'],
      ),
      price: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}price'],
      ),
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}created_at'],
      )!,
      updatedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}updated_at'],
      )!,
    );
  }

  @override
  $AdventureBackpackTableTable createAlias(String alias) {
    return $AdventureBackpackTableTable(attachedDatabase, alias);
  }
}

class AdventureBackpackTableData extends DataClass
    implements Insertable<AdventureBackpackTableData> {
  final String uuid;
  final String name;
  final String parentUuid;
  final String? suffix;
  final double? price;
  final int createdAt;
  final int updatedAt;
  const AdventureBackpackTableData({
    required this.uuid,
    required this.name,
    required this.parentUuid,
    this.suffix,
    this.price,
    required this.createdAt,
    required this.updatedAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['uuid'] = Variable<String>(uuid);
    map['name'] = Variable<String>(name);
    map['parent_uuid'] = Variable<String>(parentUuid);
    if (!nullToAbsent || suffix != null) {
      map['suffix'] = Variable<String>(suffix);
    }
    if (!nullToAbsent || price != null) {
      map['price'] = Variable<double>(price);
    }
    map['created_at'] = Variable<int>(createdAt);
    map['updated_at'] = Variable<int>(updatedAt);
    return map;
  }

  AdventureBackpackTableCompanion toCompanion(bool nullToAbsent) {
    return AdventureBackpackTableCompanion(
      uuid: Value(uuid),
      name: Value(name),
      parentUuid: Value(parentUuid),
      suffix: suffix == null && nullToAbsent
          ? const Value.absent()
          : Value(suffix),
      price: price == null && nullToAbsent
          ? const Value.absent()
          : Value(price),
      createdAt: Value(createdAt),
      updatedAt: Value(updatedAt),
    );
  }

  factory AdventureBackpackTableData.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AdventureBackpackTableData(
      uuid: serializer.fromJson<String>(json['uuid']),
      name: serializer.fromJson<String>(json['name']),
      parentUuid: serializer.fromJson<String>(json['parentUuid']),
      suffix: serializer.fromJson<String?>(json['suffix']),
      price: serializer.fromJson<double?>(json['price']),
      createdAt: serializer.fromJson<int>(json['createdAt']),
      updatedAt: serializer.fromJson<int>(json['updatedAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'uuid': serializer.toJson<String>(uuid),
      'name': serializer.toJson<String>(name),
      'parentUuid': serializer.toJson<String>(parentUuid),
      'suffix': serializer.toJson<String?>(suffix),
      'price': serializer.toJson<double?>(price),
      'createdAt': serializer.toJson<int>(createdAt),
      'updatedAt': serializer.toJson<int>(updatedAt),
    };
  }

  AdventureBackpackTableData copyWith({
    String? uuid,
    String? name,
    String? parentUuid,
    Value<String?> suffix = const Value.absent(),
    Value<double?> price = const Value.absent(),
    int? createdAt,
    int? updatedAt,
  }) => AdventureBackpackTableData(
    uuid: uuid ?? this.uuid,
    name: name ?? this.name,
    parentUuid: parentUuid ?? this.parentUuid,
    suffix: suffix.present ? suffix.value : this.suffix,
    price: price.present ? price.value : this.price,
    createdAt: createdAt ?? this.createdAt,
    updatedAt: updatedAt ?? this.updatedAt,
  );
  AdventureBackpackTableData copyWithCompanion(
    AdventureBackpackTableCompanion data,
  ) {
    return AdventureBackpackTableData(
      uuid: data.uuid.present ? data.uuid.value : this.uuid,
      name: data.name.present ? data.name.value : this.name,
      parentUuid: data.parentUuid.present
          ? data.parentUuid.value
          : this.parentUuid,
      suffix: data.suffix.present ? data.suffix.value : this.suffix,
      price: data.price.present ? data.price.value : this.price,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('AdventureBackpackTableData(')
          ..write('uuid: $uuid, ')
          ..write('name: $name, ')
          ..write('parentUuid: $parentUuid, ')
          ..write('suffix: $suffix, ')
          ..write('price: $price, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode =>
      Object.hash(uuid, name, parentUuid, suffix, price, createdAt, updatedAt);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AdventureBackpackTableData &&
          other.uuid == this.uuid &&
          other.name == this.name &&
          other.parentUuid == this.parentUuid &&
          other.suffix == this.suffix &&
          other.price == this.price &&
          other.createdAt == this.createdAt &&
          other.updatedAt == this.updatedAt);
}

class AdventureBackpackTableCompanion
    extends UpdateCompanion<AdventureBackpackTableData> {
  final Value<String> uuid;
  final Value<String> name;
  final Value<String> parentUuid;
  final Value<String?> suffix;
  final Value<double?> price;
  final Value<int> createdAt;
  final Value<int> updatedAt;
  final Value<int> rowid;
  const AdventureBackpackTableCompanion({
    this.uuid = const Value.absent(),
    this.name = const Value.absent(),
    this.parentUuid = const Value.absent(),
    this.suffix = const Value.absent(),
    this.price = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  AdventureBackpackTableCompanion.insert({
    required String uuid,
    required String name,
    required String parentUuid,
    this.suffix = const Value.absent(),
    this.price = const Value.absent(),
    required int createdAt,
    required int updatedAt,
    this.rowid = const Value.absent(),
  }) : uuid = Value(uuid),
       name = Value(name),
       parentUuid = Value(parentUuid),
       createdAt = Value(createdAt),
       updatedAt = Value(updatedAt);
  static Insertable<AdventureBackpackTableData> custom({
    Expression<String>? uuid,
    Expression<String>? name,
    Expression<String>? parentUuid,
    Expression<String>? suffix,
    Expression<double>? price,
    Expression<int>? createdAt,
    Expression<int>? updatedAt,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (uuid != null) 'uuid': uuid,
      if (name != null) 'name': name,
      if (parentUuid != null) 'parent_uuid': parentUuid,
      if (suffix != null) 'suffix': suffix,
      if (price != null) 'price': price,
      if (createdAt != null) 'created_at': createdAt,
      if (updatedAt != null) 'updated_at': updatedAt,
      if (rowid != null) 'rowid': rowid,
    });
  }

  AdventureBackpackTableCompanion copyWith({
    Value<String>? uuid,
    Value<String>? name,
    Value<String>? parentUuid,
    Value<String?>? suffix,
    Value<double?>? price,
    Value<int>? createdAt,
    Value<int>? updatedAt,
    Value<int>? rowid,
  }) {
    return AdventureBackpackTableCompanion(
      uuid: uuid ?? this.uuid,
      name: name ?? this.name,
      parentUuid: parentUuid ?? this.parentUuid,
      suffix: suffix ?? this.suffix,
      price: price ?? this.price,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (uuid.present) {
      map['uuid'] = Variable<String>(uuid.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    if (parentUuid.present) {
      map['parent_uuid'] = Variable<String>(parentUuid.value);
    }
    if (suffix.present) {
      map['suffix'] = Variable<String>(suffix.value);
    }
    if (price.present) {
      map['price'] = Variable<double>(price.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<int>(createdAt.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<int>(updatedAt.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AdventureBackpackTableCompanion(')
          ..write('uuid: $uuid, ')
          ..write('name: $name, ')
          ..write('parentUuid: $parentUuid, ')
          ..write('suffix: $suffix, ')
          ..write('price: $price, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $EquipmentTableTable extends EquipmentTable
    with TableInfo<$EquipmentTableTable, EquipmentTableData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $EquipmentTableTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _uuidMeta = const VerificationMeta('uuid');
  @override
  late final GeneratedColumn<String> uuid = GeneratedColumn<String>(
    'uuid',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
    'name',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _parentUuidMeta = const VerificationMeta(
    'parentUuid',
  );
  @override
  late final GeneratedColumn<String> parentUuid = GeneratedColumn<String>(
    'parent_uuid',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _storedInMeta = const VerificationMeta(
    'storedIn',
  );
  @override
  late final GeneratedColumn<String> storedIn = GeneratedColumn<String>(
    'stored_in',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _improvementsMeta = const VerificationMeta(
    'improvements',
  );
  @override
  late final GeneratedColumn<String> improvements = GeneratedColumn<String>(
    'improvements',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _specialMaterialIndexMeta =
      const VerificationMeta('specialMaterialIndex');
  @override
  late final GeneratedColumn<int> specialMaterialIndex = GeneratedColumn<int>(
    'special_material_index',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<int> createdAt = GeneratedColumn<int>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _updatedAtMeta = const VerificationMeta(
    'updatedAt',
  );
  @override
  late final GeneratedColumn<int> updatedAt = GeneratedColumn<int>(
    'updated_at',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  @override
  List<GeneratedColumn> get $columns => [
    uuid,
    name,
    parentUuid,
    storedIn,
    improvements,
    specialMaterialIndex,
    createdAt,
    updatedAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'equipment_table';
  @override
  VerificationContext validateIntegrity(
    Insertable<EquipmentTableData> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('uuid')) {
      context.handle(
        _uuidMeta,
        uuid.isAcceptableOrUnknown(data['uuid']!, _uuidMeta),
      );
    } else if (isInserting) {
      context.missing(_uuidMeta);
    }
    if (data.containsKey('name')) {
      context.handle(
        _nameMeta,
        name.isAcceptableOrUnknown(data['name']!, _nameMeta),
      );
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    if (data.containsKey('parent_uuid')) {
      context.handle(
        _parentUuidMeta,
        parentUuid.isAcceptableOrUnknown(data['parent_uuid']!, _parentUuidMeta),
      );
    } else if (isInserting) {
      context.missing(_parentUuidMeta);
    }
    if (data.containsKey('stored_in')) {
      context.handle(
        _storedInMeta,
        storedIn.isAcceptableOrUnknown(data['stored_in']!, _storedInMeta),
      );
    }
    if (data.containsKey('improvements')) {
      context.handle(
        _improvementsMeta,
        improvements.isAcceptableOrUnknown(
          data['improvements']!,
          _improvementsMeta,
        ),
      );
    }
    if (data.containsKey('special_material_index')) {
      context.handle(
        _specialMaterialIndexMeta,
        specialMaterialIndex.isAcceptableOrUnknown(
          data['special_material_index']!,
          _specialMaterialIndexMeta,
        ),
      );
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    } else if (isInserting) {
      context.missing(_createdAtMeta);
    }
    if (data.containsKey('updated_at')) {
      context.handle(
        _updatedAtMeta,
        updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta),
      );
    } else if (isInserting) {
      context.missing(_updatedAtMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {uuid};
  @override
  EquipmentTableData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return EquipmentTableData(
      uuid: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}uuid'],
      )!,
      name: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}name'],
      )!,
      parentUuid: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}parent_uuid'],
      )!,
      storedIn: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}stored_in'],
      ),
      improvements: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}improvements'],
      ),
      specialMaterialIndex: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}special_material_index'],
      ),
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}created_at'],
      )!,
      updatedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}updated_at'],
      )!,
    );
  }

  @override
  $EquipmentTableTable createAlias(String alias) {
    return $EquipmentTableTable(attachedDatabase, alias);
  }
}

class EquipmentTableData extends DataClass
    implements Insertable<EquipmentTableData> {
  final String uuid;
  final String name;
  final String parentUuid;
  final String? storedIn;
  final String? improvements;
  final int? specialMaterialIndex;
  final int createdAt;
  final int updatedAt;
  const EquipmentTableData({
    required this.uuid,
    required this.name,
    required this.parentUuid,
    this.storedIn,
    this.improvements,
    this.specialMaterialIndex,
    required this.createdAt,
    required this.updatedAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['uuid'] = Variable<String>(uuid);
    map['name'] = Variable<String>(name);
    map['parent_uuid'] = Variable<String>(parentUuid);
    if (!nullToAbsent || storedIn != null) {
      map['stored_in'] = Variable<String>(storedIn);
    }
    if (!nullToAbsent || improvements != null) {
      map['improvements'] = Variable<String>(improvements);
    }
    if (!nullToAbsent || specialMaterialIndex != null) {
      map['special_material_index'] = Variable<int>(specialMaterialIndex);
    }
    map['created_at'] = Variable<int>(createdAt);
    map['updated_at'] = Variable<int>(updatedAt);
    return map;
  }

  EquipmentTableCompanion toCompanion(bool nullToAbsent) {
    return EquipmentTableCompanion(
      uuid: Value(uuid),
      name: Value(name),
      parentUuid: Value(parentUuid),
      storedIn: storedIn == null && nullToAbsent
          ? const Value.absent()
          : Value(storedIn),
      improvements: improvements == null && nullToAbsent
          ? const Value.absent()
          : Value(improvements),
      specialMaterialIndex: specialMaterialIndex == null && nullToAbsent
          ? const Value.absent()
          : Value(specialMaterialIndex),
      createdAt: Value(createdAt),
      updatedAt: Value(updatedAt),
    );
  }

  factory EquipmentTableData.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return EquipmentTableData(
      uuid: serializer.fromJson<String>(json['uuid']),
      name: serializer.fromJson<String>(json['name']),
      parentUuid: serializer.fromJson<String>(json['parentUuid']),
      storedIn: serializer.fromJson<String?>(json['storedIn']),
      improvements: serializer.fromJson<String?>(json['improvements']),
      specialMaterialIndex: serializer.fromJson<int?>(
        json['specialMaterialIndex'],
      ),
      createdAt: serializer.fromJson<int>(json['createdAt']),
      updatedAt: serializer.fromJson<int>(json['updatedAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'uuid': serializer.toJson<String>(uuid),
      'name': serializer.toJson<String>(name),
      'parentUuid': serializer.toJson<String>(parentUuid),
      'storedIn': serializer.toJson<String?>(storedIn),
      'improvements': serializer.toJson<String?>(improvements),
      'specialMaterialIndex': serializer.toJson<int?>(specialMaterialIndex),
      'createdAt': serializer.toJson<int>(createdAt),
      'updatedAt': serializer.toJson<int>(updatedAt),
    };
  }

  EquipmentTableData copyWith({
    String? uuid,
    String? name,
    String? parentUuid,
    Value<String?> storedIn = const Value.absent(),
    Value<String?> improvements = const Value.absent(),
    Value<int?> specialMaterialIndex = const Value.absent(),
    int? createdAt,
    int? updatedAt,
  }) => EquipmentTableData(
    uuid: uuid ?? this.uuid,
    name: name ?? this.name,
    parentUuid: parentUuid ?? this.parentUuid,
    storedIn: storedIn.present ? storedIn.value : this.storedIn,
    improvements: improvements.present ? improvements.value : this.improvements,
    specialMaterialIndex: specialMaterialIndex.present
        ? specialMaterialIndex.value
        : this.specialMaterialIndex,
    createdAt: createdAt ?? this.createdAt,
    updatedAt: updatedAt ?? this.updatedAt,
  );
  EquipmentTableData copyWithCompanion(EquipmentTableCompanion data) {
    return EquipmentTableData(
      uuid: data.uuid.present ? data.uuid.value : this.uuid,
      name: data.name.present ? data.name.value : this.name,
      parentUuid: data.parentUuid.present
          ? data.parentUuid.value
          : this.parentUuid,
      storedIn: data.storedIn.present ? data.storedIn.value : this.storedIn,
      improvements: data.improvements.present
          ? data.improvements.value
          : this.improvements,
      specialMaterialIndex: data.specialMaterialIndex.present
          ? data.specialMaterialIndex.value
          : this.specialMaterialIndex,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('EquipmentTableData(')
          ..write('uuid: $uuid, ')
          ..write('name: $name, ')
          ..write('parentUuid: $parentUuid, ')
          ..write('storedIn: $storedIn, ')
          ..write('improvements: $improvements, ')
          ..write('specialMaterialIndex: $specialMaterialIndex, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    uuid,
    name,
    parentUuid,
    storedIn,
    improvements,
    specialMaterialIndex,
    createdAt,
    updatedAt,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is EquipmentTableData &&
          other.uuid == this.uuid &&
          other.name == this.name &&
          other.parentUuid == this.parentUuid &&
          other.storedIn == this.storedIn &&
          other.improvements == this.improvements &&
          other.specialMaterialIndex == this.specialMaterialIndex &&
          other.createdAt == this.createdAt &&
          other.updatedAt == this.updatedAt);
}

class EquipmentTableCompanion extends UpdateCompanion<EquipmentTableData> {
  final Value<String> uuid;
  final Value<String> name;
  final Value<String> parentUuid;
  final Value<String?> storedIn;
  final Value<String?> improvements;
  final Value<int?> specialMaterialIndex;
  final Value<int> createdAt;
  final Value<int> updatedAt;
  final Value<int> rowid;
  const EquipmentTableCompanion({
    this.uuid = const Value.absent(),
    this.name = const Value.absent(),
    this.parentUuid = const Value.absent(),
    this.storedIn = const Value.absent(),
    this.improvements = const Value.absent(),
    this.specialMaterialIndex = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  EquipmentTableCompanion.insert({
    required String uuid,
    required String name,
    required String parentUuid,
    this.storedIn = const Value.absent(),
    this.improvements = const Value.absent(),
    this.specialMaterialIndex = const Value.absent(),
    required int createdAt,
    required int updatedAt,
    this.rowid = const Value.absent(),
  }) : uuid = Value(uuid),
       name = Value(name),
       parentUuid = Value(parentUuid),
       createdAt = Value(createdAt),
       updatedAt = Value(updatedAt);
  static Insertable<EquipmentTableData> custom({
    Expression<String>? uuid,
    Expression<String>? name,
    Expression<String>? parentUuid,
    Expression<String>? storedIn,
    Expression<String>? improvements,
    Expression<int>? specialMaterialIndex,
    Expression<int>? createdAt,
    Expression<int>? updatedAt,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (uuid != null) 'uuid': uuid,
      if (name != null) 'name': name,
      if (parentUuid != null) 'parent_uuid': parentUuid,
      if (storedIn != null) 'stored_in': storedIn,
      if (improvements != null) 'improvements': improvements,
      if (specialMaterialIndex != null)
        'special_material_index': specialMaterialIndex,
      if (createdAt != null) 'created_at': createdAt,
      if (updatedAt != null) 'updated_at': updatedAt,
      if (rowid != null) 'rowid': rowid,
    });
  }

  EquipmentTableCompanion copyWith({
    Value<String>? uuid,
    Value<String>? name,
    Value<String>? parentUuid,
    Value<String?>? storedIn,
    Value<String?>? improvements,
    Value<int?>? specialMaterialIndex,
    Value<int>? createdAt,
    Value<int>? updatedAt,
    Value<int>? rowid,
  }) {
    return EquipmentTableCompanion(
      uuid: uuid ?? this.uuid,
      name: name ?? this.name,
      parentUuid: parentUuid ?? this.parentUuid,
      storedIn: storedIn ?? this.storedIn,
      improvements: improvements ?? this.improvements,
      specialMaterialIndex: specialMaterialIndex ?? this.specialMaterialIndex,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (uuid.present) {
      map['uuid'] = Variable<String>(uuid.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    if (parentUuid.present) {
      map['parent_uuid'] = Variable<String>(parentUuid.value);
    }
    if (storedIn.present) {
      map['stored_in'] = Variable<String>(storedIn.value);
    }
    if (improvements.present) {
      map['improvements'] = Variable<String>(improvements.value);
    }
    if (specialMaterialIndex.present) {
      map['special_material_index'] = Variable<int>(specialMaterialIndex.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<int>(createdAt.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<int>(updatedAt.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('EquipmentTableCompanion(')
          ..write('uuid: $uuid, ')
          ..write('name: $name, ')
          ..write('parentUuid: $parentUuid, ')
          ..write('storedIn: $storedIn, ')
          ..write('improvements: $improvements, ')
          ..write('specialMaterialIndex: $specialMaterialIndex, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $AmmunitionTableTable extends AmmunitionTable
    with TableInfo<$AmmunitionTableTable, AmmunitionTableData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $AmmunitionTableTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _uuidMeta = const VerificationMeta('uuid');
  @override
  late final GeneratedColumn<String> uuid = GeneratedColumn<String>(
    'uuid',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
    'name',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _parentUuidMeta = const VerificationMeta(
    'parentUuid',
  );
  @override
  late final GeneratedColumn<String> parentUuid = GeneratedColumn<String>(
    'parent_uuid',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _quantityMeta = const VerificationMeta(
    'quantity',
  );
  @override
  late final GeneratedColumn<int> quantity = GeneratedColumn<int>(
    'quantity',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _storedInMeta = const VerificationMeta(
    'storedIn',
  );
  @override
  late final GeneratedColumn<String> storedIn = GeneratedColumn<String>(
    'stored_in',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _priceMeta = const VerificationMeta('price');
  @override
  late final GeneratedColumn<double> price = GeneratedColumn<double>(
    'price',
    aliasedName,
    true,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _descMeta = const VerificationMeta('desc');
  @override
  late final GeneratedColumn<String> desc = GeneratedColumn<String>(
    'desc',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _improvementsMeta = const VerificationMeta(
    'improvements',
  );
  @override
  late final GeneratedColumn<String> improvements = GeneratedColumn<String>(
    'improvements',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _specialMaterialIndexMeta =
      const VerificationMeta('specialMaterialIndex');
  @override
  late final GeneratedColumn<int> specialMaterialIndex = GeneratedColumn<int>(
    'special_material_index',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<int> createdAt = GeneratedColumn<int>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _updatedAtMeta = const VerificationMeta(
    'updatedAt',
  );
  @override
  late final GeneratedColumn<int> updatedAt = GeneratedColumn<int>(
    'updated_at',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  @override
  List<GeneratedColumn> get $columns => [
    uuid,
    name,
    parentUuid,
    quantity,
    storedIn,
    price,
    desc,
    improvements,
    specialMaterialIndex,
    createdAt,
    updatedAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'ammunition_table';
  @override
  VerificationContext validateIntegrity(
    Insertable<AmmunitionTableData> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('uuid')) {
      context.handle(
        _uuidMeta,
        uuid.isAcceptableOrUnknown(data['uuid']!, _uuidMeta),
      );
    } else if (isInserting) {
      context.missing(_uuidMeta);
    }
    if (data.containsKey('name')) {
      context.handle(
        _nameMeta,
        name.isAcceptableOrUnknown(data['name']!, _nameMeta),
      );
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    if (data.containsKey('parent_uuid')) {
      context.handle(
        _parentUuidMeta,
        parentUuid.isAcceptableOrUnknown(data['parent_uuid']!, _parentUuidMeta),
      );
    } else if (isInserting) {
      context.missing(_parentUuidMeta);
    }
    if (data.containsKey('quantity')) {
      context.handle(
        _quantityMeta,
        quantity.isAcceptableOrUnknown(data['quantity']!, _quantityMeta),
      );
    } else if (isInserting) {
      context.missing(_quantityMeta);
    }
    if (data.containsKey('stored_in')) {
      context.handle(
        _storedInMeta,
        storedIn.isAcceptableOrUnknown(data['stored_in']!, _storedInMeta),
      );
    }
    if (data.containsKey('price')) {
      context.handle(
        _priceMeta,
        price.isAcceptableOrUnknown(data['price']!, _priceMeta),
      );
    }
    if (data.containsKey('desc')) {
      context.handle(
        _descMeta,
        desc.isAcceptableOrUnknown(data['desc']!, _descMeta),
      );
    }
    if (data.containsKey('improvements')) {
      context.handle(
        _improvementsMeta,
        improvements.isAcceptableOrUnknown(
          data['improvements']!,
          _improvementsMeta,
        ),
      );
    }
    if (data.containsKey('special_material_index')) {
      context.handle(
        _specialMaterialIndexMeta,
        specialMaterialIndex.isAcceptableOrUnknown(
          data['special_material_index']!,
          _specialMaterialIndexMeta,
        ),
      );
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    } else if (isInserting) {
      context.missing(_createdAtMeta);
    }
    if (data.containsKey('updated_at')) {
      context.handle(
        _updatedAtMeta,
        updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta),
      );
    } else if (isInserting) {
      context.missing(_updatedAtMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {uuid};
  @override
  AmmunitionTableData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return AmmunitionTableData(
      uuid: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}uuid'],
      )!,
      name: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}name'],
      )!,
      parentUuid: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}parent_uuid'],
      )!,
      quantity: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}quantity'],
      )!,
      storedIn: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}stored_in'],
      ),
      price: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}price'],
      ),
      desc: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}desc'],
      ),
      improvements: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}improvements'],
      ),
      specialMaterialIndex: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}special_material_index'],
      ),
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}created_at'],
      )!,
      updatedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}updated_at'],
      )!,
    );
  }

  @override
  $AmmunitionTableTable createAlias(String alias) {
    return $AmmunitionTableTable(attachedDatabase, alias);
  }
}

class AmmunitionTableData extends DataClass
    implements Insertable<AmmunitionTableData> {
  final String uuid;
  final String name;
  final String parentUuid;
  final int quantity;
  final String? storedIn;
  final double? price;
  final String? desc;
  final String? improvements;
  final int? specialMaterialIndex;
  final int createdAt;
  final int updatedAt;
  const AmmunitionTableData({
    required this.uuid,
    required this.name,
    required this.parentUuid,
    required this.quantity,
    this.storedIn,
    this.price,
    this.desc,
    this.improvements,
    this.specialMaterialIndex,
    required this.createdAt,
    required this.updatedAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['uuid'] = Variable<String>(uuid);
    map['name'] = Variable<String>(name);
    map['parent_uuid'] = Variable<String>(parentUuid);
    map['quantity'] = Variable<int>(quantity);
    if (!nullToAbsent || storedIn != null) {
      map['stored_in'] = Variable<String>(storedIn);
    }
    if (!nullToAbsent || price != null) {
      map['price'] = Variable<double>(price);
    }
    if (!nullToAbsent || desc != null) {
      map['desc'] = Variable<String>(desc);
    }
    if (!nullToAbsent || improvements != null) {
      map['improvements'] = Variable<String>(improvements);
    }
    if (!nullToAbsent || specialMaterialIndex != null) {
      map['special_material_index'] = Variable<int>(specialMaterialIndex);
    }
    map['created_at'] = Variable<int>(createdAt);
    map['updated_at'] = Variable<int>(updatedAt);
    return map;
  }

  AmmunitionTableCompanion toCompanion(bool nullToAbsent) {
    return AmmunitionTableCompanion(
      uuid: Value(uuid),
      name: Value(name),
      parentUuid: Value(parentUuid),
      quantity: Value(quantity),
      storedIn: storedIn == null && nullToAbsent
          ? const Value.absent()
          : Value(storedIn),
      price: price == null && nullToAbsent
          ? const Value.absent()
          : Value(price),
      desc: desc == null && nullToAbsent ? const Value.absent() : Value(desc),
      improvements: improvements == null && nullToAbsent
          ? const Value.absent()
          : Value(improvements),
      specialMaterialIndex: specialMaterialIndex == null && nullToAbsent
          ? const Value.absent()
          : Value(specialMaterialIndex),
      createdAt: Value(createdAt),
      updatedAt: Value(updatedAt),
    );
  }

  factory AmmunitionTableData.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AmmunitionTableData(
      uuid: serializer.fromJson<String>(json['uuid']),
      name: serializer.fromJson<String>(json['name']),
      parentUuid: serializer.fromJson<String>(json['parentUuid']),
      quantity: serializer.fromJson<int>(json['quantity']),
      storedIn: serializer.fromJson<String?>(json['storedIn']),
      price: serializer.fromJson<double?>(json['price']),
      desc: serializer.fromJson<String?>(json['desc']),
      improvements: serializer.fromJson<String?>(json['improvements']),
      specialMaterialIndex: serializer.fromJson<int?>(
        json['specialMaterialIndex'],
      ),
      createdAt: serializer.fromJson<int>(json['createdAt']),
      updatedAt: serializer.fromJson<int>(json['updatedAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'uuid': serializer.toJson<String>(uuid),
      'name': serializer.toJson<String>(name),
      'parentUuid': serializer.toJson<String>(parentUuid),
      'quantity': serializer.toJson<int>(quantity),
      'storedIn': serializer.toJson<String?>(storedIn),
      'price': serializer.toJson<double?>(price),
      'desc': serializer.toJson<String?>(desc),
      'improvements': serializer.toJson<String?>(improvements),
      'specialMaterialIndex': serializer.toJson<int?>(specialMaterialIndex),
      'createdAt': serializer.toJson<int>(createdAt),
      'updatedAt': serializer.toJson<int>(updatedAt),
    };
  }

  AmmunitionTableData copyWith({
    String? uuid,
    String? name,
    String? parentUuid,
    int? quantity,
    Value<String?> storedIn = const Value.absent(),
    Value<double?> price = const Value.absent(),
    Value<String?> desc = const Value.absent(),
    Value<String?> improvements = const Value.absent(),
    Value<int?> specialMaterialIndex = const Value.absent(),
    int? createdAt,
    int? updatedAt,
  }) => AmmunitionTableData(
    uuid: uuid ?? this.uuid,
    name: name ?? this.name,
    parentUuid: parentUuid ?? this.parentUuid,
    quantity: quantity ?? this.quantity,
    storedIn: storedIn.present ? storedIn.value : this.storedIn,
    price: price.present ? price.value : this.price,
    desc: desc.present ? desc.value : this.desc,
    improvements: improvements.present ? improvements.value : this.improvements,
    specialMaterialIndex: specialMaterialIndex.present
        ? specialMaterialIndex.value
        : this.specialMaterialIndex,
    createdAt: createdAt ?? this.createdAt,
    updatedAt: updatedAt ?? this.updatedAt,
  );
  AmmunitionTableData copyWithCompanion(AmmunitionTableCompanion data) {
    return AmmunitionTableData(
      uuid: data.uuid.present ? data.uuid.value : this.uuid,
      name: data.name.present ? data.name.value : this.name,
      parentUuid: data.parentUuid.present
          ? data.parentUuid.value
          : this.parentUuid,
      quantity: data.quantity.present ? data.quantity.value : this.quantity,
      storedIn: data.storedIn.present ? data.storedIn.value : this.storedIn,
      price: data.price.present ? data.price.value : this.price,
      desc: data.desc.present ? data.desc.value : this.desc,
      improvements: data.improvements.present
          ? data.improvements.value
          : this.improvements,
      specialMaterialIndex: data.specialMaterialIndex.present
          ? data.specialMaterialIndex.value
          : this.specialMaterialIndex,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('AmmunitionTableData(')
          ..write('uuid: $uuid, ')
          ..write('name: $name, ')
          ..write('parentUuid: $parentUuid, ')
          ..write('quantity: $quantity, ')
          ..write('storedIn: $storedIn, ')
          ..write('price: $price, ')
          ..write('desc: $desc, ')
          ..write('improvements: $improvements, ')
          ..write('specialMaterialIndex: $specialMaterialIndex, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    uuid,
    name,
    parentUuid,
    quantity,
    storedIn,
    price,
    desc,
    improvements,
    specialMaterialIndex,
    createdAt,
    updatedAt,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AmmunitionTableData &&
          other.uuid == this.uuid &&
          other.name == this.name &&
          other.parentUuid == this.parentUuid &&
          other.quantity == this.quantity &&
          other.storedIn == this.storedIn &&
          other.price == this.price &&
          other.desc == this.desc &&
          other.improvements == this.improvements &&
          other.specialMaterialIndex == this.specialMaterialIndex &&
          other.createdAt == this.createdAt &&
          other.updatedAt == this.updatedAt);
}

class AmmunitionTableCompanion extends UpdateCompanion<AmmunitionTableData> {
  final Value<String> uuid;
  final Value<String> name;
  final Value<String> parentUuid;
  final Value<int> quantity;
  final Value<String?> storedIn;
  final Value<double?> price;
  final Value<String?> desc;
  final Value<String?> improvements;
  final Value<int?> specialMaterialIndex;
  final Value<int> createdAt;
  final Value<int> updatedAt;
  final Value<int> rowid;
  const AmmunitionTableCompanion({
    this.uuid = const Value.absent(),
    this.name = const Value.absent(),
    this.parentUuid = const Value.absent(),
    this.quantity = const Value.absent(),
    this.storedIn = const Value.absent(),
    this.price = const Value.absent(),
    this.desc = const Value.absent(),
    this.improvements = const Value.absent(),
    this.specialMaterialIndex = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  AmmunitionTableCompanion.insert({
    required String uuid,
    required String name,
    required String parentUuid,
    required int quantity,
    this.storedIn = const Value.absent(),
    this.price = const Value.absent(),
    this.desc = const Value.absent(),
    this.improvements = const Value.absent(),
    this.specialMaterialIndex = const Value.absent(),
    required int createdAt,
    required int updatedAt,
    this.rowid = const Value.absent(),
  }) : uuid = Value(uuid),
       name = Value(name),
       parentUuid = Value(parentUuid),
       quantity = Value(quantity),
       createdAt = Value(createdAt),
       updatedAt = Value(updatedAt);
  static Insertable<AmmunitionTableData> custom({
    Expression<String>? uuid,
    Expression<String>? name,
    Expression<String>? parentUuid,
    Expression<int>? quantity,
    Expression<String>? storedIn,
    Expression<double>? price,
    Expression<String>? desc,
    Expression<String>? improvements,
    Expression<int>? specialMaterialIndex,
    Expression<int>? createdAt,
    Expression<int>? updatedAt,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (uuid != null) 'uuid': uuid,
      if (name != null) 'name': name,
      if (parentUuid != null) 'parent_uuid': parentUuid,
      if (quantity != null) 'quantity': quantity,
      if (storedIn != null) 'stored_in': storedIn,
      if (price != null) 'price': price,
      if (desc != null) 'desc': desc,
      if (improvements != null) 'improvements': improvements,
      if (specialMaterialIndex != null)
        'special_material_index': specialMaterialIndex,
      if (createdAt != null) 'created_at': createdAt,
      if (updatedAt != null) 'updated_at': updatedAt,
      if (rowid != null) 'rowid': rowid,
    });
  }

  AmmunitionTableCompanion copyWith({
    Value<String>? uuid,
    Value<String>? name,
    Value<String>? parentUuid,
    Value<int>? quantity,
    Value<String?>? storedIn,
    Value<double?>? price,
    Value<String?>? desc,
    Value<String?>? improvements,
    Value<int?>? specialMaterialIndex,
    Value<int>? createdAt,
    Value<int>? updatedAt,
    Value<int>? rowid,
  }) {
    return AmmunitionTableCompanion(
      uuid: uuid ?? this.uuid,
      name: name ?? this.name,
      parentUuid: parentUuid ?? this.parentUuid,
      quantity: quantity ?? this.quantity,
      storedIn: storedIn ?? this.storedIn,
      price: price ?? this.price,
      desc: desc ?? this.desc,
      improvements: improvements ?? this.improvements,
      specialMaterialIndex: specialMaterialIndex ?? this.specialMaterialIndex,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (uuid.present) {
      map['uuid'] = Variable<String>(uuid.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    if (parentUuid.present) {
      map['parent_uuid'] = Variable<String>(parentUuid.value);
    }
    if (quantity.present) {
      map['quantity'] = Variable<int>(quantity.value);
    }
    if (storedIn.present) {
      map['stored_in'] = Variable<String>(storedIn.value);
    }
    if (price.present) {
      map['price'] = Variable<double>(price.value);
    }
    if (desc.present) {
      map['desc'] = Variable<String>(desc.value);
    }
    if (improvements.present) {
      map['improvements'] = Variable<String>(improvements.value);
    }
    if (specialMaterialIndex.present) {
      map['special_material_index'] = Variable<int>(specialMaterialIndex.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<int>(createdAt.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<int>(updatedAt.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AmmunitionTableCompanion(')
          ..write('uuid: $uuid, ')
          ..write('name: $name, ')
          ..write('parentUuid: $parentUuid, ')
          ..write('quantity: $quantity, ')
          ..write('storedIn: $storedIn, ')
          ..write('price: $price, ')
          ..write('desc: $desc, ')
          ..write('improvements: $improvements, ')
          ..write('specialMaterialIndex: $specialMaterialIndex, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $ArmorTableTable extends ArmorTable
    with TableInfo<$ArmorTableTable, ArmorTableData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $ArmorTableTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _uuidMeta = const VerificationMeta('uuid');
  @override
  late final GeneratedColumn<String> uuid = GeneratedColumn<String>(
    'uuid',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
    'name',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _parentUuidMeta = const VerificationMeta(
    'parentUuid',
  );
  @override
  late final GeneratedColumn<String> parentUuid = GeneratedColumn<String>(
    'parent_uuid',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _storedInMeta = const VerificationMeta(
    'storedIn',
  );
  @override
  late final GeneratedColumn<String> storedIn = GeneratedColumn<String>(
    'stored_in',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _improvementsMeta = const VerificationMeta(
    'improvements',
  );
  @override
  late final GeneratedColumn<String> improvements = GeneratedColumn<String>(
    'improvements',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _specialMaterialIndexMeta =
      const VerificationMeta('specialMaterialIndex');
  @override
  late final GeneratedColumn<int> specialMaterialIndex = GeneratedColumn<int>(
    'special_material_index',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _priceMeta = const VerificationMeta('price');
  @override
  late final GeneratedColumn<double> price = GeneratedColumn<double>(
    'price',
    aliasedName,
    true,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _descMeta = const VerificationMeta('desc');
  @override
  late final GeneratedColumn<String> desc = GeneratedColumn<String>(
    'desc',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _ocupedSpaceMeta = const VerificationMeta(
    'ocupedSpace',
  );
  @override
  late final GeneratedColumn<double> ocupedSpace = GeneratedColumn<double>(
    'ocuped_space',
    aliasedName,
    false,
    type: DriftSqlType.double,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _typeIndexMeta = const VerificationMeta(
    'typeIndex',
  );
  @override
  late final GeneratedColumn<int> typeIndex = GeneratedColumn<int>(
    'type_index',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _defenseBonusMeta = const VerificationMeta(
    'defenseBonus',
  );
  @override
  late final GeneratedColumn<int> defenseBonus = GeneratedColumn<int>(
    'defense_bonus',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _penaltyMeta = const VerificationMeta(
    'penalty',
  );
  @override
  late final GeneratedColumn<int> penalty = GeneratedColumn<int>(
    'penalty',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _inUseMeta = const VerificationMeta('inUse');
  @override
  late final GeneratedColumn<bool> inUse = GeneratedColumn<bool>(
    'in_use',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("in_use" IN (0, 1))',
    ),
    defaultValue: const Constant(false),
  );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<int> createdAt = GeneratedColumn<int>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _updatedAtMeta = const VerificationMeta(
    'updatedAt',
  );
  @override
  late final GeneratedColumn<int> updatedAt = GeneratedColumn<int>(
    'updated_at',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  @override
  List<GeneratedColumn> get $columns => [
    uuid,
    name,
    parentUuid,
    storedIn,
    improvements,
    specialMaterialIndex,
    price,
    desc,
    ocupedSpace,
    typeIndex,
    defenseBonus,
    penalty,
    inUse,
    createdAt,
    updatedAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'armor_table';
  @override
  VerificationContext validateIntegrity(
    Insertable<ArmorTableData> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('uuid')) {
      context.handle(
        _uuidMeta,
        uuid.isAcceptableOrUnknown(data['uuid']!, _uuidMeta),
      );
    } else if (isInserting) {
      context.missing(_uuidMeta);
    }
    if (data.containsKey('name')) {
      context.handle(
        _nameMeta,
        name.isAcceptableOrUnknown(data['name']!, _nameMeta),
      );
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    if (data.containsKey('parent_uuid')) {
      context.handle(
        _parentUuidMeta,
        parentUuid.isAcceptableOrUnknown(data['parent_uuid']!, _parentUuidMeta),
      );
    } else if (isInserting) {
      context.missing(_parentUuidMeta);
    }
    if (data.containsKey('stored_in')) {
      context.handle(
        _storedInMeta,
        storedIn.isAcceptableOrUnknown(data['stored_in']!, _storedInMeta),
      );
    }
    if (data.containsKey('improvements')) {
      context.handle(
        _improvementsMeta,
        improvements.isAcceptableOrUnknown(
          data['improvements']!,
          _improvementsMeta,
        ),
      );
    }
    if (data.containsKey('special_material_index')) {
      context.handle(
        _specialMaterialIndexMeta,
        specialMaterialIndex.isAcceptableOrUnknown(
          data['special_material_index']!,
          _specialMaterialIndexMeta,
        ),
      );
    }
    if (data.containsKey('price')) {
      context.handle(
        _priceMeta,
        price.isAcceptableOrUnknown(data['price']!, _priceMeta),
      );
    }
    if (data.containsKey('desc')) {
      context.handle(
        _descMeta,
        desc.isAcceptableOrUnknown(data['desc']!, _descMeta),
      );
    }
    if (data.containsKey('ocuped_space')) {
      context.handle(
        _ocupedSpaceMeta,
        ocupedSpace.isAcceptableOrUnknown(
          data['ocuped_space']!,
          _ocupedSpaceMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_ocupedSpaceMeta);
    }
    if (data.containsKey('type_index')) {
      context.handle(
        _typeIndexMeta,
        typeIndex.isAcceptableOrUnknown(data['type_index']!, _typeIndexMeta),
      );
    } else if (isInserting) {
      context.missing(_typeIndexMeta);
    }
    if (data.containsKey('defense_bonus')) {
      context.handle(
        _defenseBonusMeta,
        defenseBonus.isAcceptableOrUnknown(
          data['defense_bonus']!,
          _defenseBonusMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_defenseBonusMeta);
    }
    if (data.containsKey('penalty')) {
      context.handle(
        _penaltyMeta,
        penalty.isAcceptableOrUnknown(data['penalty']!, _penaltyMeta),
      );
    } else if (isInserting) {
      context.missing(_penaltyMeta);
    }
    if (data.containsKey('in_use')) {
      context.handle(
        _inUseMeta,
        inUse.isAcceptableOrUnknown(data['in_use']!, _inUseMeta),
      );
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    } else if (isInserting) {
      context.missing(_createdAtMeta);
    }
    if (data.containsKey('updated_at')) {
      context.handle(
        _updatedAtMeta,
        updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta),
      );
    } else if (isInserting) {
      context.missing(_updatedAtMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {uuid};
  @override
  ArmorTableData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return ArmorTableData(
      uuid: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}uuid'],
      )!,
      name: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}name'],
      )!,
      parentUuid: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}parent_uuid'],
      )!,
      storedIn: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}stored_in'],
      ),
      improvements: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}improvements'],
      ),
      specialMaterialIndex: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}special_material_index'],
      ),
      price: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}price'],
      ),
      desc: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}desc'],
      ),
      ocupedSpace: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}ocuped_space'],
      )!,
      typeIndex: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}type_index'],
      )!,
      defenseBonus: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}defense_bonus'],
      )!,
      penalty: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}penalty'],
      )!,
      inUse: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}in_use'],
      )!,
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}created_at'],
      )!,
      updatedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}updated_at'],
      )!,
    );
  }

  @override
  $ArmorTableTable createAlias(String alias) {
    return $ArmorTableTable(attachedDatabase, alias);
  }
}

class ArmorTableData extends DataClass implements Insertable<ArmorTableData> {
  final String uuid;
  final String name;
  final String parentUuid;
  final String? storedIn;
  final String? improvements;
  final int? specialMaterialIndex;
  final double? price;
  final String? desc;
  final double ocupedSpace;
  final int typeIndex;
  final int defenseBonus;
  final int penalty;
  final bool inUse;
  final int createdAt;
  final int updatedAt;
  const ArmorTableData({
    required this.uuid,
    required this.name,
    required this.parentUuid,
    this.storedIn,
    this.improvements,
    this.specialMaterialIndex,
    this.price,
    this.desc,
    required this.ocupedSpace,
    required this.typeIndex,
    required this.defenseBonus,
    required this.penalty,
    required this.inUse,
    required this.createdAt,
    required this.updatedAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['uuid'] = Variable<String>(uuid);
    map['name'] = Variable<String>(name);
    map['parent_uuid'] = Variable<String>(parentUuid);
    if (!nullToAbsent || storedIn != null) {
      map['stored_in'] = Variable<String>(storedIn);
    }
    if (!nullToAbsent || improvements != null) {
      map['improvements'] = Variable<String>(improvements);
    }
    if (!nullToAbsent || specialMaterialIndex != null) {
      map['special_material_index'] = Variable<int>(specialMaterialIndex);
    }
    if (!nullToAbsent || price != null) {
      map['price'] = Variable<double>(price);
    }
    if (!nullToAbsent || desc != null) {
      map['desc'] = Variable<String>(desc);
    }
    map['ocuped_space'] = Variable<double>(ocupedSpace);
    map['type_index'] = Variable<int>(typeIndex);
    map['defense_bonus'] = Variable<int>(defenseBonus);
    map['penalty'] = Variable<int>(penalty);
    map['in_use'] = Variable<bool>(inUse);
    map['created_at'] = Variable<int>(createdAt);
    map['updated_at'] = Variable<int>(updatedAt);
    return map;
  }

  ArmorTableCompanion toCompanion(bool nullToAbsent) {
    return ArmorTableCompanion(
      uuid: Value(uuid),
      name: Value(name),
      parentUuid: Value(parentUuid),
      storedIn: storedIn == null && nullToAbsent
          ? const Value.absent()
          : Value(storedIn),
      improvements: improvements == null && nullToAbsent
          ? const Value.absent()
          : Value(improvements),
      specialMaterialIndex: specialMaterialIndex == null && nullToAbsent
          ? const Value.absent()
          : Value(specialMaterialIndex),
      price: price == null && nullToAbsent
          ? const Value.absent()
          : Value(price),
      desc: desc == null && nullToAbsent ? const Value.absent() : Value(desc),
      ocupedSpace: Value(ocupedSpace),
      typeIndex: Value(typeIndex),
      defenseBonus: Value(defenseBonus),
      penalty: Value(penalty),
      inUse: Value(inUse),
      createdAt: Value(createdAt),
      updatedAt: Value(updatedAt),
    );
  }

  factory ArmorTableData.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return ArmorTableData(
      uuid: serializer.fromJson<String>(json['uuid']),
      name: serializer.fromJson<String>(json['name']),
      parentUuid: serializer.fromJson<String>(json['parentUuid']),
      storedIn: serializer.fromJson<String?>(json['storedIn']),
      improvements: serializer.fromJson<String?>(json['improvements']),
      specialMaterialIndex: serializer.fromJson<int?>(
        json['specialMaterialIndex'],
      ),
      price: serializer.fromJson<double?>(json['price']),
      desc: serializer.fromJson<String?>(json['desc']),
      ocupedSpace: serializer.fromJson<double>(json['ocupedSpace']),
      typeIndex: serializer.fromJson<int>(json['typeIndex']),
      defenseBonus: serializer.fromJson<int>(json['defenseBonus']),
      penalty: serializer.fromJson<int>(json['penalty']),
      inUse: serializer.fromJson<bool>(json['inUse']),
      createdAt: serializer.fromJson<int>(json['createdAt']),
      updatedAt: serializer.fromJson<int>(json['updatedAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'uuid': serializer.toJson<String>(uuid),
      'name': serializer.toJson<String>(name),
      'parentUuid': serializer.toJson<String>(parentUuid),
      'storedIn': serializer.toJson<String?>(storedIn),
      'improvements': serializer.toJson<String?>(improvements),
      'specialMaterialIndex': serializer.toJson<int?>(specialMaterialIndex),
      'price': serializer.toJson<double?>(price),
      'desc': serializer.toJson<String?>(desc),
      'ocupedSpace': serializer.toJson<double>(ocupedSpace),
      'typeIndex': serializer.toJson<int>(typeIndex),
      'defenseBonus': serializer.toJson<int>(defenseBonus),
      'penalty': serializer.toJson<int>(penalty),
      'inUse': serializer.toJson<bool>(inUse),
      'createdAt': serializer.toJson<int>(createdAt),
      'updatedAt': serializer.toJson<int>(updatedAt),
    };
  }

  ArmorTableData copyWith({
    String? uuid,
    String? name,
    String? parentUuid,
    Value<String?> storedIn = const Value.absent(),
    Value<String?> improvements = const Value.absent(),
    Value<int?> specialMaterialIndex = const Value.absent(),
    Value<double?> price = const Value.absent(),
    Value<String?> desc = const Value.absent(),
    double? ocupedSpace,
    int? typeIndex,
    int? defenseBonus,
    int? penalty,
    bool? inUse,
    int? createdAt,
    int? updatedAt,
  }) => ArmorTableData(
    uuid: uuid ?? this.uuid,
    name: name ?? this.name,
    parentUuid: parentUuid ?? this.parentUuid,
    storedIn: storedIn.present ? storedIn.value : this.storedIn,
    improvements: improvements.present ? improvements.value : this.improvements,
    specialMaterialIndex: specialMaterialIndex.present
        ? specialMaterialIndex.value
        : this.specialMaterialIndex,
    price: price.present ? price.value : this.price,
    desc: desc.present ? desc.value : this.desc,
    ocupedSpace: ocupedSpace ?? this.ocupedSpace,
    typeIndex: typeIndex ?? this.typeIndex,
    defenseBonus: defenseBonus ?? this.defenseBonus,
    penalty: penalty ?? this.penalty,
    inUse: inUse ?? this.inUse,
    createdAt: createdAt ?? this.createdAt,
    updatedAt: updatedAt ?? this.updatedAt,
  );
  ArmorTableData copyWithCompanion(ArmorTableCompanion data) {
    return ArmorTableData(
      uuid: data.uuid.present ? data.uuid.value : this.uuid,
      name: data.name.present ? data.name.value : this.name,
      parentUuid: data.parentUuid.present
          ? data.parentUuid.value
          : this.parentUuid,
      storedIn: data.storedIn.present ? data.storedIn.value : this.storedIn,
      improvements: data.improvements.present
          ? data.improvements.value
          : this.improvements,
      specialMaterialIndex: data.specialMaterialIndex.present
          ? data.specialMaterialIndex.value
          : this.specialMaterialIndex,
      price: data.price.present ? data.price.value : this.price,
      desc: data.desc.present ? data.desc.value : this.desc,
      ocupedSpace: data.ocupedSpace.present
          ? data.ocupedSpace.value
          : this.ocupedSpace,
      typeIndex: data.typeIndex.present ? data.typeIndex.value : this.typeIndex,
      defenseBonus: data.defenseBonus.present
          ? data.defenseBonus.value
          : this.defenseBonus,
      penalty: data.penalty.present ? data.penalty.value : this.penalty,
      inUse: data.inUse.present ? data.inUse.value : this.inUse,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('ArmorTableData(')
          ..write('uuid: $uuid, ')
          ..write('name: $name, ')
          ..write('parentUuid: $parentUuid, ')
          ..write('storedIn: $storedIn, ')
          ..write('improvements: $improvements, ')
          ..write('specialMaterialIndex: $specialMaterialIndex, ')
          ..write('price: $price, ')
          ..write('desc: $desc, ')
          ..write('ocupedSpace: $ocupedSpace, ')
          ..write('typeIndex: $typeIndex, ')
          ..write('defenseBonus: $defenseBonus, ')
          ..write('penalty: $penalty, ')
          ..write('inUse: $inUse, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    uuid,
    name,
    parentUuid,
    storedIn,
    improvements,
    specialMaterialIndex,
    price,
    desc,
    ocupedSpace,
    typeIndex,
    defenseBonus,
    penalty,
    inUse,
    createdAt,
    updatedAt,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is ArmorTableData &&
          other.uuid == this.uuid &&
          other.name == this.name &&
          other.parentUuid == this.parentUuid &&
          other.storedIn == this.storedIn &&
          other.improvements == this.improvements &&
          other.specialMaterialIndex == this.specialMaterialIndex &&
          other.price == this.price &&
          other.desc == this.desc &&
          other.ocupedSpace == this.ocupedSpace &&
          other.typeIndex == this.typeIndex &&
          other.defenseBonus == this.defenseBonus &&
          other.penalty == this.penalty &&
          other.inUse == this.inUse &&
          other.createdAt == this.createdAt &&
          other.updatedAt == this.updatedAt);
}

class ArmorTableCompanion extends UpdateCompanion<ArmorTableData> {
  final Value<String> uuid;
  final Value<String> name;
  final Value<String> parentUuid;
  final Value<String?> storedIn;
  final Value<String?> improvements;
  final Value<int?> specialMaterialIndex;
  final Value<double?> price;
  final Value<String?> desc;
  final Value<double> ocupedSpace;
  final Value<int> typeIndex;
  final Value<int> defenseBonus;
  final Value<int> penalty;
  final Value<bool> inUse;
  final Value<int> createdAt;
  final Value<int> updatedAt;
  final Value<int> rowid;
  const ArmorTableCompanion({
    this.uuid = const Value.absent(),
    this.name = const Value.absent(),
    this.parentUuid = const Value.absent(),
    this.storedIn = const Value.absent(),
    this.improvements = const Value.absent(),
    this.specialMaterialIndex = const Value.absent(),
    this.price = const Value.absent(),
    this.desc = const Value.absent(),
    this.ocupedSpace = const Value.absent(),
    this.typeIndex = const Value.absent(),
    this.defenseBonus = const Value.absent(),
    this.penalty = const Value.absent(),
    this.inUse = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  ArmorTableCompanion.insert({
    required String uuid,
    required String name,
    required String parentUuid,
    this.storedIn = const Value.absent(),
    this.improvements = const Value.absent(),
    this.specialMaterialIndex = const Value.absent(),
    this.price = const Value.absent(),
    this.desc = const Value.absent(),
    required double ocupedSpace,
    required int typeIndex,
    required int defenseBonus,
    required int penalty,
    this.inUse = const Value.absent(),
    required int createdAt,
    required int updatedAt,
    this.rowid = const Value.absent(),
  }) : uuid = Value(uuid),
       name = Value(name),
       parentUuid = Value(parentUuid),
       ocupedSpace = Value(ocupedSpace),
       typeIndex = Value(typeIndex),
       defenseBonus = Value(defenseBonus),
       penalty = Value(penalty),
       createdAt = Value(createdAt),
       updatedAt = Value(updatedAt);
  static Insertable<ArmorTableData> custom({
    Expression<String>? uuid,
    Expression<String>? name,
    Expression<String>? parentUuid,
    Expression<String>? storedIn,
    Expression<String>? improvements,
    Expression<int>? specialMaterialIndex,
    Expression<double>? price,
    Expression<String>? desc,
    Expression<double>? ocupedSpace,
    Expression<int>? typeIndex,
    Expression<int>? defenseBonus,
    Expression<int>? penalty,
    Expression<bool>? inUse,
    Expression<int>? createdAt,
    Expression<int>? updatedAt,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (uuid != null) 'uuid': uuid,
      if (name != null) 'name': name,
      if (parentUuid != null) 'parent_uuid': parentUuid,
      if (storedIn != null) 'stored_in': storedIn,
      if (improvements != null) 'improvements': improvements,
      if (specialMaterialIndex != null)
        'special_material_index': specialMaterialIndex,
      if (price != null) 'price': price,
      if (desc != null) 'desc': desc,
      if (ocupedSpace != null) 'ocuped_space': ocupedSpace,
      if (typeIndex != null) 'type_index': typeIndex,
      if (defenseBonus != null) 'defense_bonus': defenseBonus,
      if (penalty != null) 'penalty': penalty,
      if (inUse != null) 'in_use': inUse,
      if (createdAt != null) 'created_at': createdAt,
      if (updatedAt != null) 'updated_at': updatedAt,
      if (rowid != null) 'rowid': rowid,
    });
  }

  ArmorTableCompanion copyWith({
    Value<String>? uuid,
    Value<String>? name,
    Value<String>? parentUuid,
    Value<String?>? storedIn,
    Value<String?>? improvements,
    Value<int?>? specialMaterialIndex,
    Value<double?>? price,
    Value<String?>? desc,
    Value<double>? ocupedSpace,
    Value<int>? typeIndex,
    Value<int>? defenseBonus,
    Value<int>? penalty,
    Value<bool>? inUse,
    Value<int>? createdAt,
    Value<int>? updatedAt,
    Value<int>? rowid,
  }) {
    return ArmorTableCompanion(
      uuid: uuid ?? this.uuid,
      name: name ?? this.name,
      parentUuid: parentUuid ?? this.parentUuid,
      storedIn: storedIn ?? this.storedIn,
      improvements: improvements ?? this.improvements,
      specialMaterialIndex: specialMaterialIndex ?? this.specialMaterialIndex,
      price: price ?? this.price,
      desc: desc ?? this.desc,
      ocupedSpace: ocupedSpace ?? this.ocupedSpace,
      typeIndex: typeIndex ?? this.typeIndex,
      defenseBonus: defenseBonus ?? this.defenseBonus,
      penalty: penalty ?? this.penalty,
      inUse: inUse ?? this.inUse,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (uuid.present) {
      map['uuid'] = Variable<String>(uuid.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    if (parentUuid.present) {
      map['parent_uuid'] = Variable<String>(parentUuid.value);
    }
    if (storedIn.present) {
      map['stored_in'] = Variable<String>(storedIn.value);
    }
    if (improvements.present) {
      map['improvements'] = Variable<String>(improvements.value);
    }
    if (specialMaterialIndex.present) {
      map['special_material_index'] = Variable<int>(specialMaterialIndex.value);
    }
    if (price.present) {
      map['price'] = Variable<double>(price.value);
    }
    if (desc.present) {
      map['desc'] = Variable<String>(desc.value);
    }
    if (ocupedSpace.present) {
      map['ocuped_space'] = Variable<double>(ocupedSpace.value);
    }
    if (typeIndex.present) {
      map['type_index'] = Variable<int>(typeIndex.value);
    }
    if (defenseBonus.present) {
      map['defense_bonus'] = Variable<int>(defenseBonus.value);
    }
    if (penalty.present) {
      map['penalty'] = Variable<int>(penalty.value);
    }
    if (inUse.present) {
      map['in_use'] = Variable<bool>(inUse.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<int>(createdAt.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<int>(updatedAt.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('ArmorTableCompanion(')
          ..write('uuid: $uuid, ')
          ..write('name: $name, ')
          ..write('parentUuid: $parentUuid, ')
          ..write('storedIn: $storedIn, ')
          ..write('improvements: $improvements, ')
          ..write('specialMaterialIndex: $specialMaterialIndex, ')
          ..write('price: $price, ')
          ..write('desc: $desc, ')
          ..write('ocupedSpace: $ocupedSpace, ')
          ..write('typeIndex: $typeIndex, ')
          ..write('defenseBonus: $defenseBonus, ')
          ..write('penalty: $penalty, ')
          ..write('inUse: $inUse, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $BackpackTableTable extends BackpackTable
    with TableInfo<$BackpackTableTable, BackpackTableData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $BackpackTableTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _uuidMeta = const VerificationMeta('uuid');
  @override
  late final GeneratedColumn<String> uuid = GeneratedColumn<String>(
    'uuid',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
    'name',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _parentUuidMeta = const VerificationMeta(
    'parentUuid',
  );
  @override
  late final GeneratedColumn<String> parentUuid = GeneratedColumn<String>(
    'parent_uuid',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _suffixMeta = const VerificationMeta('suffix');
  @override
  late final GeneratedColumn<String> suffix = GeneratedColumn<String>(
    'suffix',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _priceMeta = const VerificationMeta('price');
  @override
  late final GeneratedColumn<double> price = GeneratedColumn<double>(
    'price',
    aliasedName,
    true,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<int> createdAt = GeneratedColumn<int>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _updatedAtMeta = const VerificationMeta(
    'updatedAt',
  );
  @override
  late final GeneratedColumn<int> updatedAt = GeneratedColumn<int>(
    'updated_at',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  @override
  List<GeneratedColumn> get $columns => [
    uuid,
    name,
    parentUuid,
    suffix,
    price,
    createdAt,
    updatedAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'backpack_table';
  @override
  VerificationContext validateIntegrity(
    Insertable<BackpackTableData> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('uuid')) {
      context.handle(
        _uuidMeta,
        uuid.isAcceptableOrUnknown(data['uuid']!, _uuidMeta),
      );
    } else if (isInserting) {
      context.missing(_uuidMeta);
    }
    if (data.containsKey('name')) {
      context.handle(
        _nameMeta,
        name.isAcceptableOrUnknown(data['name']!, _nameMeta),
      );
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    if (data.containsKey('parent_uuid')) {
      context.handle(
        _parentUuidMeta,
        parentUuid.isAcceptableOrUnknown(data['parent_uuid']!, _parentUuidMeta),
      );
    } else if (isInserting) {
      context.missing(_parentUuidMeta);
    }
    if (data.containsKey('suffix')) {
      context.handle(
        _suffixMeta,
        suffix.isAcceptableOrUnknown(data['suffix']!, _suffixMeta),
      );
    }
    if (data.containsKey('price')) {
      context.handle(
        _priceMeta,
        price.isAcceptableOrUnknown(data['price']!, _priceMeta),
      );
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    } else if (isInserting) {
      context.missing(_createdAtMeta);
    }
    if (data.containsKey('updated_at')) {
      context.handle(
        _updatedAtMeta,
        updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta),
      );
    } else if (isInserting) {
      context.missing(_updatedAtMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {uuid};
  @override
  BackpackTableData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return BackpackTableData(
      uuid: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}uuid'],
      )!,
      name: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}name'],
      )!,
      parentUuid: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}parent_uuid'],
      )!,
      suffix: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}suffix'],
      ),
      price: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}price'],
      ),
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}created_at'],
      )!,
      updatedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}updated_at'],
      )!,
    );
  }

  @override
  $BackpackTableTable createAlias(String alias) {
    return $BackpackTableTable(attachedDatabase, alias);
  }
}

class BackpackTableData extends DataClass
    implements Insertable<BackpackTableData> {
  final String uuid;
  final String name;
  final String parentUuid;
  final String? suffix;
  final double? price;
  final int createdAt;
  final int updatedAt;
  const BackpackTableData({
    required this.uuid,
    required this.name,
    required this.parentUuid,
    this.suffix,
    this.price,
    required this.createdAt,
    required this.updatedAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['uuid'] = Variable<String>(uuid);
    map['name'] = Variable<String>(name);
    map['parent_uuid'] = Variable<String>(parentUuid);
    if (!nullToAbsent || suffix != null) {
      map['suffix'] = Variable<String>(suffix);
    }
    if (!nullToAbsent || price != null) {
      map['price'] = Variable<double>(price);
    }
    map['created_at'] = Variable<int>(createdAt);
    map['updated_at'] = Variable<int>(updatedAt);
    return map;
  }

  BackpackTableCompanion toCompanion(bool nullToAbsent) {
    return BackpackTableCompanion(
      uuid: Value(uuid),
      name: Value(name),
      parentUuid: Value(parentUuid),
      suffix: suffix == null && nullToAbsent
          ? const Value.absent()
          : Value(suffix),
      price: price == null && nullToAbsent
          ? const Value.absent()
          : Value(price),
      createdAt: Value(createdAt),
      updatedAt: Value(updatedAt),
    );
  }

  factory BackpackTableData.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return BackpackTableData(
      uuid: serializer.fromJson<String>(json['uuid']),
      name: serializer.fromJson<String>(json['name']),
      parentUuid: serializer.fromJson<String>(json['parentUuid']),
      suffix: serializer.fromJson<String?>(json['suffix']),
      price: serializer.fromJson<double?>(json['price']),
      createdAt: serializer.fromJson<int>(json['createdAt']),
      updatedAt: serializer.fromJson<int>(json['updatedAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'uuid': serializer.toJson<String>(uuid),
      'name': serializer.toJson<String>(name),
      'parentUuid': serializer.toJson<String>(parentUuid),
      'suffix': serializer.toJson<String?>(suffix),
      'price': serializer.toJson<double?>(price),
      'createdAt': serializer.toJson<int>(createdAt),
      'updatedAt': serializer.toJson<int>(updatedAt),
    };
  }

  BackpackTableData copyWith({
    String? uuid,
    String? name,
    String? parentUuid,
    Value<String?> suffix = const Value.absent(),
    Value<double?> price = const Value.absent(),
    int? createdAt,
    int? updatedAt,
  }) => BackpackTableData(
    uuid: uuid ?? this.uuid,
    name: name ?? this.name,
    parentUuid: parentUuid ?? this.parentUuid,
    suffix: suffix.present ? suffix.value : this.suffix,
    price: price.present ? price.value : this.price,
    createdAt: createdAt ?? this.createdAt,
    updatedAt: updatedAt ?? this.updatedAt,
  );
  BackpackTableData copyWithCompanion(BackpackTableCompanion data) {
    return BackpackTableData(
      uuid: data.uuid.present ? data.uuid.value : this.uuid,
      name: data.name.present ? data.name.value : this.name,
      parentUuid: data.parentUuid.present
          ? data.parentUuid.value
          : this.parentUuid,
      suffix: data.suffix.present ? data.suffix.value : this.suffix,
      price: data.price.present ? data.price.value : this.price,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('BackpackTableData(')
          ..write('uuid: $uuid, ')
          ..write('name: $name, ')
          ..write('parentUuid: $parentUuid, ')
          ..write('suffix: $suffix, ')
          ..write('price: $price, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode =>
      Object.hash(uuid, name, parentUuid, suffix, price, createdAt, updatedAt);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is BackpackTableData &&
          other.uuid == this.uuid &&
          other.name == this.name &&
          other.parentUuid == this.parentUuid &&
          other.suffix == this.suffix &&
          other.price == this.price &&
          other.createdAt == this.createdAt &&
          other.updatedAt == this.updatedAt);
}

class BackpackTableCompanion extends UpdateCompanion<BackpackTableData> {
  final Value<String> uuid;
  final Value<String> name;
  final Value<String> parentUuid;
  final Value<String?> suffix;
  final Value<double?> price;
  final Value<int> createdAt;
  final Value<int> updatedAt;
  final Value<int> rowid;
  const BackpackTableCompanion({
    this.uuid = const Value.absent(),
    this.name = const Value.absent(),
    this.parentUuid = const Value.absent(),
    this.suffix = const Value.absent(),
    this.price = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  BackpackTableCompanion.insert({
    required String uuid,
    required String name,
    required String parentUuid,
    this.suffix = const Value.absent(),
    this.price = const Value.absent(),
    required int createdAt,
    required int updatedAt,
    this.rowid = const Value.absent(),
  }) : uuid = Value(uuid),
       name = Value(name),
       parentUuid = Value(parentUuid),
       createdAt = Value(createdAt),
       updatedAt = Value(updatedAt);
  static Insertable<BackpackTableData> custom({
    Expression<String>? uuid,
    Expression<String>? name,
    Expression<String>? parentUuid,
    Expression<String>? suffix,
    Expression<double>? price,
    Expression<int>? createdAt,
    Expression<int>? updatedAt,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (uuid != null) 'uuid': uuid,
      if (name != null) 'name': name,
      if (parentUuid != null) 'parent_uuid': parentUuid,
      if (suffix != null) 'suffix': suffix,
      if (price != null) 'price': price,
      if (createdAt != null) 'created_at': createdAt,
      if (updatedAt != null) 'updated_at': updatedAt,
      if (rowid != null) 'rowid': rowid,
    });
  }

  BackpackTableCompanion copyWith({
    Value<String>? uuid,
    Value<String>? name,
    Value<String>? parentUuid,
    Value<String?>? suffix,
    Value<double?>? price,
    Value<int>? createdAt,
    Value<int>? updatedAt,
    Value<int>? rowid,
  }) {
    return BackpackTableCompanion(
      uuid: uuid ?? this.uuid,
      name: name ?? this.name,
      parentUuid: parentUuid ?? this.parentUuid,
      suffix: suffix ?? this.suffix,
      price: price ?? this.price,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (uuid.present) {
      map['uuid'] = Variable<String>(uuid.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    if (parentUuid.present) {
      map['parent_uuid'] = Variable<String>(parentUuid.value);
    }
    if (suffix.present) {
      map['suffix'] = Variable<String>(suffix.value);
    }
    if (price.present) {
      map['price'] = Variable<double>(price.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<int>(createdAt.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<int>(updatedAt.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('BackpackTableCompanion(')
          ..write('uuid: $uuid, ')
          ..write('name: $name, ')
          ..write('parentUuid: $parentUuid, ')
          ..write('suffix: $suffix, ')
          ..write('price: $price, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $GeneralItemTableTable extends GeneralItemTable
    with TableInfo<$GeneralItemTableTable, GeneralItemTableData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $GeneralItemTableTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _uuidMeta = const VerificationMeta('uuid');
  @override
  late final GeneratedColumn<String> uuid = GeneratedColumn<String>(
    'uuid',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
    'name',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _parentUuidMeta = const VerificationMeta(
    'parentUuid',
  );
  @override
  late final GeneratedColumn<String> parentUuid = GeneratedColumn<String>(
    'parent_uuid',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _storedInMeta = const VerificationMeta(
    'storedIn',
  );
  @override
  late final GeneratedColumn<String> storedIn = GeneratedColumn<String>(
    'stored_in',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _improvementsMeta = const VerificationMeta(
    'improvements',
  );
  @override
  late final GeneratedColumn<String> improvements = GeneratedColumn<String>(
    'improvements',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _specialMaterialIndexMeta =
      const VerificationMeta('specialMaterialIndex');
  @override
  late final GeneratedColumn<int> specialMaterialIndex = GeneratedColumn<int>(
    'special_material_index',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _priceMeta = const VerificationMeta('price');
  @override
  late final GeneratedColumn<double> price = GeneratedColumn<double>(
    'price',
    aliasedName,
    true,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _descMeta = const VerificationMeta('desc');
  @override
  late final GeneratedColumn<String> desc = GeneratedColumn<String>(
    'desc',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _ocupedSpaceMeta = const VerificationMeta(
    'ocupedSpace',
  );
  @override
  late final GeneratedColumn<double> ocupedSpace = GeneratedColumn<double>(
    'ocuped_space',
    aliasedName,
    false,
    type: DriftSqlType.double,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _typeIndexMeta = const VerificationMeta(
    'typeIndex',
  );
  @override
  late final GeneratedColumn<int> typeIndex = GeneratedColumn<int>(
    'type_index',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<int> createdAt = GeneratedColumn<int>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _updatedAtMeta = const VerificationMeta(
    'updatedAt',
  );
  @override
  late final GeneratedColumn<int> updatedAt = GeneratedColumn<int>(
    'updated_at',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  @override
  List<GeneratedColumn> get $columns => [
    uuid,
    name,
    parentUuid,
    storedIn,
    improvements,
    specialMaterialIndex,
    price,
    desc,
    ocupedSpace,
    typeIndex,
    createdAt,
    updatedAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'general_item_table';
  @override
  VerificationContext validateIntegrity(
    Insertable<GeneralItemTableData> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('uuid')) {
      context.handle(
        _uuidMeta,
        uuid.isAcceptableOrUnknown(data['uuid']!, _uuidMeta),
      );
    } else if (isInserting) {
      context.missing(_uuidMeta);
    }
    if (data.containsKey('name')) {
      context.handle(
        _nameMeta,
        name.isAcceptableOrUnknown(data['name']!, _nameMeta),
      );
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    if (data.containsKey('parent_uuid')) {
      context.handle(
        _parentUuidMeta,
        parentUuid.isAcceptableOrUnknown(data['parent_uuid']!, _parentUuidMeta),
      );
    } else if (isInserting) {
      context.missing(_parentUuidMeta);
    }
    if (data.containsKey('stored_in')) {
      context.handle(
        _storedInMeta,
        storedIn.isAcceptableOrUnknown(data['stored_in']!, _storedInMeta),
      );
    }
    if (data.containsKey('improvements')) {
      context.handle(
        _improvementsMeta,
        improvements.isAcceptableOrUnknown(
          data['improvements']!,
          _improvementsMeta,
        ),
      );
    }
    if (data.containsKey('special_material_index')) {
      context.handle(
        _specialMaterialIndexMeta,
        specialMaterialIndex.isAcceptableOrUnknown(
          data['special_material_index']!,
          _specialMaterialIndexMeta,
        ),
      );
    }
    if (data.containsKey('price')) {
      context.handle(
        _priceMeta,
        price.isAcceptableOrUnknown(data['price']!, _priceMeta),
      );
    }
    if (data.containsKey('desc')) {
      context.handle(
        _descMeta,
        desc.isAcceptableOrUnknown(data['desc']!, _descMeta),
      );
    }
    if (data.containsKey('ocuped_space')) {
      context.handle(
        _ocupedSpaceMeta,
        ocupedSpace.isAcceptableOrUnknown(
          data['ocuped_space']!,
          _ocupedSpaceMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_ocupedSpaceMeta);
    }
    if (data.containsKey('type_index')) {
      context.handle(
        _typeIndexMeta,
        typeIndex.isAcceptableOrUnknown(data['type_index']!, _typeIndexMeta),
      );
    } else if (isInserting) {
      context.missing(_typeIndexMeta);
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    } else if (isInserting) {
      context.missing(_createdAtMeta);
    }
    if (data.containsKey('updated_at')) {
      context.handle(
        _updatedAtMeta,
        updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta),
      );
    } else if (isInserting) {
      context.missing(_updatedAtMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {uuid};
  @override
  GeneralItemTableData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return GeneralItemTableData(
      uuid: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}uuid'],
      )!,
      name: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}name'],
      )!,
      parentUuid: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}parent_uuid'],
      )!,
      storedIn: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}stored_in'],
      ),
      improvements: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}improvements'],
      ),
      specialMaterialIndex: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}special_material_index'],
      ),
      price: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}price'],
      ),
      desc: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}desc'],
      ),
      ocupedSpace: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}ocuped_space'],
      )!,
      typeIndex: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}type_index'],
      )!,
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}created_at'],
      )!,
      updatedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}updated_at'],
      )!,
    );
  }

  @override
  $GeneralItemTableTable createAlias(String alias) {
    return $GeneralItemTableTable(attachedDatabase, alias);
  }
}

class GeneralItemTableData extends DataClass
    implements Insertable<GeneralItemTableData> {
  final String uuid;
  final String name;
  final String parentUuid;
  final String? storedIn;
  final String? improvements;
  final int? specialMaterialIndex;
  final double? price;
  final String? desc;
  final double ocupedSpace;
  final int typeIndex;
  final int createdAt;
  final int updatedAt;
  const GeneralItemTableData({
    required this.uuid,
    required this.name,
    required this.parentUuid,
    this.storedIn,
    this.improvements,
    this.specialMaterialIndex,
    this.price,
    this.desc,
    required this.ocupedSpace,
    required this.typeIndex,
    required this.createdAt,
    required this.updatedAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['uuid'] = Variable<String>(uuid);
    map['name'] = Variable<String>(name);
    map['parent_uuid'] = Variable<String>(parentUuid);
    if (!nullToAbsent || storedIn != null) {
      map['stored_in'] = Variable<String>(storedIn);
    }
    if (!nullToAbsent || improvements != null) {
      map['improvements'] = Variable<String>(improvements);
    }
    if (!nullToAbsent || specialMaterialIndex != null) {
      map['special_material_index'] = Variable<int>(specialMaterialIndex);
    }
    if (!nullToAbsent || price != null) {
      map['price'] = Variable<double>(price);
    }
    if (!nullToAbsent || desc != null) {
      map['desc'] = Variable<String>(desc);
    }
    map['ocuped_space'] = Variable<double>(ocupedSpace);
    map['type_index'] = Variable<int>(typeIndex);
    map['created_at'] = Variable<int>(createdAt);
    map['updated_at'] = Variable<int>(updatedAt);
    return map;
  }

  GeneralItemTableCompanion toCompanion(bool nullToAbsent) {
    return GeneralItemTableCompanion(
      uuid: Value(uuid),
      name: Value(name),
      parentUuid: Value(parentUuid),
      storedIn: storedIn == null && nullToAbsent
          ? const Value.absent()
          : Value(storedIn),
      improvements: improvements == null && nullToAbsent
          ? const Value.absent()
          : Value(improvements),
      specialMaterialIndex: specialMaterialIndex == null && nullToAbsent
          ? const Value.absent()
          : Value(specialMaterialIndex),
      price: price == null && nullToAbsent
          ? const Value.absent()
          : Value(price),
      desc: desc == null && nullToAbsent ? const Value.absent() : Value(desc),
      ocupedSpace: Value(ocupedSpace),
      typeIndex: Value(typeIndex),
      createdAt: Value(createdAt),
      updatedAt: Value(updatedAt),
    );
  }

  factory GeneralItemTableData.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return GeneralItemTableData(
      uuid: serializer.fromJson<String>(json['uuid']),
      name: serializer.fromJson<String>(json['name']),
      parentUuid: serializer.fromJson<String>(json['parentUuid']),
      storedIn: serializer.fromJson<String?>(json['storedIn']),
      improvements: serializer.fromJson<String?>(json['improvements']),
      specialMaterialIndex: serializer.fromJson<int?>(
        json['specialMaterialIndex'],
      ),
      price: serializer.fromJson<double?>(json['price']),
      desc: serializer.fromJson<String?>(json['desc']),
      ocupedSpace: serializer.fromJson<double>(json['ocupedSpace']),
      typeIndex: serializer.fromJson<int>(json['typeIndex']),
      createdAt: serializer.fromJson<int>(json['createdAt']),
      updatedAt: serializer.fromJson<int>(json['updatedAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'uuid': serializer.toJson<String>(uuid),
      'name': serializer.toJson<String>(name),
      'parentUuid': serializer.toJson<String>(parentUuid),
      'storedIn': serializer.toJson<String?>(storedIn),
      'improvements': serializer.toJson<String?>(improvements),
      'specialMaterialIndex': serializer.toJson<int?>(specialMaterialIndex),
      'price': serializer.toJson<double?>(price),
      'desc': serializer.toJson<String?>(desc),
      'ocupedSpace': serializer.toJson<double>(ocupedSpace),
      'typeIndex': serializer.toJson<int>(typeIndex),
      'createdAt': serializer.toJson<int>(createdAt),
      'updatedAt': serializer.toJson<int>(updatedAt),
    };
  }

  GeneralItemTableData copyWith({
    String? uuid,
    String? name,
    String? parentUuid,
    Value<String?> storedIn = const Value.absent(),
    Value<String?> improvements = const Value.absent(),
    Value<int?> specialMaterialIndex = const Value.absent(),
    Value<double?> price = const Value.absent(),
    Value<String?> desc = const Value.absent(),
    double? ocupedSpace,
    int? typeIndex,
    int? createdAt,
    int? updatedAt,
  }) => GeneralItemTableData(
    uuid: uuid ?? this.uuid,
    name: name ?? this.name,
    parentUuid: parentUuid ?? this.parentUuid,
    storedIn: storedIn.present ? storedIn.value : this.storedIn,
    improvements: improvements.present ? improvements.value : this.improvements,
    specialMaterialIndex: specialMaterialIndex.present
        ? specialMaterialIndex.value
        : this.specialMaterialIndex,
    price: price.present ? price.value : this.price,
    desc: desc.present ? desc.value : this.desc,
    ocupedSpace: ocupedSpace ?? this.ocupedSpace,
    typeIndex: typeIndex ?? this.typeIndex,
    createdAt: createdAt ?? this.createdAt,
    updatedAt: updatedAt ?? this.updatedAt,
  );
  GeneralItemTableData copyWithCompanion(GeneralItemTableCompanion data) {
    return GeneralItemTableData(
      uuid: data.uuid.present ? data.uuid.value : this.uuid,
      name: data.name.present ? data.name.value : this.name,
      parentUuid: data.parentUuid.present
          ? data.parentUuid.value
          : this.parentUuid,
      storedIn: data.storedIn.present ? data.storedIn.value : this.storedIn,
      improvements: data.improvements.present
          ? data.improvements.value
          : this.improvements,
      specialMaterialIndex: data.specialMaterialIndex.present
          ? data.specialMaterialIndex.value
          : this.specialMaterialIndex,
      price: data.price.present ? data.price.value : this.price,
      desc: data.desc.present ? data.desc.value : this.desc,
      ocupedSpace: data.ocupedSpace.present
          ? data.ocupedSpace.value
          : this.ocupedSpace,
      typeIndex: data.typeIndex.present ? data.typeIndex.value : this.typeIndex,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('GeneralItemTableData(')
          ..write('uuid: $uuid, ')
          ..write('name: $name, ')
          ..write('parentUuid: $parentUuid, ')
          ..write('storedIn: $storedIn, ')
          ..write('improvements: $improvements, ')
          ..write('specialMaterialIndex: $specialMaterialIndex, ')
          ..write('price: $price, ')
          ..write('desc: $desc, ')
          ..write('ocupedSpace: $ocupedSpace, ')
          ..write('typeIndex: $typeIndex, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    uuid,
    name,
    parentUuid,
    storedIn,
    improvements,
    specialMaterialIndex,
    price,
    desc,
    ocupedSpace,
    typeIndex,
    createdAt,
    updatedAt,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is GeneralItemTableData &&
          other.uuid == this.uuid &&
          other.name == this.name &&
          other.parentUuid == this.parentUuid &&
          other.storedIn == this.storedIn &&
          other.improvements == this.improvements &&
          other.specialMaterialIndex == this.specialMaterialIndex &&
          other.price == this.price &&
          other.desc == this.desc &&
          other.ocupedSpace == this.ocupedSpace &&
          other.typeIndex == this.typeIndex &&
          other.createdAt == this.createdAt &&
          other.updatedAt == this.updatedAt);
}

class GeneralItemTableCompanion extends UpdateCompanion<GeneralItemTableData> {
  final Value<String> uuid;
  final Value<String> name;
  final Value<String> parentUuid;
  final Value<String?> storedIn;
  final Value<String?> improvements;
  final Value<int?> specialMaterialIndex;
  final Value<double?> price;
  final Value<String?> desc;
  final Value<double> ocupedSpace;
  final Value<int> typeIndex;
  final Value<int> createdAt;
  final Value<int> updatedAt;
  final Value<int> rowid;
  const GeneralItemTableCompanion({
    this.uuid = const Value.absent(),
    this.name = const Value.absent(),
    this.parentUuid = const Value.absent(),
    this.storedIn = const Value.absent(),
    this.improvements = const Value.absent(),
    this.specialMaterialIndex = const Value.absent(),
    this.price = const Value.absent(),
    this.desc = const Value.absent(),
    this.ocupedSpace = const Value.absent(),
    this.typeIndex = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  GeneralItemTableCompanion.insert({
    required String uuid,
    required String name,
    required String parentUuid,
    this.storedIn = const Value.absent(),
    this.improvements = const Value.absent(),
    this.specialMaterialIndex = const Value.absent(),
    this.price = const Value.absent(),
    this.desc = const Value.absent(),
    required double ocupedSpace,
    required int typeIndex,
    required int createdAt,
    required int updatedAt,
    this.rowid = const Value.absent(),
  }) : uuid = Value(uuid),
       name = Value(name),
       parentUuid = Value(parentUuid),
       ocupedSpace = Value(ocupedSpace),
       typeIndex = Value(typeIndex),
       createdAt = Value(createdAt),
       updatedAt = Value(updatedAt);
  static Insertable<GeneralItemTableData> custom({
    Expression<String>? uuid,
    Expression<String>? name,
    Expression<String>? parentUuid,
    Expression<String>? storedIn,
    Expression<String>? improvements,
    Expression<int>? specialMaterialIndex,
    Expression<double>? price,
    Expression<String>? desc,
    Expression<double>? ocupedSpace,
    Expression<int>? typeIndex,
    Expression<int>? createdAt,
    Expression<int>? updatedAt,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (uuid != null) 'uuid': uuid,
      if (name != null) 'name': name,
      if (parentUuid != null) 'parent_uuid': parentUuid,
      if (storedIn != null) 'stored_in': storedIn,
      if (improvements != null) 'improvements': improvements,
      if (specialMaterialIndex != null)
        'special_material_index': specialMaterialIndex,
      if (price != null) 'price': price,
      if (desc != null) 'desc': desc,
      if (ocupedSpace != null) 'ocuped_space': ocupedSpace,
      if (typeIndex != null) 'type_index': typeIndex,
      if (createdAt != null) 'created_at': createdAt,
      if (updatedAt != null) 'updated_at': updatedAt,
      if (rowid != null) 'rowid': rowid,
    });
  }

  GeneralItemTableCompanion copyWith({
    Value<String>? uuid,
    Value<String>? name,
    Value<String>? parentUuid,
    Value<String?>? storedIn,
    Value<String?>? improvements,
    Value<int?>? specialMaterialIndex,
    Value<double?>? price,
    Value<String?>? desc,
    Value<double>? ocupedSpace,
    Value<int>? typeIndex,
    Value<int>? createdAt,
    Value<int>? updatedAt,
    Value<int>? rowid,
  }) {
    return GeneralItemTableCompanion(
      uuid: uuid ?? this.uuid,
      name: name ?? this.name,
      parentUuid: parentUuid ?? this.parentUuid,
      storedIn: storedIn ?? this.storedIn,
      improvements: improvements ?? this.improvements,
      specialMaterialIndex: specialMaterialIndex ?? this.specialMaterialIndex,
      price: price ?? this.price,
      desc: desc ?? this.desc,
      ocupedSpace: ocupedSpace ?? this.ocupedSpace,
      typeIndex: typeIndex ?? this.typeIndex,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (uuid.present) {
      map['uuid'] = Variable<String>(uuid.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    if (parentUuid.present) {
      map['parent_uuid'] = Variable<String>(parentUuid.value);
    }
    if (storedIn.present) {
      map['stored_in'] = Variable<String>(storedIn.value);
    }
    if (improvements.present) {
      map['improvements'] = Variable<String>(improvements.value);
    }
    if (specialMaterialIndex.present) {
      map['special_material_index'] = Variable<int>(specialMaterialIndex.value);
    }
    if (price.present) {
      map['price'] = Variable<double>(price.value);
    }
    if (desc.present) {
      map['desc'] = Variable<String>(desc.value);
    }
    if (ocupedSpace.present) {
      map['ocuped_space'] = Variable<double>(ocupedSpace.value);
    }
    if (typeIndex.present) {
      map['type_index'] = Variable<int>(typeIndex.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<int>(createdAt.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<int>(updatedAt.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('GeneralItemTableCompanion(')
          ..write('uuid: $uuid, ')
          ..write('name: $name, ')
          ..write('parentUuid: $parentUuid, ')
          ..write('storedIn: $storedIn, ')
          ..write('improvements: $improvements, ')
          ..write('specialMaterialIndex: $specialMaterialIndex, ')
          ..write('price: $price, ')
          ..write('desc: $desc, ')
          ..write('ocupedSpace: $ocupedSpace, ')
          ..write('typeIndex: $typeIndex, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $GeneralSkillTableTable extends GeneralSkillTable
    with TableInfo<$GeneralSkillTableTable, GeneralSkillTableData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $GeneralSkillTableTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _uuidMeta = const VerificationMeta('uuid');
  @override
  late final GeneratedColumn<String> uuid = GeneratedColumn<String>(
    'uuid',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
    'name',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _descMeta = const VerificationMeta('desc');
  @override
  late final GeneratedColumn<String> desc = GeneratedColumn<String>(
    'desc',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _parentUuidMeta = const VerificationMeta(
    'parentUuid',
  );
  @override
  late final GeneratedColumn<String> parentUuid = GeneratedColumn<String>(
    'parent_uuid',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<int> createdAt = GeneratedColumn<int>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _updatedAtMeta = const VerificationMeta(
    'updatedAt',
  );
  @override
  late final GeneratedColumn<int> updatedAt = GeneratedColumn<int>(
    'updated_at',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  @override
  List<GeneratedColumn> get $columns => [
    uuid,
    name,
    desc,
    parentUuid,
    createdAt,
    updatedAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'general_skill_table';
  @override
  VerificationContext validateIntegrity(
    Insertable<GeneralSkillTableData> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('uuid')) {
      context.handle(
        _uuidMeta,
        uuid.isAcceptableOrUnknown(data['uuid']!, _uuidMeta),
      );
    } else if (isInserting) {
      context.missing(_uuidMeta);
    }
    if (data.containsKey('name')) {
      context.handle(
        _nameMeta,
        name.isAcceptableOrUnknown(data['name']!, _nameMeta),
      );
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    if (data.containsKey('desc')) {
      context.handle(
        _descMeta,
        desc.isAcceptableOrUnknown(data['desc']!, _descMeta),
      );
    } else if (isInserting) {
      context.missing(_descMeta);
    }
    if (data.containsKey('parent_uuid')) {
      context.handle(
        _parentUuidMeta,
        parentUuid.isAcceptableOrUnknown(data['parent_uuid']!, _parentUuidMeta),
      );
    } else if (isInserting) {
      context.missing(_parentUuidMeta);
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    } else if (isInserting) {
      context.missing(_createdAtMeta);
    }
    if (data.containsKey('updated_at')) {
      context.handle(
        _updatedAtMeta,
        updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta),
      );
    } else if (isInserting) {
      context.missing(_updatedAtMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {uuid};
  @override
  GeneralSkillTableData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return GeneralSkillTableData(
      uuid: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}uuid'],
      )!,
      name: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}name'],
      )!,
      desc: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}desc'],
      )!,
      parentUuid: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}parent_uuid'],
      )!,
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}created_at'],
      )!,
      updatedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}updated_at'],
      )!,
    );
  }

  @override
  $GeneralSkillTableTable createAlias(String alias) {
    return $GeneralSkillTableTable(attachedDatabase, alias);
  }
}

class GeneralSkillTableData extends DataClass
    implements Insertable<GeneralSkillTableData> {
  final String uuid;
  final String name;
  final String desc;
  final String parentUuid;
  final int createdAt;
  final int updatedAt;
  const GeneralSkillTableData({
    required this.uuid,
    required this.name,
    required this.desc,
    required this.parentUuid,
    required this.createdAt,
    required this.updatedAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['uuid'] = Variable<String>(uuid);
    map['name'] = Variable<String>(name);
    map['desc'] = Variable<String>(desc);
    map['parent_uuid'] = Variable<String>(parentUuid);
    map['created_at'] = Variable<int>(createdAt);
    map['updated_at'] = Variable<int>(updatedAt);
    return map;
  }

  GeneralSkillTableCompanion toCompanion(bool nullToAbsent) {
    return GeneralSkillTableCompanion(
      uuid: Value(uuid),
      name: Value(name),
      desc: Value(desc),
      parentUuid: Value(parentUuid),
      createdAt: Value(createdAt),
      updatedAt: Value(updatedAt),
    );
  }

  factory GeneralSkillTableData.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return GeneralSkillTableData(
      uuid: serializer.fromJson<String>(json['uuid']),
      name: serializer.fromJson<String>(json['name']),
      desc: serializer.fromJson<String>(json['desc']),
      parentUuid: serializer.fromJson<String>(json['parentUuid']),
      createdAt: serializer.fromJson<int>(json['createdAt']),
      updatedAt: serializer.fromJson<int>(json['updatedAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'uuid': serializer.toJson<String>(uuid),
      'name': serializer.toJson<String>(name),
      'desc': serializer.toJson<String>(desc),
      'parentUuid': serializer.toJson<String>(parentUuid),
      'createdAt': serializer.toJson<int>(createdAt),
      'updatedAt': serializer.toJson<int>(updatedAt),
    };
  }

  GeneralSkillTableData copyWith({
    String? uuid,
    String? name,
    String? desc,
    String? parentUuid,
    int? createdAt,
    int? updatedAt,
  }) => GeneralSkillTableData(
    uuid: uuid ?? this.uuid,
    name: name ?? this.name,
    desc: desc ?? this.desc,
    parentUuid: parentUuid ?? this.parentUuid,
    createdAt: createdAt ?? this.createdAt,
    updatedAt: updatedAt ?? this.updatedAt,
  );
  GeneralSkillTableData copyWithCompanion(GeneralSkillTableCompanion data) {
    return GeneralSkillTableData(
      uuid: data.uuid.present ? data.uuid.value : this.uuid,
      name: data.name.present ? data.name.value : this.name,
      desc: data.desc.present ? data.desc.value : this.desc,
      parentUuid: data.parentUuid.present
          ? data.parentUuid.value
          : this.parentUuid,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('GeneralSkillTableData(')
          ..write('uuid: $uuid, ')
          ..write('name: $name, ')
          ..write('desc: $desc, ')
          ..write('parentUuid: $parentUuid, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode =>
      Object.hash(uuid, name, desc, parentUuid, createdAt, updatedAt);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is GeneralSkillTableData &&
          other.uuid == this.uuid &&
          other.name == this.name &&
          other.desc == this.desc &&
          other.parentUuid == this.parentUuid &&
          other.createdAt == this.createdAt &&
          other.updatedAt == this.updatedAt);
}

class GeneralSkillTableCompanion
    extends UpdateCompanion<GeneralSkillTableData> {
  final Value<String> uuid;
  final Value<String> name;
  final Value<String> desc;
  final Value<String> parentUuid;
  final Value<int> createdAt;
  final Value<int> updatedAt;
  final Value<int> rowid;
  const GeneralSkillTableCompanion({
    this.uuid = const Value.absent(),
    this.name = const Value.absent(),
    this.desc = const Value.absent(),
    this.parentUuid = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  GeneralSkillTableCompanion.insert({
    required String uuid,
    required String name,
    required String desc,
    required String parentUuid,
    required int createdAt,
    required int updatedAt,
    this.rowid = const Value.absent(),
  }) : uuid = Value(uuid),
       name = Value(name),
       desc = Value(desc),
       parentUuid = Value(parentUuid),
       createdAt = Value(createdAt),
       updatedAt = Value(updatedAt);
  static Insertable<GeneralSkillTableData> custom({
    Expression<String>? uuid,
    Expression<String>? name,
    Expression<String>? desc,
    Expression<String>? parentUuid,
    Expression<int>? createdAt,
    Expression<int>? updatedAt,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (uuid != null) 'uuid': uuid,
      if (name != null) 'name': name,
      if (desc != null) 'desc': desc,
      if (parentUuid != null) 'parent_uuid': parentUuid,
      if (createdAt != null) 'created_at': createdAt,
      if (updatedAt != null) 'updated_at': updatedAt,
      if (rowid != null) 'rowid': rowid,
    });
  }

  GeneralSkillTableCompanion copyWith({
    Value<String>? uuid,
    Value<String>? name,
    Value<String>? desc,
    Value<String>? parentUuid,
    Value<int>? createdAt,
    Value<int>? updatedAt,
    Value<int>? rowid,
  }) {
    return GeneralSkillTableCompanion(
      uuid: uuid ?? this.uuid,
      name: name ?? this.name,
      desc: desc ?? this.desc,
      parentUuid: parentUuid ?? this.parentUuid,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (uuid.present) {
      map['uuid'] = Variable<String>(uuid.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    if (desc.present) {
      map['desc'] = Variable<String>(desc.value);
    }
    if (parentUuid.present) {
      map['parent_uuid'] = Variable<String>(parentUuid.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<int>(createdAt.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<int>(updatedAt.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('GeneralSkillTableCompanion(')
          ..write('uuid: $uuid, ')
          ..write('name: $name, ')
          ..write('desc: $desc, ')
          ..write('parentUuid: $parentUuid, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $MagicMenaceTableTable extends MagicMenaceTable
    with TableInfo<$MagicMenaceTableTable, MagicMenaceTableData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $MagicMenaceTableTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _uuidMeta = const VerificationMeta('uuid');
  @override
  late final GeneratedColumn<String> uuid = GeneratedColumn<String>(
    'uuid',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
    'name',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _resumedDescMeta = const VerificationMeta(
    'resumedDesc',
  );
  @override
  late final GeneratedColumn<String> resumedDesc = GeneratedColumn<String>(
    'resumed_desc',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _menaceUuidMeta = const VerificationMeta(
    'menaceUuid',
  );
  @override
  late final GeneratedColumn<String> menaceUuid = GeneratedColumn<String>(
    'menace_uuid',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _magicBaseIdMeta = const VerificationMeta(
    'magicBaseId',
  );
  @override
  late final GeneratedColumn<int> magicBaseId = GeneratedColumn<int>(
    'magic_base_id',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _pmMeta = const VerificationMeta('pm');
  @override
  late final GeneratedColumn<int> pm = GeneratedColumn<int>(
    'pm',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _cdMeta = const VerificationMeta('cd');
  @override
  late final GeneratedColumn<int> cd = GeneratedColumn<int>(
    'cd',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _mediumDamageValueMeta = const VerificationMeta(
    'mediumDamageValue',
  );
  @override
  late final GeneratedColumn<int> mediumDamageValue = GeneratedColumn<int>(
    'medium_damage_value',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _damageDicesMeta = const VerificationMeta(
    'damageDices',
  );
  @override
  late final GeneratedColumn<String> damageDices = GeneratedColumn<String>(
    'damage_dices',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _extraDamageDicesMeta = const VerificationMeta(
    'extraDamageDices',
  );
  @override
  late final GeneratedColumn<String> extraDamageDices = GeneratedColumn<String>(
    'extra_damage_dices',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  @override
  List<GeneratedColumn> get $columns => [
    uuid,
    name,
    resumedDesc,
    menaceUuid,
    magicBaseId,
    pm,
    cd,
    mediumDamageValue,
    damageDices,
    extraDamageDices,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'magic_menace_table';
  @override
  VerificationContext validateIntegrity(
    Insertable<MagicMenaceTableData> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('uuid')) {
      context.handle(
        _uuidMeta,
        uuid.isAcceptableOrUnknown(data['uuid']!, _uuidMeta),
      );
    } else if (isInserting) {
      context.missing(_uuidMeta);
    }
    if (data.containsKey('name')) {
      context.handle(
        _nameMeta,
        name.isAcceptableOrUnknown(data['name']!, _nameMeta),
      );
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    if (data.containsKey('resumed_desc')) {
      context.handle(
        _resumedDescMeta,
        resumedDesc.isAcceptableOrUnknown(
          data['resumed_desc']!,
          _resumedDescMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_resumedDescMeta);
    }
    if (data.containsKey('menace_uuid')) {
      context.handle(
        _menaceUuidMeta,
        menaceUuid.isAcceptableOrUnknown(data['menace_uuid']!, _menaceUuidMeta),
      );
    } else if (isInserting) {
      context.missing(_menaceUuidMeta);
    }
    if (data.containsKey('magic_base_id')) {
      context.handle(
        _magicBaseIdMeta,
        magicBaseId.isAcceptableOrUnknown(
          data['magic_base_id']!,
          _magicBaseIdMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_magicBaseIdMeta);
    }
    if (data.containsKey('pm')) {
      context.handle(_pmMeta, pm.isAcceptableOrUnknown(data['pm']!, _pmMeta));
    }
    if (data.containsKey('cd')) {
      context.handle(_cdMeta, cd.isAcceptableOrUnknown(data['cd']!, _cdMeta));
    }
    if (data.containsKey('medium_damage_value')) {
      context.handle(
        _mediumDamageValueMeta,
        mediumDamageValue.isAcceptableOrUnknown(
          data['medium_damage_value']!,
          _mediumDamageValueMeta,
        ),
      );
    }
    if (data.containsKey('damage_dices')) {
      context.handle(
        _damageDicesMeta,
        damageDices.isAcceptableOrUnknown(
          data['damage_dices']!,
          _damageDicesMeta,
        ),
      );
    }
    if (data.containsKey('extra_damage_dices')) {
      context.handle(
        _extraDamageDicesMeta,
        extraDamageDices.isAcceptableOrUnknown(
          data['extra_damage_dices']!,
          _extraDamageDicesMeta,
        ),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {uuid};
  @override
  MagicMenaceTableData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return MagicMenaceTableData(
      uuid: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}uuid'],
      )!,
      name: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}name'],
      )!,
      resumedDesc: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}resumed_desc'],
      )!,
      menaceUuid: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}menace_uuid'],
      )!,
      magicBaseId: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}magic_base_id'],
      )!,
      pm: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}pm'],
      ),
      cd: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}cd'],
      ),
      mediumDamageValue: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}medium_damage_value'],
      ),
      damageDices: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}damage_dices'],
      ),
      extraDamageDices: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}extra_damage_dices'],
      ),
    );
  }

  @override
  $MagicMenaceTableTable createAlias(String alias) {
    return $MagicMenaceTableTable(attachedDatabase, alias);
  }
}

class MagicMenaceTableData extends DataClass
    implements Insertable<MagicMenaceTableData> {
  final String uuid;
  final String name;
  final String resumedDesc;
  final String menaceUuid;
  final int magicBaseId;
  final int? pm;
  final int? cd;
  final int? mediumDamageValue;
  final String? damageDices;
  final String? extraDamageDices;
  const MagicMenaceTableData({
    required this.uuid,
    required this.name,
    required this.resumedDesc,
    required this.menaceUuid,
    required this.magicBaseId,
    this.pm,
    this.cd,
    this.mediumDamageValue,
    this.damageDices,
    this.extraDamageDices,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['uuid'] = Variable<String>(uuid);
    map['name'] = Variable<String>(name);
    map['resumed_desc'] = Variable<String>(resumedDesc);
    map['menace_uuid'] = Variable<String>(menaceUuid);
    map['magic_base_id'] = Variable<int>(magicBaseId);
    if (!nullToAbsent || pm != null) {
      map['pm'] = Variable<int>(pm);
    }
    if (!nullToAbsent || cd != null) {
      map['cd'] = Variable<int>(cd);
    }
    if (!nullToAbsent || mediumDamageValue != null) {
      map['medium_damage_value'] = Variable<int>(mediumDamageValue);
    }
    if (!nullToAbsent || damageDices != null) {
      map['damage_dices'] = Variable<String>(damageDices);
    }
    if (!nullToAbsent || extraDamageDices != null) {
      map['extra_damage_dices'] = Variable<String>(extraDamageDices);
    }
    return map;
  }

  MagicMenaceTableCompanion toCompanion(bool nullToAbsent) {
    return MagicMenaceTableCompanion(
      uuid: Value(uuid),
      name: Value(name),
      resumedDesc: Value(resumedDesc),
      menaceUuid: Value(menaceUuid),
      magicBaseId: Value(magicBaseId),
      pm: pm == null && nullToAbsent ? const Value.absent() : Value(pm),
      cd: cd == null && nullToAbsent ? const Value.absent() : Value(cd),
      mediumDamageValue: mediumDamageValue == null && nullToAbsent
          ? const Value.absent()
          : Value(mediumDamageValue),
      damageDices: damageDices == null && nullToAbsent
          ? const Value.absent()
          : Value(damageDices),
      extraDamageDices: extraDamageDices == null && nullToAbsent
          ? const Value.absent()
          : Value(extraDamageDices),
    );
  }

  factory MagicMenaceTableData.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return MagicMenaceTableData(
      uuid: serializer.fromJson<String>(json['uuid']),
      name: serializer.fromJson<String>(json['name']),
      resumedDesc: serializer.fromJson<String>(json['resumedDesc']),
      menaceUuid: serializer.fromJson<String>(json['menaceUuid']),
      magicBaseId: serializer.fromJson<int>(json['magicBaseId']),
      pm: serializer.fromJson<int?>(json['pm']),
      cd: serializer.fromJson<int?>(json['cd']),
      mediumDamageValue: serializer.fromJson<int?>(json['mediumDamageValue']),
      damageDices: serializer.fromJson<String?>(json['damageDices']),
      extraDamageDices: serializer.fromJson<String?>(json['extraDamageDices']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'uuid': serializer.toJson<String>(uuid),
      'name': serializer.toJson<String>(name),
      'resumedDesc': serializer.toJson<String>(resumedDesc),
      'menaceUuid': serializer.toJson<String>(menaceUuid),
      'magicBaseId': serializer.toJson<int>(magicBaseId),
      'pm': serializer.toJson<int?>(pm),
      'cd': serializer.toJson<int?>(cd),
      'mediumDamageValue': serializer.toJson<int?>(mediumDamageValue),
      'damageDices': serializer.toJson<String?>(damageDices),
      'extraDamageDices': serializer.toJson<String?>(extraDamageDices),
    };
  }

  MagicMenaceTableData copyWith({
    String? uuid,
    String? name,
    String? resumedDesc,
    String? menaceUuid,
    int? magicBaseId,
    Value<int?> pm = const Value.absent(),
    Value<int?> cd = const Value.absent(),
    Value<int?> mediumDamageValue = const Value.absent(),
    Value<String?> damageDices = const Value.absent(),
    Value<String?> extraDamageDices = const Value.absent(),
  }) => MagicMenaceTableData(
    uuid: uuid ?? this.uuid,
    name: name ?? this.name,
    resumedDesc: resumedDesc ?? this.resumedDesc,
    menaceUuid: menaceUuid ?? this.menaceUuid,
    magicBaseId: magicBaseId ?? this.magicBaseId,
    pm: pm.present ? pm.value : this.pm,
    cd: cd.present ? cd.value : this.cd,
    mediumDamageValue: mediumDamageValue.present
        ? mediumDamageValue.value
        : this.mediumDamageValue,
    damageDices: damageDices.present ? damageDices.value : this.damageDices,
    extraDamageDices: extraDamageDices.present
        ? extraDamageDices.value
        : this.extraDamageDices,
  );
  MagicMenaceTableData copyWithCompanion(MagicMenaceTableCompanion data) {
    return MagicMenaceTableData(
      uuid: data.uuid.present ? data.uuid.value : this.uuid,
      name: data.name.present ? data.name.value : this.name,
      resumedDesc: data.resumedDesc.present
          ? data.resumedDesc.value
          : this.resumedDesc,
      menaceUuid: data.menaceUuid.present
          ? data.menaceUuid.value
          : this.menaceUuid,
      magicBaseId: data.magicBaseId.present
          ? data.magicBaseId.value
          : this.magicBaseId,
      pm: data.pm.present ? data.pm.value : this.pm,
      cd: data.cd.present ? data.cd.value : this.cd,
      mediumDamageValue: data.mediumDamageValue.present
          ? data.mediumDamageValue.value
          : this.mediumDamageValue,
      damageDices: data.damageDices.present
          ? data.damageDices.value
          : this.damageDices,
      extraDamageDices: data.extraDamageDices.present
          ? data.extraDamageDices.value
          : this.extraDamageDices,
    );
  }

  @override
  String toString() {
    return (StringBuffer('MagicMenaceTableData(')
          ..write('uuid: $uuid, ')
          ..write('name: $name, ')
          ..write('resumedDesc: $resumedDesc, ')
          ..write('menaceUuid: $menaceUuid, ')
          ..write('magicBaseId: $magicBaseId, ')
          ..write('pm: $pm, ')
          ..write('cd: $cd, ')
          ..write('mediumDamageValue: $mediumDamageValue, ')
          ..write('damageDices: $damageDices, ')
          ..write('extraDamageDices: $extraDamageDices')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    uuid,
    name,
    resumedDesc,
    menaceUuid,
    magicBaseId,
    pm,
    cd,
    mediumDamageValue,
    damageDices,
    extraDamageDices,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is MagicMenaceTableData &&
          other.uuid == this.uuid &&
          other.name == this.name &&
          other.resumedDesc == this.resumedDesc &&
          other.menaceUuid == this.menaceUuid &&
          other.magicBaseId == this.magicBaseId &&
          other.pm == this.pm &&
          other.cd == this.cd &&
          other.mediumDamageValue == this.mediumDamageValue &&
          other.damageDices == this.damageDices &&
          other.extraDamageDices == this.extraDamageDices);
}

class MagicMenaceTableCompanion extends UpdateCompanion<MagicMenaceTableData> {
  final Value<String> uuid;
  final Value<String> name;
  final Value<String> resumedDesc;
  final Value<String> menaceUuid;
  final Value<int> magicBaseId;
  final Value<int?> pm;
  final Value<int?> cd;
  final Value<int?> mediumDamageValue;
  final Value<String?> damageDices;
  final Value<String?> extraDamageDices;
  final Value<int> rowid;
  const MagicMenaceTableCompanion({
    this.uuid = const Value.absent(),
    this.name = const Value.absent(),
    this.resumedDesc = const Value.absent(),
    this.menaceUuid = const Value.absent(),
    this.magicBaseId = const Value.absent(),
    this.pm = const Value.absent(),
    this.cd = const Value.absent(),
    this.mediumDamageValue = const Value.absent(),
    this.damageDices = const Value.absent(),
    this.extraDamageDices = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  MagicMenaceTableCompanion.insert({
    required String uuid,
    required String name,
    required String resumedDesc,
    required String menaceUuid,
    required int magicBaseId,
    this.pm = const Value.absent(),
    this.cd = const Value.absent(),
    this.mediumDamageValue = const Value.absent(),
    this.damageDices = const Value.absent(),
    this.extraDamageDices = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : uuid = Value(uuid),
       name = Value(name),
       resumedDesc = Value(resumedDesc),
       menaceUuid = Value(menaceUuid),
       magicBaseId = Value(magicBaseId);
  static Insertable<MagicMenaceTableData> custom({
    Expression<String>? uuid,
    Expression<String>? name,
    Expression<String>? resumedDesc,
    Expression<String>? menaceUuid,
    Expression<int>? magicBaseId,
    Expression<int>? pm,
    Expression<int>? cd,
    Expression<int>? mediumDamageValue,
    Expression<String>? damageDices,
    Expression<String>? extraDamageDices,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (uuid != null) 'uuid': uuid,
      if (name != null) 'name': name,
      if (resumedDesc != null) 'resumed_desc': resumedDesc,
      if (menaceUuid != null) 'menace_uuid': menaceUuid,
      if (magicBaseId != null) 'magic_base_id': magicBaseId,
      if (pm != null) 'pm': pm,
      if (cd != null) 'cd': cd,
      if (mediumDamageValue != null) 'medium_damage_value': mediumDamageValue,
      if (damageDices != null) 'damage_dices': damageDices,
      if (extraDamageDices != null) 'extra_damage_dices': extraDamageDices,
      if (rowid != null) 'rowid': rowid,
    });
  }

  MagicMenaceTableCompanion copyWith({
    Value<String>? uuid,
    Value<String>? name,
    Value<String>? resumedDesc,
    Value<String>? menaceUuid,
    Value<int>? magicBaseId,
    Value<int?>? pm,
    Value<int?>? cd,
    Value<int?>? mediumDamageValue,
    Value<String?>? damageDices,
    Value<String?>? extraDamageDices,
    Value<int>? rowid,
  }) {
    return MagicMenaceTableCompanion(
      uuid: uuid ?? this.uuid,
      name: name ?? this.name,
      resumedDesc: resumedDesc ?? this.resumedDesc,
      menaceUuid: menaceUuid ?? this.menaceUuid,
      magicBaseId: magicBaseId ?? this.magicBaseId,
      pm: pm ?? this.pm,
      cd: cd ?? this.cd,
      mediumDamageValue: mediumDamageValue ?? this.mediumDamageValue,
      damageDices: damageDices ?? this.damageDices,
      extraDamageDices: extraDamageDices ?? this.extraDamageDices,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (uuid.present) {
      map['uuid'] = Variable<String>(uuid.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    if (resumedDesc.present) {
      map['resumed_desc'] = Variable<String>(resumedDesc.value);
    }
    if (menaceUuid.present) {
      map['menace_uuid'] = Variable<String>(menaceUuid.value);
    }
    if (magicBaseId.present) {
      map['magic_base_id'] = Variable<int>(magicBaseId.value);
    }
    if (pm.present) {
      map['pm'] = Variable<int>(pm.value);
    }
    if (cd.present) {
      map['cd'] = Variable<int>(cd.value);
    }
    if (mediumDamageValue.present) {
      map['medium_damage_value'] = Variable<int>(mediumDamageValue.value);
    }
    if (damageDices.present) {
      map['damage_dices'] = Variable<String>(damageDices.value);
    }
    if (extraDamageDices.present) {
      map['extra_damage_dices'] = Variable<String>(extraDamageDices.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('MagicMenaceTableCompanion(')
          ..write('uuid: $uuid, ')
          ..write('name: $name, ')
          ..write('resumedDesc: $resumedDesc, ')
          ..write('menaceUuid: $menaceUuid, ')
          ..write('magicBaseId: $magicBaseId, ')
          ..write('pm: $pm, ')
          ..write('cd: $cd, ')
          ..write('mediumDamageValue: $mediumDamageValue, ')
          ..write('damageDices: $damageDices, ')
          ..write('extraDamageDices: $extraDamageDices, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $SaddlebagTableTable extends SaddlebagTable
    with TableInfo<$SaddlebagTableTable, SaddlebagTableData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $SaddlebagTableTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _uuidMeta = const VerificationMeta('uuid');
  @override
  late final GeneratedColumn<String> uuid = GeneratedColumn<String>(
    'uuid',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
    'name',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _parentUuidMeta = const VerificationMeta(
    'parentUuid',
  );
  @override
  late final GeneratedColumn<String> parentUuid = GeneratedColumn<String>(
    'parent_uuid',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _priceMeta = const VerificationMeta('price');
  @override
  late final GeneratedColumn<double> price = GeneratedColumn<double>(
    'price',
    aliasedName,
    true,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<int> createdAt = GeneratedColumn<int>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _updatedAtMeta = const VerificationMeta(
    'updatedAt',
  );
  @override
  late final GeneratedColumn<int> updatedAt = GeneratedColumn<int>(
    'updated_at',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  @override
  List<GeneratedColumn> get $columns => [
    uuid,
    name,
    parentUuid,
    price,
    createdAt,
    updatedAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'saddlebag_table';
  @override
  VerificationContext validateIntegrity(
    Insertable<SaddlebagTableData> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('uuid')) {
      context.handle(
        _uuidMeta,
        uuid.isAcceptableOrUnknown(data['uuid']!, _uuidMeta),
      );
    } else if (isInserting) {
      context.missing(_uuidMeta);
    }
    if (data.containsKey('name')) {
      context.handle(
        _nameMeta,
        name.isAcceptableOrUnknown(data['name']!, _nameMeta),
      );
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    if (data.containsKey('parent_uuid')) {
      context.handle(
        _parentUuidMeta,
        parentUuid.isAcceptableOrUnknown(data['parent_uuid']!, _parentUuidMeta),
      );
    } else if (isInserting) {
      context.missing(_parentUuidMeta);
    }
    if (data.containsKey('price')) {
      context.handle(
        _priceMeta,
        price.isAcceptableOrUnknown(data['price']!, _priceMeta),
      );
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    } else if (isInserting) {
      context.missing(_createdAtMeta);
    }
    if (data.containsKey('updated_at')) {
      context.handle(
        _updatedAtMeta,
        updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta),
      );
    } else if (isInserting) {
      context.missing(_updatedAtMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {uuid};
  @override
  SaddlebagTableData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return SaddlebagTableData(
      uuid: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}uuid'],
      )!,
      name: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}name'],
      )!,
      parentUuid: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}parent_uuid'],
      )!,
      price: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}price'],
      ),
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}created_at'],
      )!,
      updatedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}updated_at'],
      )!,
    );
  }

  @override
  $SaddlebagTableTable createAlias(String alias) {
    return $SaddlebagTableTable(attachedDatabase, alias);
  }
}

class SaddlebagTableData extends DataClass
    implements Insertable<SaddlebagTableData> {
  final String uuid;
  final String name;
  final String parentUuid;
  final double? price;
  final int createdAt;
  final int updatedAt;
  const SaddlebagTableData({
    required this.uuid,
    required this.name,
    required this.parentUuid,
    this.price,
    required this.createdAt,
    required this.updatedAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['uuid'] = Variable<String>(uuid);
    map['name'] = Variable<String>(name);
    map['parent_uuid'] = Variable<String>(parentUuid);
    if (!nullToAbsent || price != null) {
      map['price'] = Variable<double>(price);
    }
    map['created_at'] = Variable<int>(createdAt);
    map['updated_at'] = Variable<int>(updatedAt);
    return map;
  }

  SaddlebagTableCompanion toCompanion(bool nullToAbsent) {
    return SaddlebagTableCompanion(
      uuid: Value(uuid),
      name: Value(name),
      parentUuid: Value(parentUuid),
      price: price == null && nullToAbsent
          ? const Value.absent()
          : Value(price),
      createdAt: Value(createdAt),
      updatedAt: Value(updatedAt),
    );
  }

  factory SaddlebagTableData.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return SaddlebagTableData(
      uuid: serializer.fromJson<String>(json['uuid']),
      name: serializer.fromJson<String>(json['name']),
      parentUuid: serializer.fromJson<String>(json['parentUuid']),
      price: serializer.fromJson<double?>(json['price']),
      createdAt: serializer.fromJson<int>(json['createdAt']),
      updatedAt: serializer.fromJson<int>(json['updatedAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'uuid': serializer.toJson<String>(uuid),
      'name': serializer.toJson<String>(name),
      'parentUuid': serializer.toJson<String>(parentUuid),
      'price': serializer.toJson<double?>(price),
      'createdAt': serializer.toJson<int>(createdAt),
      'updatedAt': serializer.toJson<int>(updatedAt),
    };
  }

  SaddlebagTableData copyWith({
    String? uuid,
    String? name,
    String? parentUuid,
    Value<double?> price = const Value.absent(),
    int? createdAt,
    int? updatedAt,
  }) => SaddlebagTableData(
    uuid: uuid ?? this.uuid,
    name: name ?? this.name,
    parentUuid: parentUuid ?? this.parentUuid,
    price: price.present ? price.value : this.price,
    createdAt: createdAt ?? this.createdAt,
    updatedAt: updatedAt ?? this.updatedAt,
  );
  SaddlebagTableData copyWithCompanion(SaddlebagTableCompanion data) {
    return SaddlebagTableData(
      uuid: data.uuid.present ? data.uuid.value : this.uuid,
      name: data.name.present ? data.name.value : this.name,
      parentUuid: data.parentUuid.present
          ? data.parentUuid.value
          : this.parentUuid,
      price: data.price.present ? data.price.value : this.price,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('SaddlebagTableData(')
          ..write('uuid: $uuid, ')
          ..write('name: $name, ')
          ..write('parentUuid: $parentUuid, ')
          ..write('price: $price, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode =>
      Object.hash(uuid, name, parentUuid, price, createdAt, updatedAt);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is SaddlebagTableData &&
          other.uuid == this.uuid &&
          other.name == this.name &&
          other.parentUuid == this.parentUuid &&
          other.price == this.price &&
          other.createdAt == this.createdAt &&
          other.updatedAt == this.updatedAt);
}

class SaddlebagTableCompanion extends UpdateCompanion<SaddlebagTableData> {
  final Value<String> uuid;
  final Value<String> name;
  final Value<String> parentUuid;
  final Value<double?> price;
  final Value<int> createdAt;
  final Value<int> updatedAt;
  final Value<int> rowid;
  const SaddlebagTableCompanion({
    this.uuid = const Value.absent(),
    this.name = const Value.absent(),
    this.parentUuid = const Value.absent(),
    this.price = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  SaddlebagTableCompanion.insert({
    required String uuid,
    required String name,
    required String parentUuid,
    this.price = const Value.absent(),
    required int createdAt,
    required int updatedAt,
    this.rowid = const Value.absent(),
  }) : uuid = Value(uuid),
       name = Value(name),
       parentUuid = Value(parentUuid),
       createdAt = Value(createdAt),
       updatedAt = Value(updatedAt);
  static Insertable<SaddlebagTableData> custom({
    Expression<String>? uuid,
    Expression<String>? name,
    Expression<String>? parentUuid,
    Expression<double>? price,
    Expression<int>? createdAt,
    Expression<int>? updatedAt,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (uuid != null) 'uuid': uuid,
      if (name != null) 'name': name,
      if (parentUuid != null) 'parent_uuid': parentUuid,
      if (price != null) 'price': price,
      if (createdAt != null) 'created_at': createdAt,
      if (updatedAt != null) 'updated_at': updatedAt,
      if (rowid != null) 'rowid': rowid,
    });
  }

  SaddlebagTableCompanion copyWith({
    Value<String>? uuid,
    Value<String>? name,
    Value<String>? parentUuid,
    Value<double?>? price,
    Value<int>? createdAt,
    Value<int>? updatedAt,
    Value<int>? rowid,
  }) {
    return SaddlebagTableCompanion(
      uuid: uuid ?? this.uuid,
      name: name ?? this.name,
      parentUuid: parentUuid ?? this.parentUuid,
      price: price ?? this.price,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (uuid.present) {
      map['uuid'] = Variable<String>(uuid.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    if (parentUuid.present) {
      map['parent_uuid'] = Variable<String>(parentUuid.value);
    }
    if (price.present) {
      map['price'] = Variable<double>(price.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<int>(createdAt.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<int>(updatedAt.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('SaddlebagTableCompanion(')
          ..write('uuid: $uuid, ')
          ..write('name: $name, ')
          ..write('parentUuid: $parentUuid, ')
          ..write('price: $price, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $ShieldTableTable extends ShieldTable
    with TableInfo<$ShieldTableTable, ShieldTableData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $ShieldTableTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _uuidMeta = const VerificationMeta('uuid');
  @override
  late final GeneratedColumn<String> uuid = GeneratedColumn<String>(
    'uuid',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
    'name',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _parentUuidMeta = const VerificationMeta(
    'parentUuid',
  );
  @override
  late final GeneratedColumn<String> parentUuid = GeneratedColumn<String>(
    'parent_uuid',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _storedInMeta = const VerificationMeta(
    'storedIn',
  );
  @override
  late final GeneratedColumn<String> storedIn = GeneratedColumn<String>(
    'stored_in',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _improvementsMeta = const VerificationMeta(
    'improvements',
  );
  @override
  late final GeneratedColumn<String> improvements = GeneratedColumn<String>(
    'improvements',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _specialMaterialIndexMeta =
      const VerificationMeta('specialMaterialIndex');
  @override
  late final GeneratedColumn<int> specialMaterialIndex = GeneratedColumn<int>(
    'special_material_index',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _priceMeta = const VerificationMeta('price');
  @override
  late final GeneratedColumn<double> price = GeneratedColumn<double>(
    'price',
    aliasedName,
    true,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _descMeta = const VerificationMeta('desc');
  @override
  late final GeneratedColumn<String> desc = GeneratedColumn<String>(
    'desc',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _ocupedSpaceMeta = const VerificationMeta(
    'ocupedSpace',
  );
  @override
  late final GeneratedColumn<double> ocupedSpace = GeneratedColumn<double>(
    'ocuped_space',
    aliasedName,
    false,
    type: DriftSqlType.double,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _typeIndexMeta = const VerificationMeta(
    'typeIndex',
  );
  @override
  late final GeneratedColumn<int> typeIndex = GeneratedColumn<int>(
    'type_index',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _defenseBonusMeta = const VerificationMeta(
    'defenseBonus',
  );
  @override
  late final GeneratedColumn<int> defenseBonus = GeneratedColumn<int>(
    'defense_bonus',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _penaltyMeta = const VerificationMeta(
    'penalty',
  );
  @override
  late final GeneratedColumn<int> penalty = GeneratedColumn<int>(
    'penalty',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _inUseMeta = const VerificationMeta('inUse');
  @override
  late final GeneratedColumn<bool> inUse = GeneratedColumn<bool>(
    'in_use',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("in_use" IN (0, 1))',
    ),
    defaultValue: const Constant(false),
  );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<int> createdAt = GeneratedColumn<int>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _updatedAtMeta = const VerificationMeta(
    'updatedAt',
  );
  @override
  late final GeneratedColumn<int> updatedAt = GeneratedColumn<int>(
    'updated_at',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  @override
  List<GeneratedColumn> get $columns => [
    uuid,
    name,
    parentUuid,
    storedIn,
    improvements,
    specialMaterialIndex,
    price,
    desc,
    ocupedSpace,
    typeIndex,
    defenseBonus,
    penalty,
    inUse,
    createdAt,
    updatedAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'shield_table';
  @override
  VerificationContext validateIntegrity(
    Insertable<ShieldTableData> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('uuid')) {
      context.handle(
        _uuidMeta,
        uuid.isAcceptableOrUnknown(data['uuid']!, _uuidMeta),
      );
    } else if (isInserting) {
      context.missing(_uuidMeta);
    }
    if (data.containsKey('name')) {
      context.handle(
        _nameMeta,
        name.isAcceptableOrUnknown(data['name']!, _nameMeta),
      );
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    if (data.containsKey('parent_uuid')) {
      context.handle(
        _parentUuidMeta,
        parentUuid.isAcceptableOrUnknown(data['parent_uuid']!, _parentUuidMeta),
      );
    } else if (isInserting) {
      context.missing(_parentUuidMeta);
    }
    if (data.containsKey('stored_in')) {
      context.handle(
        _storedInMeta,
        storedIn.isAcceptableOrUnknown(data['stored_in']!, _storedInMeta),
      );
    }
    if (data.containsKey('improvements')) {
      context.handle(
        _improvementsMeta,
        improvements.isAcceptableOrUnknown(
          data['improvements']!,
          _improvementsMeta,
        ),
      );
    }
    if (data.containsKey('special_material_index')) {
      context.handle(
        _specialMaterialIndexMeta,
        specialMaterialIndex.isAcceptableOrUnknown(
          data['special_material_index']!,
          _specialMaterialIndexMeta,
        ),
      );
    }
    if (data.containsKey('price')) {
      context.handle(
        _priceMeta,
        price.isAcceptableOrUnknown(data['price']!, _priceMeta),
      );
    }
    if (data.containsKey('desc')) {
      context.handle(
        _descMeta,
        desc.isAcceptableOrUnknown(data['desc']!, _descMeta),
      );
    }
    if (data.containsKey('ocuped_space')) {
      context.handle(
        _ocupedSpaceMeta,
        ocupedSpace.isAcceptableOrUnknown(
          data['ocuped_space']!,
          _ocupedSpaceMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_ocupedSpaceMeta);
    }
    if (data.containsKey('type_index')) {
      context.handle(
        _typeIndexMeta,
        typeIndex.isAcceptableOrUnknown(data['type_index']!, _typeIndexMeta),
      );
    } else if (isInserting) {
      context.missing(_typeIndexMeta);
    }
    if (data.containsKey('defense_bonus')) {
      context.handle(
        _defenseBonusMeta,
        defenseBonus.isAcceptableOrUnknown(
          data['defense_bonus']!,
          _defenseBonusMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_defenseBonusMeta);
    }
    if (data.containsKey('penalty')) {
      context.handle(
        _penaltyMeta,
        penalty.isAcceptableOrUnknown(data['penalty']!, _penaltyMeta),
      );
    } else if (isInserting) {
      context.missing(_penaltyMeta);
    }
    if (data.containsKey('in_use')) {
      context.handle(
        _inUseMeta,
        inUse.isAcceptableOrUnknown(data['in_use']!, _inUseMeta),
      );
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    } else if (isInserting) {
      context.missing(_createdAtMeta);
    }
    if (data.containsKey('updated_at')) {
      context.handle(
        _updatedAtMeta,
        updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta),
      );
    } else if (isInserting) {
      context.missing(_updatedAtMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {uuid};
  @override
  ShieldTableData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return ShieldTableData(
      uuid: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}uuid'],
      )!,
      name: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}name'],
      )!,
      parentUuid: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}parent_uuid'],
      )!,
      storedIn: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}stored_in'],
      ),
      improvements: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}improvements'],
      ),
      specialMaterialIndex: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}special_material_index'],
      ),
      price: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}price'],
      ),
      desc: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}desc'],
      ),
      ocupedSpace: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}ocuped_space'],
      )!,
      typeIndex: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}type_index'],
      )!,
      defenseBonus: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}defense_bonus'],
      )!,
      penalty: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}penalty'],
      )!,
      inUse: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}in_use'],
      )!,
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}created_at'],
      )!,
      updatedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}updated_at'],
      )!,
    );
  }

  @override
  $ShieldTableTable createAlias(String alias) {
    return $ShieldTableTable(attachedDatabase, alias);
  }
}

class ShieldTableData extends DataClass implements Insertable<ShieldTableData> {
  final String uuid;
  final String name;
  final String parentUuid;
  final String? storedIn;
  final String? improvements;
  final int? specialMaterialIndex;
  final double? price;
  final String? desc;
  final double ocupedSpace;
  final int typeIndex;
  final int defenseBonus;
  final int penalty;
  final bool inUse;
  final int createdAt;
  final int updatedAt;
  const ShieldTableData({
    required this.uuid,
    required this.name,
    required this.parentUuid,
    this.storedIn,
    this.improvements,
    this.specialMaterialIndex,
    this.price,
    this.desc,
    required this.ocupedSpace,
    required this.typeIndex,
    required this.defenseBonus,
    required this.penalty,
    required this.inUse,
    required this.createdAt,
    required this.updatedAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['uuid'] = Variable<String>(uuid);
    map['name'] = Variable<String>(name);
    map['parent_uuid'] = Variable<String>(parentUuid);
    if (!nullToAbsent || storedIn != null) {
      map['stored_in'] = Variable<String>(storedIn);
    }
    if (!nullToAbsent || improvements != null) {
      map['improvements'] = Variable<String>(improvements);
    }
    if (!nullToAbsent || specialMaterialIndex != null) {
      map['special_material_index'] = Variable<int>(specialMaterialIndex);
    }
    if (!nullToAbsent || price != null) {
      map['price'] = Variable<double>(price);
    }
    if (!nullToAbsent || desc != null) {
      map['desc'] = Variable<String>(desc);
    }
    map['ocuped_space'] = Variable<double>(ocupedSpace);
    map['type_index'] = Variable<int>(typeIndex);
    map['defense_bonus'] = Variable<int>(defenseBonus);
    map['penalty'] = Variable<int>(penalty);
    map['in_use'] = Variable<bool>(inUse);
    map['created_at'] = Variable<int>(createdAt);
    map['updated_at'] = Variable<int>(updatedAt);
    return map;
  }

  ShieldTableCompanion toCompanion(bool nullToAbsent) {
    return ShieldTableCompanion(
      uuid: Value(uuid),
      name: Value(name),
      parentUuid: Value(parentUuid),
      storedIn: storedIn == null && nullToAbsent
          ? const Value.absent()
          : Value(storedIn),
      improvements: improvements == null && nullToAbsent
          ? const Value.absent()
          : Value(improvements),
      specialMaterialIndex: specialMaterialIndex == null && nullToAbsent
          ? const Value.absent()
          : Value(specialMaterialIndex),
      price: price == null && nullToAbsent
          ? const Value.absent()
          : Value(price),
      desc: desc == null && nullToAbsent ? const Value.absent() : Value(desc),
      ocupedSpace: Value(ocupedSpace),
      typeIndex: Value(typeIndex),
      defenseBonus: Value(defenseBonus),
      penalty: Value(penalty),
      inUse: Value(inUse),
      createdAt: Value(createdAt),
      updatedAt: Value(updatedAt),
    );
  }

  factory ShieldTableData.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return ShieldTableData(
      uuid: serializer.fromJson<String>(json['uuid']),
      name: serializer.fromJson<String>(json['name']),
      parentUuid: serializer.fromJson<String>(json['parentUuid']),
      storedIn: serializer.fromJson<String?>(json['storedIn']),
      improvements: serializer.fromJson<String?>(json['improvements']),
      specialMaterialIndex: serializer.fromJson<int?>(
        json['specialMaterialIndex'],
      ),
      price: serializer.fromJson<double?>(json['price']),
      desc: serializer.fromJson<String?>(json['desc']),
      ocupedSpace: serializer.fromJson<double>(json['ocupedSpace']),
      typeIndex: serializer.fromJson<int>(json['typeIndex']),
      defenseBonus: serializer.fromJson<int>(json['defenseBonus']),
      penalty: serializer.fromJson<int>(json['penalty']),
      inUse: serializer.fromJson<bool>(json['inUse']),
      createdAt: serializer.fromJson<int>(json['createdAt']),
      updatedAt: serializer.fromJson<int>(json['updatedAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'uuid': serializer.toJson<String>(uuid),
      'name': serializer.toJson<String>(name),
      'parentUuid': serializer.toJson<String>(parentUuid),
      'storedIn': serializer.toJson<String?>(storedIn),
      'improvements': serializer.toJson<String?>(improvements),
      'specialMaterialIndex': serializer.toJson<int?>(specialMaterialIndex),
      'price': serializer.toJson<double?>(price),
      'desc': serializer.toJson<String?>(desc),
      'ocupedSpace': serializer.toJson<double>(ocupedSpace),
      'typeIndex': serializer.toJson<int>(typeIndex),
      'defenseBonus': serializer.toJson<int>(defenseBonus),
      'penalty': serializer.toJson<int>(penalty),
      'inUse': serializer.toJson<bool>(inUse),
      'createdAt': serializer.toJson<int>(createdAt),
      'updatedAt': serializer.toJson<int>(updatedAt),
    };
  }

  ShieldTableData copyWith({
    String? uuid,
    String? name,
    String? parentUuid,
    Value<String?> storedIn = const Value.absent(),
    Value<String?> improvements = const Value.absent(),
    Value<int?> specialMaterialIndex = const Value.absent(),
    Value<double?> price = const Value.absent(),
    Value<String?> desc = const Value.absent(),
    double? ocupedSpace,
    int? typeIndex,
    int? defenseBonus,
    int? penalty,
    bool? inUse,
    int? createdAt,
    int? updatedAt,
  }) => ShieldTableData(
    uuid: uuid ?? this.uuid,
    name: name ?? this.name,
    parentUuid: parentUuid ?? this.parentUuid,
    storedIn: storedIn.present ? storedIn.value : this.storedIn,
    improvements: improvements.present ? improvements.value : this.improvements,
    specialMaterialIndex: specialMaterialIndex.present
        ? specialMaterialIndex.value
        : this.specialMaterialIndex,
    price: price.present ? price.value : this.price,
    desc: desc.present ? desc.value : this.desc,
    ocupedSpace: ocupedSpace ?? this.ocupedSpace,
    typeIndex: typeIndex ?? this.typeIndex,
    defenseBonus: defenseBonus ?? this.defenseBonus,
    penalty: penalty ?? this.penalty,
    inUse: inUse ?? this.inUse,
    createdAt: createdAt ?? this.createdAt,
    updatedAt: updatedAt ?? this.updatedAt,
  );
  ShieldTableData copyWithCompanion(ShieldTableCompanion data) {
    return ShieldTableData(
      uuid: data.uuid.present ? data.uuid.value : this.uuid,
      name: data.name.present ? data.name.value : this.name,
      parentUuid: data.parentUuid.present
          ? data.parentUuid.value
          : this.parentUuid,
      storedIn: data.storedIn.present ? data.storedIn.value : this.storedIn,
      improvements: data.improvements.present
          ? data.improvements.value
          : this.improvements,
      specialMaterialIndex: data.specialMaterialIndex.present
          ? data.specialMaterialIndex.value
          : this.specialMaterialIndex,
      price: data.price.present ? data.price.value : this.price,
      desc: data.desc.present ? data.desc.value : this.desc,
      ocupedSpace: data.ocupedSpace.present
          ? data.ocupedSpace.value
          : this.ocupedSpace,
      typeIndex: data.typeIndex.present ? data.typeIndex.value : this.typeIndex,
      defenseBonus: data.defenseBonus.present
          ? data.defenseBonus.value
          : this.defenseBonus,
      penalty: data.penalty.present ? data.penalty.value : this.penalty,
      inUse: data.inUse.present ? data.inUse.value : this.inUse,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('ShieldTableData(')
          ..write('uuid: $uuid, ')
          ..write('name: $name, ')
          ..write('parentUuid: $parentUuid, ')
          ..write('storedIn: $storedIn, ')
          ..write('improvements: $improvements, ')
          ..write('specialMaterialIndex: $specialMaterialIndex, ')
          ..write('price: $price, ')
          ..write('desc: $desc, ')
          ..write('ocupedSpace: $ocupedSpace, ')
          ..write('typeIndex: $typeIndex, ')
          ..write('defenseBonus: $defenseBonus, ')
          ..write('penalty: $penalty, ')
          ..write('inUse: $inUse, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    uuid,
    name,
    parentUuid,
    storedIn,
    improvements,
    specialMaterialIndex,
    price,
    desc,
    ocupedSpace,
    typeIndex,
    defenseBonus,
    penalty,
    inUse,
    createdAt,
    updatedAt,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is ShieldTableData &&
          other.uuid == this.uuid &&
          other.name == this.name &&
          other.parentUuid == this.parentUuid &&
          other.storedIn == this.storedIn &&
          other.improvements == this.improvements &&
          other.specialMaterialIndex == this.specialMaterialIndex &&
          other.price == this.price &&
          other.desc == this.desc &&
          other.ocupedSpace == this.ocupedSpace &&
          other.typeIndex == this.typeIndex &&
          other.defenseBonus == this.defenseBonus &&
          other.penalty == this.penalty &&
          other.inUse == this.inUse &&
          other.createdAt == this.createdAt &&
          other.updatedAt == this.updatedAt);
}

class ShieldTableCompanion extends UpdateCompanion<ShieldTableData> {
  final Value<String> uuid;
  final Value<String> name;
  final Value<String> parentUuid;
  final Value<String?> storedIn;
  final Value<String?> improvements;
  final Value<int?> specialMaterialIndex;
  final Value<double?> price;
  final Value<String?> desc;
  final Value<double> ocupedSpace;
  final Value<int> typeIndex;
  final Value<int> defenseBonus;
  final Value<int> penalty;
  final Value<bool> inUse;
  final Value<int> createdAt;
  final Value<int> updatedAt;
  final Value<int> rowid;
  const ShieldTableCompanion({
    this.uuid = const Value.absent(),
    this.name = const Value.absent(),
    this.parentUuid = const Value.absent(),
    this.storedIn = const Value.absent(),
    this.improvements = const Value.absent(),
    this.specialMaterialIndex = const Value.absent(),
    this.price = const Value.absent(),
    this.desc = const Value.absent(),
    this.ocupedSpace = const Value.absent(),
    this.typeIndex = const Value.absent(),
    this.defenseBonus = const Value.absent(),
    this.penalty = const Value.absent(),
    this.inUse = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  ShieldTableCompanion.insert({
    required String uuid,
    required String name,
    required String parentUuid,
    this.storedIn = const Value.absent(),
    this.improvements = const Value.absent(),
    this.specialMaterialIndex = const Value.absent(),
    this.price = const Value.absent(),
    this.desc = const Value.absent(),
    required double ocupedSpace,
    required int typeIndex,
    required int defenseBonus,
    required int penalty,
    this.inUse = const Value.absent(),
    required int createdAt,
    required int updatedAt,
    this.rowid = const Value.absent(),
  }) : uuid = Value(uuid),
       name = Value(name),
       parentUuid = Value(parentUuid),
       ocupedSpace = Value(ocupedSpace),
       typeIndex = Value(typeIndex),
       defenseBonus = Value(defenseBonus),
       penalty = Value(penalty),
       createdAt = Value(createdAt),
       updatedAt = Value(updatedAt);
  static Insertable<ShieldTableData> custom({
    Expression<String>? uuid,
    Expression<String>? name,
    Expression<String>? parentUuid,
    Expression<String>? storedIn,
    Expression<String>? improvements,
    Expression<int>? specialMaterialIndex,
    Expression<double>? price,
    Expression<String>? desc,
    Expression<double>? ocupedSpace,
    Expression<int>? typeIndex,
    Expression<int>? defenseBonus,
    Expression<int>? penalty,
    Expression<bool>? inUse,
    Expression<int>? createdAt,
    Expression<int>? updatedAt,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (uuid != null) 'uuid': uuid,
      if (name != null) 'name': name,
      if (parentUuid != null) 'parent_uuid': parentUuid,
      if (storedIn != null) 'stored_in': storedIn,
      if (improvements != null) 'improvements': improvements,
      if (specialMaterialIndex != null)
        'special_material_index': specialMaterialIndex,
      if (price != null) 'price': price,
      if (desc != null) 'desc': desc,
      if (ocupedSpace != null) 'ocuped_space': ocupedSpace,
      if (typeIndex != null) 'type_index': typeIndex,
      if (defenseBonus != null) 'defense_bonus': defenseBonus,
      if (penalty != null) 'penalty': penalty,
      if (inUse != null) 'in_use': inUse,
      if (createdAt != null) 'created_at': createdAt,
      if (updatedAt != null) 'updated_at': updatedAt,
      if (rowid != null) 'rowid': rowid,
    });
  }

  ShieldTableCompanion copyWith({
    Value<String>? uuid,
    Value<String>? name,
    Value<String>? parentUuid,
    Value<String?>? storedIn,
    Value<String?>? improvements,
    Value<int?>? specialMaterialIndex,
    Value<double?>? price,
    Value<String?>? desc,
    Value<double>? ocupedSpace,
    Value<int>? typeIndex,
    Value<int>? defenseBonus,
    Value<int>? penalty,
    Value<bool>? inUse,
    Value<int>? createdAt,
    Value<int>? updatedAt,
    Value<int>? rowid,
  }) {
    return ShieldTableCompanion(
      uuid: uuid ?? this.uuid,
      name: name ?? this.name,
      parentUuid: parentUuid ?? this.parentUuid,
      storedIn: storedIn ?? this.storedIn,
      improvements: improvements ?? this.improvements,
      specialMaterialIndex: specialMaterialIndex ?? this.specialMaterialIndex,
      price: price ?? this.price,
      desc: desc ?? this.desc,
      ocupedSpace: ocupedSpace ?? this.ocupedSpace,
      typeIndex: typeIndex ?? this.typeIndex,
      defenseBonus: defenseBonus ?? this.defenseBonus,
      penalty: penalty ?? this.penalty,
      inUse: inUse ?? this.inUse,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (uuid.present) {
      map['uuid'] = Variable<String>(uuid.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    if (parentUuid.present) {
      map['parent_uuid'] = Variable<String>(parentUuid.value);
    }
    if (storedIn.present) {
      map['stored_in'] = Variable<String>(storedIn.value);
    }
    if (improvements.present) {
      map['improvements'] = Variable<String>(improvements.value);
    }
    if (specialMaterialIndex.present) {
      map['special_material_index'] = Variable<int>(specialMaterialIndex.value);
    }
    if (price.present) {
      map['price'] = Variable<double>(price.value);
    }
    if (desc.present) {
      map['desc'] = Variable<String>(desc.value);
    }
    if (ocupedSpace.present) {
      map['ocuped_space'] = Variable<double>(ocupedSpace.value);
    }
    if (typeIndex.present) {
      map['type_index'] = Variable<int>(typeIndex.value);
    }
    if (defenseBonus.present) {
      map['defense_bonus'] = Variable<int>(defenseBonus.value);
    }
    if (penalty.present) {
      map['penalty'] = Variable<int>(penalty.value);
    }
    if (inUse.present) {
      map['in_use'] = Variable<bool>(inUse.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<int>(createdAt.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<int>(updatedAt.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('ShieldTableCompanion(')
          ..write('uuid: $uuid, ')
          ..write('name: $name, ')
          ..write('parentUuid: $parentUuid, ')
          ..write('storedIn: $storedIn, ')
          ..write('improvements: $improvements, ')
          ..write('specialMaterialIndex: $specialMaterialIndex, ')
          ..write('price: $price, ')
          ..write('desc: $desc, ')
          ..write('ocupedSpace: $ocupedSpace, ')
          ..write('typeIndex: $typeIndex, ')
          ..write('defenseBonus: $defenseBonus, ')
          ..write('penalty: $penalty, ')
          ..write('inUse: $inUse, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $TibarsTableTable extends TibarsTable
    with TableInfo<$TibarsTableTable, TibarsTableData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $TibarsTableTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _uuidMeta = const VerificationMeta('uuid');
  @override
  late final GeneratedColumn<String> uuid = GeneratedColumn<String>(
    'uuid',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _parentUuidMeta = const VerificationMeta(
    'parentUuid',
  );
  @override
  late final GeneratedColumn<String> parentUuid = GeneratedColumn<String>(
    'parent_uuid',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _storedInMeta = const VerificationMeta(
    'storedIn',
  );
  @override
  late final GeneratedColumn<String> storedIn = GeneratedColumn<String>(
    'stored_in',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _goldMeta = const VerificationMeta('gold');
  @override
  late final GeneratedColumn<int> gold = GeneratedColumn<int>(
    'gold',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _silverMeta = const VerificationMeta('silver');
  @override
  late final GeneratedColumn<int> silver = GeneratedColumn<int>(
    'silver',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _bronzeMeta = const VerificationMeta('bronze');
  @override
  late final GeneratedColumn<int> bronze = GeneratedColumn<int>(
    'bronze',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _hasInitialRollMeta = const VerificationMeta(
    'hasInitialRoll',
  );
  @override
  late final GeneratedColumn<bool> hasInitialRoll = GeneratedColumn<bool>(
    'has_initial_roll',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("has_initial_roll" IN (0, 1))',
    ),
  );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<int> createdAt = GeneratedColumn<int>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _updatedAtMeta = const VerificationMeta(
    'updatedAt',
  );
  @override
  late final GeneratedColumn<int> updatedAt = GeneratedColumn<int>(
    'updated_at',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  @override
  List<GeneratedColumn> get $columns => [
    uuid,
    parentUuid,
    storedIn,
    gold,
    silver,
    bronze,
    hasInitialRoll,
    createdAt,
    updatedAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'tibars_table';
  @override
  VerificationContext validateIntegrity(
    Insertable<TibarsTableData> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('uuid')) {
      context.handle(
        _uuidMeta,
        uuid.isAcceptableOrUnknown(data['uuid']!, _uuidMeta),
      );
    } else if (isInserting) {
      context.missing(_uuidMeta);
    }
    if (data.containsKey('parent_uuid')) {
      context.handle(
        _parentUuidMeta,
        parentUuid.isAcceptableOrUnknown(data['parent_uuid']!, _parentUuidMeta),
      );
    } else if (isInserting) {
      context.missing(_parentUuidMeta);
    }
    if (data.containsKey('stored_in')) {
      context.handle(
        _storedInMeta,
        storedIn.isAcceptableOrUnknown(data['stored_in']!, _storedInMeta),
      );
    }
    if (data.containsKey('gold')) {
      context.handle(
        _goldMeta,
        gold.isAcceptableOrUnknown(data['gold']!, _goldMeta),
      );
    } else if (isInserting) {
      context.missing(_goldMeta);
    }
    if (data.containsKey('silver')) {
      context.handle(
        _silverMeta,
        silver.isAcceptableOrUnknown(data['silver']!, _silverMeta),
      );
    } else if (isInserting) {
      context.missing(_silverMeta);
    }
    if (data.containsKey('bronze')) {
      context.handle(
        _bronzeMeta,
        bronze.isAcceptableOrUnknown(data['bronze']!, _bronzeMeta),
      );
    } else if (isInserting) {
      context.missing(_bronzeMeta);
    }
    if (data.containsKey('has_initial_roll')) {
      context.handle(
        _hasInitialRollMeta,
        hasInitialRoll.isAcceptableOrUnknown(
          data['has_initial_roll']!,
          _hasInitialRollMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_hasInitialRollMeta);
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    } else if (isInserting) {
      context.missing(_createdAtMeta);
    }
    if (data.containsKey('updated_at')) {
      context.handle(
        _updatedAtMeta,
        updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta),
      );
    } else if (isInserting) {
      context.missing(_updatedAtMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {uuid};
  @override
  TibarsTableData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return TibarsTableData(
      uuid: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}uuid'],
      )!,
      parentUuid: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}parent_uuid'],
      )!,
      storedIn: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}stored_in'],
      ),
      gold: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}gold'],
      )!,
      silver: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}silver'],
      )!,
      bronze: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}bronze'],
      )!,
      hasInitialRoll: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}has_initial_roll'],
      )!,
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}created_at'],
      )!,
      updatedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}updated_at'],
      )!,
    );
  }

  @override
  $TibarsTableTable createAlias(String alias) {
    return $TibarsTableTable(attachedDatabase, alias);
  }
}

class TibarsTableData extends DataClass implements Insertable<TibarsTableData> {
  final String uuid;
  final String parentUuid;
  final String? storedIn;
  final int gold;
  final int silver;
  final int bronze;
  final bool hasInitialRoll;
  final int createdAt;
  final int updatedAt;
  const TibarsTableData({
    required this.uuid,
    required this.parentUuid,
    this.storedIn,
    required this.gold,
    required this.silver,
    required this.bronze,
    required this.hasInitialRoll,
    required this.createdAt,
    required this.updatedAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['uuid'] = Variable<String>(uuid);
    map['parent_uuid'] = Variable<String>(parentUuid);
    if (!nullToAbsent || storedIn != null) {
      map['stored_in'] = Variable<String>(storedIn);
    }
    map['gold'] = Variable<int>(gold);
    map['silver'] = Variable<int>(silver);
    map['bronze'] = Variable<int>(bronze);
    map['has_initial_roll'] = Variable<bool>(hasInitialRoll);
    map['created_at'] = Variable<int>(createdAt);
    map['updated_at'] = Variable<int>(updatedAt);
    return map;
  }

  TibarsTableCompanion toCompanion(bool nullToAbsent) {
    return TibarsTableCompanion(
      uuid: Value(uuid),
      parentUuid: Value(parentUuid),
      storedIn: storedIn == null && nullToAbsent
          ? const Value.absent()
          : Value(storedIn),
      gold: Value(gold),
      silver: Value(silver),
      bronze: Value(bronze),
      hasInitialRoll: Value(hasInitialRoll),
      createdAt: Value(createdAt),
      updatedAt: Value(updatedAt),
    );
  }

  factory TibarsTableData.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return TibarsTableData(
      uuid: serializer.fromJson<String>(json['uuid']),
      parentUuid: serializer.fromJson<String>(json['parentUuid']),
      storedIn: serializer.fromJson<String?>(json['storedIn']),
      gold: serializer.fromJson<int>(json['gold']),
      silver: serializer.fromJson<int>(json['silver']),
      bronze: serializer.fromJson<int>(json['bronze']),
      hasInitialRoll: serializer.fromJson<bool>(json['hasInitialRoll']),
      createdAt: serializer.fromJson<int>(json['createdAt']),
      updatedAt: serializer.fromJson<int>(json['updatedAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'uuid': serializer.toJson<String>(uuid),
      'parentUuid': serializer.toJson<String>(parentUuid),
      'storedIn': serializer.toJson<String?>(storedIn),
      'gold': serializer.toJson<int>(gold),
      'silver': serializer.toJson<int>(silver),
      'bronze': serializer.toJson<int>(bronze),
      'hasInitialRoll': serializer.toJson<bool>(hasInitialRoll),
      'createdAt': serializer.toJson<int>(createdAt),
      'updatedAt': serializer.toJson<int>(updatedAt),
    };
  }

  TibarsTableData copyWith({
    String? uuid,
    String? parentUuid,
    Value<String?> storedIn = const Value.absent(),
    int? gold,
    int? silver,
    int? bronze,
    bool? hasInitialRoll,
    int? createdAt,
    int? updatedAt,
  }) => TibarsTableData(
    uuid: uuid ?? this.uuid,
    parentUuid: parentUuid ?? this.parentUuid,
    storedIn: storedIn.present ? storedIn.value : this.storedIn,
    gold: gold ?? this.gold,
    silver: silver ?? this.silver,
    bronze: bronze ?? this.bronze,
    hasInitialRoll: hasInitialRoll ?? this.hasInitialRoll,
    createdAt: createdAt ?? this.createdAt,
    updatedAt: updatedAt ?? this.updatedAt,
  );
  TibarsTableData copyWithCompanion(TibarsTableCompanion data) {
    return TibarsTableData(
      uuid: data.uuid.present ? data.uuid.value : this.uuid,
      parentUuid: data.parentUuid.present
          ? data.parentUuid.value
          : this.parentUuid,
      storedIn: data.storedIn.present ? data.storedIn.value : this.storedIn,
      gold: data.gold.present ? data.gold.value : this.gold,
      silver: data.silver.present ? data.silver.value : this.silver,
      bronze: data.bronze.present ? data.bronze.value : this.bronze,
      hasInitialRoll: data.hasInitialRoll.present
          ? data.hasInitialRoll.value
          : this.hasInitialRoll,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('TibarsTableData(')
          ..write('uuid: $uuid, ')
          ..write('parentUuid: $parentUuid, ')
          ..write('storedIn: $storedIn, ')
          ..write('gold: $gold, ')
          ..write('silver: $silver, ')
          ..write('bronze: $bronze, ')
          ..write('hasInitialRoll: $hasInitialRoll, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    uuid,
    parentUuid,
    storedIn,
    gold,
    silver,
    bronze,
    hasInitialRoll,
    createdAt,
    updatedAt,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is TibarsTableData &&
          other.uuid == this.uuid &&
          other.parentUuid == this.parentUuid &&
          other.storedIn == this.storedIn &&
          other.gold == this.gold &&
          other.silver == this.silver &&
          other.bronze == this.bronze &&
          other.hasInitialRoll == this.hasInitialRoll &&
          other.createdAt == this.createdAt &&
          other.updatedAt == this.updatedAt);
}

class TibarsTableCompanion extends UpdateCompanion<TibarsTableData> {
  final Value<String> uuid;
  final Value<String> parentUuid;
  final Value<String?> storedIn;
  final Value<int> gold;
  final Value<int> silver;
  final Value<int> bronze;
  final Value<bool> hasInitialRoll;
  final Value<int> createdAt;
  final Value<int> updatedAt;
  final Value<int> rowid;
  const TibarsTableCompanion({
    this.uuid = const Value.absent(),
    this.parentUuid = const Value.absent(),
    this.storedIn = const Value.absent(),
    this.gold = const Value.absent(),
    this.silver = const Value.absent(),
    this.bronze = const Value.absent(),
    this.hasInitialRoll = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  TibarsTableCompanion.insert({
    required String uuid,
    required String parentUuid,
    this.storedIn = const Value.absent(),
    required int gold,
    required int silver,
    required int bronze,
    required bool hasInitialRoll,
    required int createdAt,
    required int updatedAt,
    this.rowid = const Value.absent(),
  }) : uuid = Value(uuid),
       parentUuid = Value(parentUuid),
       gold = Value(gold),
       silver = Value(silver),
       bronze = Value(bronze),
       hasInitialRoll = Value(hasInitialRoll),
       createdAt = Value(createdAt),
       updatedAt = Value(updatedAt);
  static Insertable<TibarsTableData> custom({
    Expression<String>? uuid,
    Expression<String>? parentUuid,
    Expression<String>? storedIn,
    Expression<int>? gold,
    Expression<int>? silver,
    Expression<int>? bronze,
    Expression<bool>? hasInitialRoll,
    Expression<int>? createdAt,
    Expression<int>? updatedAt,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (uuid != null) 'uuid': uuid,
      if (parentUuid != null) 'parent_uuid': parentUuid,
      if (storedIn != null) 'stored_in': storedIn,
      if (gold != null) 'gold': gold,
      if (silver != null) 'silver': silver,
      if (bronze != null) 'bronze': bronze,
      if (hasInitialRoll != null) 'has_initial_roll': hasInitialRoll,
      if (createdAt != null) 'created_at': createdAt,
      if (updatedAt != null) 'updated_at': updatedAt,
      if (rowid != null) 'rowid': rowid,
    });
  }

  TibarsTableCompanion copyWith({
    Value<String>? uuid,
    Value<String>? parentUuid,
    Value<String?>? storedIn,
    Value<int>? gold,
    Value<int>? silver,
    Value<int>? bronze,
    Value<bool>? hasInitialRoll,
    Value<int>? createdAt,
    Value<int>? updatedAt,
    Value<int>? rowid,
  }) {
    return TibarsTableCompanion(
      uuid: uuid ?? this.uuid,
      parentUuid: parentUuid ?? this.parentUuid,
      storedIn: storedIn ?? this.storedIn,
      gold: gold ?? this.gold,
      silver: silver ?? this.silver,
      bronze: bronze ?? this.bronze,
      hasInitialRoll: hasInitialRoll ?? this.hasInitialRoll,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (uuid.present) {
      map['uuid'] = Variable<String>(uuid.value);
    }
    if (parentUuid.present) {
      map['parent_uuid'] = Variable<String>(parentUuid.value);
    }
    if (storedIn.present) {
      map['stored_in'] = Variable<String>(storedIn.value);
    }
    if (gold.present) {
      map['gold'] = Variable<int>(gold.value);
    }
    if (silver.present) {
      map['silver'] = Variable<int>(silver.value);
    }
    if (bronze.present) {
      map['bronze'] = Variable<int>(bronze.value);
    }
    if (hasInitialRoll.present) {
      map['has_initial_roll'] = Variable<bool>(hasInitialRoll.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<int>(createdAt.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<int>(updatedAt.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('TibarsTableCompanion(')
          ..write('uuid: $uuid, ')
          ..write('parentUuid: $parentUuid, ')
          ..write('storedIn: $storedIn, ')
          ..write('gold: $gold, ')
          ..write('silver: $silver, ')
          ..write('bronze: $bronze, ')
          ..write('hasInitialRoll: $hasInitialRoll, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $WeaponTableTable extends WeaponTable
    with TableInfo<$WeaponTableTable, WeaponTableData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $WeaponTableTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _uuidMeta = const VerificationMeta('uuid');
  @override
  late final GeneratedColumn<String> uuid = GeneratedColumn<String>(
    'uuid',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
    'name',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _parentUuidMeta = const VerificationMeta(
    'parentUuid',
  );
  @override
  late final GeneratedColumn<String> parentUuid = GeneratedColumn<String>(
    'parent_uuid',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _storedInMeta = const VerificationMeta(
    'storedIn',
  );
  @override
  late final GeneratedColumn<String> storedIn = GeneratedColumn<String>(
    'stored_in',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _improvementsMeta = const VerificationMeta(
    'improvements',
  );
  @override
  late final GeneratedColumn<String> improvements = GeneratedColumn<String>(
    'improvements',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _specialMaterialIndexMeta =
      const VerificationMeta('specialMaterialIndex');
  @override
  late final GeneratedColumn<int> specialMaterialIndex = GeneratedColumn<int>(
    'special_material_index',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _priceMeta = const VerificationMeta('price');
  @override
  late final GeneratedColumn<double> price = GeneratedColumn<double>(
    'price',
    aliasedName,
    true,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _descMeta = const VerificationMeta('desc');
  @override
  late final GeneratedColumn<String> desc = GeneratedColumn<String>(
    'desc',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _ocupedSpaceMeta = const VerificationMeta(
    'ocupedSpace',
  );
  @override
  late final GeneratedColumn<double> ocupedSpace = GeneratedColumn<double>(
    'ocuped_space',
    aliasedName,
    false,
    type: DriftSqlType.double,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _wieldableIndexMeta = const VerificationMeta(
    'wieldableIndex',
  );
  @override
  late final GeneratedColumn<int> wieldableIndex = GeneratedColumn<int>(
    'wieldable_index',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _purposeIndexMeta = const VerificationMeta(
    'purposeIndex',
  );
  @override
  late final GeneratedColumn<int> purposeIndex = GeneratedColumn<int>(
    'purpose_index',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _proficiencyIndexMeta = const VerificationMeta(
    'proficiencyIndex',
  );
  @override
  late final GeneratedColumn<int> proficiencyIndex = GeneratedColumn<int>(
    'proficiency_index',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _typeIndexMeta = const VerificationMeta(
    'typeIndex',
  );
  @override
  late final GeneratedColumn<int> typeIndex = GeneratedColumn<int>(
    'type_index',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _rangeIndexMeta = const VerificationMeta(
    'rangeIndex',
  );
  @override
  late final GeneratedColumn<int> rangeIndex = GeneratedColumn<int>(
    'range_index',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _criticalMeta = const VerificationMeta(
    'critical',
  );
  @override
  late final GeneratedColumn<int> critical = GeneratedColumn<int>(
    'critical',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _criticalMultiplierMeta =
      const VerificationMeta('criticalMultiplier');
  @override
  late final GeneratedColumn<int> criticalMultiplier = GeneratedColumn<int>(
    'critical_multiplier',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _stepsMeta = const VerificationMeta('steps');
  @override
  late final GeneratedColumn<int> steps = GeneratedColumn<int>(
    'steps',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _dicesMeta = const VerificationMeta('dices');
  @override
  late final GeneratedColumn<String> dices = GeneratedColumn<String>(
    'dices',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _skillIndexesMeta = const VerificationMeta(
    'skillIndexes',
  );
  @override
  late final GeneratedColumn<String> skillIndexes = GeneratedColumn<String>(
    'skill_indexes',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _isNaturalMeta = const VerificationMeta(
    'isNatural',
  );
  @override
  late final GeneratedColumn<bool> isNatural = GeneratedColumn<bool>(
    'is_natural',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_natural" IN (0, 1))',
    ),
  );
  static const VerificationMeta _isUnarmedMeta = const VerificationMeta(
    'isUnarmed',
  );
  @override
  late final GeneratedColumn<bool> isUnarmed = GeneratedColumn<bool>(
    'is_unarmed',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_unarmed" IN (0, 1))',
    ),
  );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<int> createdAt = GeneratedColumn<int>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _updatedAtMeta = const VerificationMeta(
    'updatedAt',
  );
  @override
  late final GeneratedColumn<int> updatedAt = GeneratedColumn<int>(
    'updated_at',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  @override
  List<GeneratedColumn> get $columns => [
    uuid,
    name,
    parentUuid,
    storedIn,
    improvements,
    specialMaterialIndex,
    price,
    desc,
    ocupedSpace,
    wieldableIndex,
    purposeIndex,
    proficiencyIndex,
    typeIndex,
    rangeIndex,
    critical,
    criticalMultiplier,
    steps,
    dices,
    skillIndexes,
    isNatural,
    isUnarmed,
    createdAt,
    updatedAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'weapon_table';
  @override
  VerificationContext validateIntegrity(
    Insertable<WeaponTableData> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('uuid')) {
      context.handle(
        _uuidMeta,
        uuid.isAcceptableOrUnknown(data['uuid']!, _uuidMeta),
      );
    } else if (isInserting) {
      context.missing(_uuidMeta);
    }
    if (data.containsKey('name')) {
      context.handle(
        _nameMeta,
        name.isAcceptableOrUnknown(data['name']!, _nameMeta),
      );
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    if (data.containsKey('parent_uuid')) {
      context.handle(
        _parentUuidMeta,
        parentUuid.isAcceptableOrUnknown(data['parent_uuid']!, _parentUuidMeta),
      );
    } else if (isInserting) {
      context.missing(_parentUuidMeta);
    }
    if (data.containsKey('stored_in')) {
      context.handle(
        _storedInMeta,
        storedIn.isAcceptableOrUnknown(data['stored_in']!, _storedInMeta),
      );
    }
    if (data.containsKey('improvements')) {
      context.handle(
        _improvementsMeta,
        improvements.isAcceptableOrUnknown(
          data['improvements']!,
          _improvementsMeta,
        ),
      );
    }
    if (data.containsKey('special_material_index')) {
      context.handle(
        _specialMaterialIndexMeta,
        specialMaterialIndex.isAcceptableOrUnknown(
          data['special_material_index']!,
          _specialMaterialIndexMeta,
        ),
      );
    }
    if (data.containsKey('price')) {
      context.handle(
        _priceMeta,
        price.isAcceptableOrUnknown(data['price']!, _priceMeta),
      );
    }
    if (data.containsKey('desc')) {
      context.handle(
        _descMeta,
        desc.isAcceptableOrUnknown(data['desc']!, _descMeta),
      );
    }
    if (data.containsKey('ocuped_space')) {
      context.handle(
        _ocupedSpaceMeta,
        ocupedSpace.isAcceptableOrUnknown(
          data['ocuped_space']!,
          _ocupedSpaceMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_ocupedSpaceMeta);
    }
    if (data.containsKey('wieldable_index')) {
      context.handle(
        _wieldableIndexMeta,
        wieldableIndex.isAcceptableOrUnknown(
          data['wieldable_index']!,
          _wieldableIndexMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_wieldableIndexMeta);
    }
    if (data.containsKey('purpose_index')) {
      context.handle(
        _purposeIndexMeta,
        purposeIndex.isAcceptableOrUnknown(
          data['purpose_index']!,
          _purposeIndexMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_purposeIndexMeta);
    }
    if (data.containsKey('proficiency_index')) {
      context.handle(
        _proficiencyIndexMeta,
        proficiencyIndex.isAcceptableOrUnknown(
          data['proficiency_index']!,
          _proficiencyIndexMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_proficiencyIndexMeta);
    }
    if (data.containsKey('type_index')) {
      context.handle(
        _typeIndexMeta,
        typeIndex.isAcceptableOrUnknown(data['type_index']!, _typeIndexMeta),
      );
    } else if (isInserting) {
      context.missing(_typeIndexMeta);
    }
    if (data.containsKey('range_index')) {
      context.handle(
        _rangeIndexMeta,
        rangeIndex.isAcceptableOrUnknown(data['range_index']!, _rangeIndexMeta),
      );
    } else if (isInserting) {
      context.missing(_rangeIndexMeta);
    }
    if (data.containsKey('critical')) {
      context.handle(
        _criticalMeta,
        critical.isAcceptableOrUnknown(data['critical']!, _criticalMeta),
      );
    } else if (isInserting) {
      context.missing(_criticalMeta);
    }
    if (data.containsKey('critical_multiplier')) {
      context.handle(
        _criticalMultiplierMeta,
        criticalMultiplier.isAcceptableOrUnknown(
          data['critical_multiplier']!,
          _criticalMultiplierMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_criticalMultiplierMeta);
    }
    if (data.containsKey('steps')) {
      context.handle(
        _stepsMeta,
        steps.isAcceptableOrUnknown(data['steps']!, _stepsMeta),
      );
    }
    if (data.containsKey('dices')) {
      context.handle(
        _dicesMeta,
        dices.isAcceptableOrUnknown(data['dices']!, _dicesMeta),
      );
    } else if (isInserting) {
      context.missing(_dicesMeta);
    }
    if (data.containsKey('skill_indexes')) {
      context.handle(
        _skillIndexesMeta,
        skillIndexes.isAcceptableOrUnknown(
          data['skill_indexes']!,
          _skillIndexesMeta,
        ),
      );
    }
    if (data.containsKey('is_natural')) {
      context.handle(
        _isNaturalMeta,
        isNatural.isAcceptableOrUnknown(data['is_natural']!, _isNaturalMeta),
      );
    } else if (isInserting) {
      context.missing(_isNaturalMeta);
    }
    if (data.containsKey('is_unarmed')) {
      context.handle(
        _isUnarmedMeta,
        isUnarmed.isAcceptableOrUnknown(data['is_unarmed']!, _isUnarmedMeta),
      );
    } else if (isInserting) {
      context.missing(_isUnarmedMeta);
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    } else if (isInserting) {
      context.missing(_createdAtMeta);
    }
    if (data.containsKey('updated_at')) {
      context.handle(
        _updatedAtMeta,
        updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta),
      );
    } else if (isInserting) {
      context.missing(_updatedAtMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {uuid};
  @override
  WeaponTableData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return WeaponTableData(
      uuid: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}uuid'],
      )!,
      name: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}name'],
      )!,
      parentUuid: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}parent_uuid'],
      )!,
      storedIn: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}stored_in'],
      ),
      improvements: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}improvements'],
      ),
      specialMaterialIndex: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}special_material_index'],
      ),
      price: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}price'],
      ),
      desc: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}desc'],
      ),
      ocupedSpace: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}ocuped_space'],
      )!,
      wieldableIndex: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}wieldable_index'],
      )!,
      purposeIndex: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}purpose_index'],
      )!,
      proficiencyIndex: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}proficiency_index'],
      )!,
      typeIndex: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}type_index'],
      )!,
      rangeIndex: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}range_index'],
      )!,
      critical: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}critical'],
      )!,
      criticalMultiplier: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}critical_multiplier'],
      )!,
      steps: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}steps'],
      ),
      dices: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}dices'],
      )!,
      skillIndexes: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}skill_indexes'],
      ),
      isNatural: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_natural'],
      )!,
      isUnarmed: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_unarmed'],
      )!,
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}created_at'],
      )!,
      updatedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}updated_at'],
      )!,
    );
  }

  @override
  $WeaponTableTable createAlias(String alias) {
    return $WeaponTableTable(attachedDatabase, alias);
  }
}

class WeaponTableData extends DataClass implements Insertable<WeaponTableData> {
  final String uuid;
  final String name;
  final String parentUuid;
  final String? storedIn;
  final String? improvements;
  final int? specialMaterialIndex;
  final double? price;
  final String? desc;
  final double ocupedSpace;
  final int wieldableIndex;
  final int purposeIndex;
  final int proficiencyIndex;
  final int typeIndex;
  final int rangeIndex;
  final int critical;
  final int criticalMultiplier;
  final int? steps;
  final String dices;
  final String? skillIndexes;
  final bool isNatural;
  final bool isUnarmed;
  final int createdAt;
  final int updatedAt;
  const WeaponTableData({
    required this.uuid,
    required this.name,
    required this.parentUuid,
    this.storedIn,
    this.improvements,
    this.specialMaterialIndex,
    this.price,
    this.desc,
    required this.ocupedSpace,
    required this.wieldableIndex,
    required this.purposeIndex,
    required this.proficiencyIndex,
    required this.typeIndex,
    required this.rangeIndex,
    required this.critical,
    required this.criticalMultiplier,
    this.steps,
    required this.dices,
    this.skillIndexes,
    required this.isNatural,
    required this.isUnarmed,
    required this.createdAt,
    required this.updatedAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['uuid'] = Variable<String>(uuid);
    map['name'] = Variable<String>(name);
    map['parent_uuid'] = Variable<String>(parentUuid);
    if (!nullToAbsent || storedIn != null) {
      map['stored_in'] = Variable<String>(storedIn);
    }
    if (!nullToAbsent || improvements != null) {
      map['improvements'] = Variable<String>(improvements);
    }
    if (!nullToAbsent || specialMaterialIndex != null) {
      map['special_material_index'] = Variable<int>(specialMaterialIndex);
    }
    if (!nullToAbsent || price != null) {
      map['price'] = Variable<double>(price);
    }
    if (!nullToAbsent || desc != null) {
      map['desc'] = Variable<String>(desc);
    }
    map['ocuped_space'] = Variable<double>(ocupedSpace);
    map['wieldable_index'] = Variable<int>(wieldableIndex);
    map['purpose_index'] = Variable<int>(purposeIndex);
    map['proficiency_index'] = Variable<int>(proficiencyIndex);
    map['type_index'] = Variable<int>(typeIndex);
    map['range_index'] = Variable<int>(rangeIndex);
    map['critical'] = Variable<int>(critical);
    map['critical_multiplier'] = Variable<int>(criticalMultiplier);
    if (!nullToAbsent || steps != null) {
      map['steps'] = Variable<int>(steps);
    }
    map['dices'] = Variable<String>(dices);
    if (!nullToAbsent || skillIndexes != null) {
      map['skill_indexes'] = Variable<String>(skillIndexes);
    }
    map['is_natural'] = Variable<bool>(isNatural);
    map['is_unarmed'] = Variable<bool>(isUnarmed);
    map['created_at'] = Variable<int>(createdAt);
    map['updated_at'] = Variable<int>(updatedAt);
    return map;
  }

  WeaponTableCompanion toCompanion(bool nullToAbsent) {
    return WeaponTableCompanion(
      uuid: Value(uuid),
      name: Value(name),
      parentUuid: Value(parentUuid),
      storedIn: storedIn == null && nullToAbsent
          ? const Value.absent()
          : Value(storedIn),
      improvements: improvements == null && nullToAbsent
          ? const Value.absent()
          : Value(improvements),
      specialMaterialIndex: specialMaterialIndex == null && nullToAbsent
          ? const Value.absent()
          : Value(specialMaterialIndex),
      price: price == null && nullToAbsent
          ? const Value.absent()
          : Value(price),
      desc: desc == null && nullToAbsent ? const Value.absent() : Value(desc),
      ocupedSpace: Value(ocupedSpace),
      wieldableIndex: Value(wieldableIndex),
      purposeIndex: Value(purposeIndex),
      proficiencyIndex: Value(proficiencyIndex),
      typeIndex: Value(typeIndex),
      rangeIndex: Value(rangeIndex),
      critical: Value(critical),
      criticalMultiplier: Value(criticalMultiplier),
      steps: steps == null && nullToAbsent
          ? const Value.absent()
          : Value(steps),
      dices: Value(dices),
      skillIndexes: skillIndexes == null && nullToAbsent
          ? const Value.absent()
          : Value(skillIndexes),
      isNatural: Value(isNatural),
      isUnarmed: Value(isUnarmed),
      createdAt: Value(createdAt),
      updatedAt: Value(updatedAt),
    );
  }

  factory WeaponTableData.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return WeaponTableData(
      uuid: serializer.fromJson<String>(json['uuid']),
      name: serializer.fromJson<String>(json['name']),
      parentUuid: serializer.fromJson<String>(json['parentUuid']),
      storedIn: serializer.fromJson<String?>(json['storedIn']),
      improvements: serializer.fromJson<String?>(json['improvements']),
      specialMaterialIndex: serializer.fromJson<int?>(
        json['specialMaterialIndex'],
      ),
      price: serializer.fromJson<double?>(json['price']),
      desc: serializer.fromJson<String?>(json['desc']),
      ocupedSpace: serializer.fromJson<double>(json['ocupedSpace']),
      wieldableIndex: serializer.fromJson<int>(json['wieldableIndex']),
      purposeIndex: serializer.fromJson<int>(json['purposeIndex']),
      proficiencyIndex: serializer.fromJson<int>(json['proficiencyIndex']),
      typeIndex: serializer.fromJson<int>(json['typeIndex']),
      rangeIndex: serializer.fromJson<int>(json['rangeIndex']),
      critical: serializer.fromJson<int>(json['critical']),
      criticalMultiplier: serializer.fromJson<int>(json['criticalMultiplier']),
      steps: serializer.fromJson<int?>(json['steps']),
      dices: serializer.fromJson<String>(json['dices']),
      skillIndexes: serializer.fromJson<String?>(json['skillIndexes']),
      isNatural: serializer.fromJson<bool>(json['isNatural']),
      isUnarmed: serializer.fromJson<bool>(json['isUnarmed']),
      createdAt: serializer.fromJson<int>(json['createdAt']),
      updatedAt: serializer.fromJson<int>(json['updatedAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'uuid': serializer.toJson<String>(uuid),
      'name': serializer.toJson<String>(name),
      'parentUuid': serializer.toJson<String>(parentUuid),
      'storedIn': serializer.toJson<String?>(storedIn),
      'improvements': serializer.toJson<String?>(improvements),
      'specialMaterialIndex': serializer.toJson<int?>(specialMaterialIndex),
      'price': serializer.toJson<double?>(price),
      'desc': serializer.toJson<String?>(desc),
      'ocupedSpace': serializer.toJson<double>(ocupedSpace),
      'wieldableIndex': serializer.toJson<int>(wieldableIndex),
      'purposeIndex': serializer.toJson<int>(purposeIndex),
      'proficiencyIndex': serializer.toJson<int>(proficiencyIndex),
      'typeIndex': serializer.toJson<int>(typeIndex),
      'rangeIndex': serializer.toJson<int>(rangeIndex),
      'critical': serializer.toJson<int>(critical),
      'criticalMultiplier': serializer.toJson<int>(criticalMultiplier),
      'steps': serializer.toJson<int?>(steps),
      'dices': serializer.toJson<String>(dices),
      'skillIndexes': serializer.toJson<String?>(skillIndexes),
      'isNatural': serializer.toJson<bool>(isNatural),
      'isUnarmed': serializer.toJson<bool>(isUnarmed),
      'createdAt': serializer.toJson<int>(createdAt),
      'updatedAt': serializer.toJson<int>(updatedAt),
    };
  }

  WeaponTableData copyWith({
    String? uuid,
    String? name,
    String? parentUuid,
    Value<String?> storedIn = const Value.absent(),
    Value<String?> improvements = const Value.absent(),
    Value<int?> specialMaterialIndex = const Value.absent(),
    Value<double?> price = const Value.absent(),
    Value<String?> desc = const Value.absent(),
    double? ocupedSpace,
    int? wieldableIndex,
    int? purposeIndex,
    int? proficiencyIndex,
    int? typeIndex,
    int? rangeIndex,
    int? critical,
    int? criticalMultiplier,
    Value<int?> steps = const Value.absent(),
    String? dices,
    Value<String?> skillIndexes = const Value.absent(),
    bool? isNatural,
    bool? isUnarmed,
    int? createdAt,
    int? updatedAt,
  }) => WeaponTableData(
    uuid: uuid ?? this.uuid,
    name: name ?? this.name,
    parentUuid: parentUuid ?? this.parentUuid,
    storedIn: storedIn.present ? storedIn.value : this.storedIn,
    improvements: improvements.present ? improvements.value : this.improvements,
    specialMaterialIndex: specialMaterialIndex.present
        ? specialMaterialIndex.value
        : this.specialMaterialIndex,
    price: price.present ? price.value : this.price,
    desc: desc.present ? desc.value : this.desc,
    ocupedSpace: ocupedSpace ?? this.ocupedSpace,
    wieldableIndex: wieldableIndex ?? this.wieldableIndex,
    purposeIndex: purposeIndex ?? this.purposeIndex,
    proficiencyIndex: proficiencyIndex ?? this.proficiencyIndex,
    typeIndex: typeIndex ?? this.typeIndex,
    rangeIndex: rangeIndex ?? this.rangeIndex,
    critical: critical ?? this.critical,
    criticalMultiplier: criticalMultiplier ?? this.criticalMultiplier,
    steps: steps.present ? steps.value : this.steps,
    dices: dices ?? this.dices,
    skillIndexes: skillIndexes.present ? skillIndexes.value : this.skillIndexes,
    isNatural: isNatural ?? this.isNatural,
    isUnarmed: isUnarmed ?? this.isUnarmed,
    createdAt: createdAt ?? this.createdAt,
    updatedAt: updatedAt ?? this.updatedAt,
  );
  WeaponTableData copyWithCompanion(WeaponTableCompanion data) {
    return WeaponTableData(
      uuid: data.uuid.present ? data.uuid.value : this.uuid,
      name: data.name.present ? data.name.value : this.name,
      parentUuid: data.parentUuid.present
          ? data.parentUuid.value
          : this.parentUuid,
      storedIn: data.storedIn.present ? data.storedIn.value : this.storedIn,
      improvements: data.improvements.present
          ? data.improvements.value
          : this.improvements,
      specialMaterialIndex: data.specialMaterialIndex.present
          ? data.specialMaterialIndex.value
          : this.specialMaterialIndex,
      price: data.price.present ? data.price.value : this.price,
      desc: data.desc.present ? data.desc.value : this.desc,
      ocupedSpace: data.ocupedSpace.present
          ? data.ocupedSpace.value
          : this.ocupedSpace,
      wieldableIndex: data.wieldableIndex.present
          ? data.wieldableIndex.value
          : this.wieldableIndex,
      purposeIndex: data.purposeIndex.present
          ? data.purposeIndex.value
          : this.purposeIndex,
      proficiencyIndex: data.proficiencyIndex.present
          ? data.proficiencyIndex.value
          : this.proficiencyIndex,
      typeIndex: data.typeIndex.present ? data.typeIndex.value : this.typeIndex,
      rangeIndex: data.rangeIndex.present
          ? data.rangeIndex.value
          : this.rangeIndex,
      critical: data.critical.present ? data.critical.value : this.critical,
      criticalMultiplier: data.criticalMultiplier.present
          ? data.criticalMultiplier.value
          : this.criticalMultiplier,
      steps: data.steps.present ? data.steps.value : this.steps,
      dices: data.dices.present ? data.dices.value : this.dices,
      skillIndexes: data.skillIndexes.present
          ? data.skillIndexes.value
          : this.skillIndexes,
      isNatural: data.isNatural.present ? data.isNatural.value : this.isNatural,
      isUnarmed: data.isUnarmed.present ? data.isUnarmed.value : this.isUnarmed,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('WeaponTableData(')
          ..write('uuid: $uuid, ')
          ..write('name: $name, ')
          ..write('parentUuid: $parentUuid, ')
          ..write('storedIn: $storedIn, ')
          ..write('improvements: $improvements, ')
          ..write('specialMaterialIndex: $specialMaterialIndex, ')
          ..write('price: $price, ')
          ..write('desc: $desc, ')
          ..write('ocupedSpace: $ocupedSpace, ')
          ..write('wieldableIndex: $wieldableIndex, ')
          ..write('purposeIndex: $purposeIndex, ')
          ..write('proficiencyIndex: $proficiencyIndex, ')
          ..write('typeIndex: $typeIndex, ')
          ..write('rangeIndex: $rangeIndex, ')
          ..write('critical: $critical, ')
          ..write('criticalMultiplier: $criticalMultiplier, ')
          ..write('steps: $steps, ')
          ..write('dices: $dices, ')
          ..write('skillIndexes: $skillIndexes, ')
          ..write('isNatural: $isNatural, ')
          ..write('isUnarmed: $isUnarmed, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hashAll([
    uuid,
    name,
    parentUuid,
    storedIn,
    improvements,
    specialMaterialIndex,
    price,
    desc,
    ocupedSpace,
    wieldableIndex,
    purposeIndex,
    proficiencyIndex,
    typeIndex,
    rangeIndex,
    critical,
    criticalMultiplier,
    steps,
    dices,
    skillIndexes,
    isNatural,
    isUnarmed,
    createdAt,
    updatedAt,
  ]);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is WeaponTableData &&
          other.uuid == this.uuid &&
          other.name == this.name &&
          other.parentUuid == this.parentUuid &&
          other.storedIn == this.storedIn &&
          other.improvements == this.improvements &&
          other.specialMaterialIndex == this.specialMaterialIndex &&
          other.price == this.price &&
          other.desc == this.desc &&
          other.ocupedSpace == this.ocupedSpace &&
          other.wieldableIndex == this.wieldableIndex &&
          other.purposeIndex == this.purposeIndex &&
          other.proficiencyIndex == this.proficiencyIndex &&
          other.typeIndex == this.typeIndex &&
          other.rangeIndex == this.rangeIndex &&
          other.critical == this.critical &&
          other.criticalMultiplier == this.criticalMultiplier &&
          other.steps == this.steps &&
          other.dices == this.dices &&
          other.skillIndexes == this.skillIndexes &&
          other.isNatural == this.isNatural &&
          other.isUnarmed == this.isUnarmed &&
          other.createdAt == this.createdAt &&
          other.updatedAt == this.updatedAt);
}

class WeaponTableCompanion extends UpdateCompanion<WeaponTableData> {
  final Value<String> uuid;
  final Value<String> name;
  final Value<String> parentUuid;
  final Value<String?> storedIn;
  final Value<String?> improvements;
  final Value<int?> specialMaterialIndex;
  final Value<double?> price;
  final Value<String?> desc;
  final Value<double> ocupedSpace;
  final Value<int> wieldableIndex;
  final Value<int> purposeIndex;
  final Value<int> proficiencyIndex;
  final Value<int> typeIndex;
  final Value<int> rangeIndex;
  final Value<int> critical;
  final Value<int> criticalMultiplier;
  final Value<int?> steps;
  final Value<String> dices;
  final Value<String?> skillIndexes;
  final Value<bool> isNatural;
  final Value<bool> isUnarmed;
  final Value<int> createdAt;
  final Value<int> updatedAt;
  final Value<int> rowid;
  const WeaponTableCompanion({
    this.uuid = const Value.absent(),
    this.name = const Value.absent(),
    this.parentUuid = const Value.absent(),
    this.storedIn = const Value.absent(),
    this.improvements = const Value.absent(),
    this.specialMaterialIndex = const Value.absent(),
    this.price = const Value.absent(),
    this.desc = const Value.absent(),
    this.ocupedSpace = const Value.absent(),
    this.wieldableIndex = const Value.absent(),
    this.purposeIndex = const Value.absent(),
    this.proficiencyIndex = const Value.absent(),
    this.typeIndex = const Value.absent(),
    this.rangeIndex = const Value.absent(),
    this.critical = const Value.absent(),
    this.criticalMultiplier = const Value.absent(),
    this.steps = const Value.absent(),
    this.dices = const Value.absent(),
    this.skillIndexes = const Value.absent(),
    this.isNatural = const Value.absent(),
    this.isUnarmed = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  WeaponTableCompanion.insert({
    required String uuid,
    required String name,
    required String parentUuid,
    this.storedIn = const Value.absent(),
    this.improvements = const Value.absent(),
    this.specialMaterialIndex = const Value.absent(),
    this.price = const Value.absent(),
    this.desc = const Value.absent(),
    required double ocupedSpace,
    required int wieldableIndex,
    required int purposeIndex,
    required int proficiencyIndex,
    required int typeIndex,
    required int rangeIndex,
    required int critical,
    required int criticalMultiplier,
    this.steps = const Value.absent(),
    required String dices,
    this.skillIndexes = const Value.absent(),
    required bool isNatural,
    required bool isUnarmed,
    required int createdAt,
    required int updatedAt,
    this.rowid = const Value.absent(),
  }) : uuid = Value(uuid),
       name = Value(name),
       parentUuid = Value(parentUuid),
       ocupedSpace = Value(ocupedSpace),
       wieldableIndex = Value(wieldableIndex),
       purposeIndex = Value(purposeIndex),
       proficiencyIndex = Value(proficiencyIndex),
       typeIndex = Value(typeIndex),
       rangeIndex = Value(rangeIndex),
       critical = Value(critical),
       criticalMultiplier = Value(criticalMultiplier),
       dices = Value(dices),
       isNatural = Value(isNatural),
       isUnarmed = Value(isUnarmed),
       createdAt = Value(createdAt),
       updatedAt = Value(updatedAt);
  static Insertable<WeaponTableData> custom({
    Expression<String>? uuid,
    Expression<String>? name,
    Expression<String>? parentUuid,
    Expression<String>? storedIn,
    Expression<String>? improvements,
    Expression<int>? specialMaterialIndex,
    Expression<double>? price,
    Expression<String>? desc,
    Expression<double>? ocupedSpace,
    Expression<int>? wieldableIndex,
    Expression<int>? purposeIndex,
    Expression<int>? proficiencyIndex,
    Expression<int>? typeIndex,
    Expression<int>? rangeIndex,
    Expression<int>? critical,
    Expression<int>? criticalMultiplier,
    Expression<int>? steps,
    Expression<String>? dices,
    Expression<String>? skillIndexes,
    Expression<bool>? isNatural,
    Expression<bool>? isUnarmed,
    Expression<int>? createdAt,
    Expression<int>? updatedAt,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (uuid != null) 'uuid': uuid,
      if (name != null) 'name': name,
      if (parentUuid != null) 'parent_uuid': parentUuid,
      if (storedIn != null) 'stored_in': storedIn,
      if (improvements != null) 'improvements': improvements,
      if (specialMaterialIndex != null)
        'special_material_index': specialMaterialIndex,
      if (price != null) 'price': price,
      if (desc != null) 'desc': desc,
      if (ocupedSpace != null) 'ocuped_space': ocupedSpace,
      if (wieldableIndex != null) 'wieldable_index': wieldableIndex,
      if (purposeIndex != null) 'purpose_index': purposeIndex,
      if (proficiencyIndex != null) 'proficiency_index': proficiencyIndex,
      if (typeIndex != null) 'type_index': typeIndex,
      if (rangeIndex != null) 'range_index': rangeIndex,
      if (critical != null) 'critical': critical,
      if (criticalMultiplier != null) 'critical_multiplier': criticalMultiplier,
      if (steps != null) 'steps': steps,
      if (dices != null) 'dices': dices,
      if (skillIndexes != null) 'skill_indexes': skillIndexes,
      if (isNatural != null) 'is_natural': isNatural,
      if (isUnarmed != null) 'is_unarmed': isUnarmed,
      if (createdAt != null) 'created_at': createdAt,
      if (updatedAt != null) 'updated_at': updatedAt,
      if (rowid != null) 'rowid': rowid,
    });
  }

  WeaponTableCompanion copyWith({
    Value<String>? uuid,
    Value<String>? name,
    Value<String>? parentUuid,
    Value<String?>? storedIn,
    Value<String?>? improvements,
    Value<int?>? specialMaterialIndex,
    Value<double?>? price,
    Value<String?>? desc,
    Value<double>? ocupedSpace,
    Value<int>? wieldableIndex,
    Value<int>? purposeIndex,
    Value<int>? proficiencyIndex,
    Value<int>? typeIndex,
    Value<int>? rangeIndex,
    Value<int>? critical,
    Value<int>? criticalMultiplier,
    Value<int?>? steps,
    Value<String>? dices,
    Value<String?>? skillIndexes,
    Value<bool>? isNatural,
    Value<bool>? isUnarmed,
    Value<int>? createdAt,
    Value<int>? updatedAt,
    Value<int>? rowid,
  }) {
    return WeaponTableCompanion(
      uuid: uuid ?? this.uuid,
      name: name ?? this.name,
      parentUuid: parentUuid ?? this.parentUuid,
      storedIn: storedIn ?? this.storedIn,
      improvements: improvements ?? this.improvements,
      specialMaterialIndex: specialMaterialIndex ?? this.specialMaterialIndex,
      price: price ?? this.price,
      desc: desc ?? this.desc,
      ocupedSpace: ocupedSpace ?? this.ocupedSpace,
      wieldableIndex: wieldableIndex ?? this.wieldableIndex,
      purposeIndex: purposeIndex ?? this.purposeIndex,
      proficiencyIndex: proficiencyIndex ?? this.proficiencyIndex,
      typeIndex: typeIndex ?? this.typeIndex,
      rangeIndex: rangeIndex ?? this.rangeIndex,
      critical: critical ?? this.critical,
      criticalMultiplier: criticalMultiplier ?? this.criticalMultiplier,
      steps: steps ?? this.steps,
      dices: dices ?? this.dices,
      skillIndexes: skillIndexes ?? this.skillIndexes,
      isNatural: isNatural ?? this.isNatural,
      isUnarmed: isUnarmed ?? this.isUnarmed,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (uuid.present) {
      map['uuid'] = Variable<String>(uuid.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    if (parentUuid.present) {
      map['parent_uuid'] = Variable<String>(parentUuid.value);
    }
    if (storedIn.present) {
      map['stored_in'] = Variable<String>(storedIn.value);
    }
    if (improvements.present) {
      map['improvements'] = Variable<String>(improvements.value);
    }
    if (specialMaterialIndex.present) {
      map['special_material_index'] = Variable<int>(specialMaterialIndex.value);
    }
    if (price.present) {
      map['price'] = Variable<double>(price.value);
    }
    if (desc.present) {
      map['desc'] = Variable<String>(desc.value);
    }
    if (ocupedSpace.present) {
      map['ocuped_space'] = Variable<double>(ocupedSpace.value);
    }
    if (wieldableIndex.present) {
      map['wieldable_index'] = Variable<int>(wieldableIndex.value);
    }
    if (purposeIndex.present) {
      map['purpose_index'] = Variable<int>(purposeIndex.value);
    }
    if (proficiencyIndex.present) {
      map['proficiency_index'] = Variable<int>(proficiencyIndex.value);
    }
    if (typeIndex.present) {
      map['type_index'] = Variable<int>(typeIndex.value);
    }
    if (rangeIndex.present) {
      map['range_index'] = Variable<int>(rangeIndex.value);
    }
    if (critical.present) {
      map['critical'] = Variable<int>(critical.value);
    }
    if (criticalMultiplier.present) {
      map['critical_multiplier'] = Variable<int>(criticalMultiplier.value);
    }
    if (steps.present) {
      map['steps'] = Variable<int>(steps.value);
    }
    if (dices.present) {
      map['dices'] = Variable<String>(dices.value);
    }
    if (skillIndexes.present) {
      map['skill_indexes'] = Variable<String>(skillIndexes.value);
    }
    if (isNatural.present) {
      map['is_natural'] = Variable<bool>(isNatural.value);
    }
    if (isUnarmed.present) {
      map['is_unarmed'] = Variable<bool>(isUnarmed.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<int>(createdAt.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<int>(updatedAt.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('WeaponTableCompanion(')
          ..write('uuid: $uuid, ')
          ..write('name: $name, ')
          ..write('parentUuid: $parentUuid, ')
          ..write('storedIn: $storedIn, ')
          ..write('improvements: $improvements, ')
          ..write('specialMaterialIndex: $specialMaterialIndex, ')
          ..write('price: $price, ')
          ..write('desc: $desc, ')
          ..write('ocupedSpace: $ocupedSpace, ')
          ..write('wieldableIndex: $wieldableIndex, ')
          ..write('purposeIndex: $purposeIndex, ')
          ..write('proficiencyIndex: $proficiencyIndex, ')
          ..write('typeIndex: $typeIndex, ')
          ..write('rangeIndex: $rangeIndex, ')
          ..write('critical: $critical, ')
          ..write('criticalMultiplier: $criticalMultiplier, ')
          ..write('steps: $steps, ')
          ..write('dices: $dices, ')
          ..write('skillIndexes: $skillIndexes, ')
          ..write('isNatural: $isNatural, ')
          ..write('isUnarmed: $isUnarmed, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $ActionTableTable extends ActionTable
    with TableInfo<$ActionTableTable, ActionTableData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $ActionTableTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _uuidMeta = const VerificationMeta('uuid');
  @override
  late final GeneratedColumn<String> uuid = GeneratedColumn<String>(
    'uuid',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
    'name',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _parentUuidMeta = const VerificationMeta(
    'parentUuid',
  );
  @override
  late final GeneratedColumn<String> parentUuid = GeneratedColumn<String>(
    'parent_uuid',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _descMeta = const VerificationMeta('desc');
  @override
  late final GeneratedColumn<String> desc = GeneratedColumn<String>(
    'desc',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _damageDicesMeta = const VerificationMeta(
    'damageDices',
  );
  @override
  late final GeneratedColumn<String> damageDices = GeneratedColumn<String>(
    'damage_dices',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _extraDamageDicesMeta = const VerificationMeta(
    'extraDamageDices',
  );
  @override
  late final GeneratedColumn<String> extraDamageDices = GeneratedColumn<String>(
    'extra_damage_dices',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _pmMeta = const VerificationMeta('pm');
  @override
  late final GeneratedColumn<int> pm = GeneratedColumn<int>(
    'pm',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _cdMeta = const VerificationMeta('cd');
  @override
  late final GeneratedColumn<int> cd = GeneratedColumn<int>(
    'cd',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _equipamentUuidMeta = const VerificationMeta(
    'equipamentUuid',
  );
  @override
  late final GeneratedColumn<String> equipamentUuid = GeneratedColumn<String>(
    'equipament_uuid',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _mediumDamageValueMeta = const VerificationMeta(
    'mediumDamageValue',
  );
  @override
  late final GeneratedColumn<int> mediumDamageValue = GeneratedColumn<int>(
    'medium_damage_value',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _criticalMeta = const VerificationMeta(
    'critical',
  );
  @override
  late final GeneratedColumn<int> critical = GeneratedColumn<int>(
    'critical',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _criticalMultiplierMeta =
      const VerificationMeta('criticalMultiplier');
  @override
  late final GeneratedColumn<int> criticalMultiplier = GeneratedColumn<int>(
    'critical_multiplier',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _typeIndexMeta = const VerificationMeta(
    'typeIndex',
  );
  @override
  late final GeneratedColumn<int> typeIndex = GeneratedColumn<int>(
    'type_index',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<int> createdAt = GeneratedColumn<int>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _updatedAtMeta = const VerificationMeta(
    'updatedAt',
  );
  @override
  late final GeneratedColumn<int> updatedAt = GeneratedColumn<int>(
    'updated_at',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  @override
  List<GeneratedColumn> get $columns => [
    uuid,
    name,
    parentUuid,
    desc,
    damageDices,
    extraDamageDices,
    pm,
    cd,
    equipamentUuid,
    mediumDamageValue,
    critical,
    criticalMultiplier,
    typeIndex,
    createdAt,
    updatedAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'action_table';
  @override
  VerificationContext validateIntegrity(
    Insertable<ActionTableData> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('uuid')) {
      context.handle(
        _uuidMeta,
        uuid.isAcceptableOrUnknown(data['uuid']!, _uuidMeta),
      );
    } else if (isInserting) {
      context.missing(_uuidMeta);
    }
    if (data.containsKey('name')) {
      context.handle(
        _nameMeta,
        name.isAcceptableOrUnknown(data['name']!, _nameMeta),
      );
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    if (data.containsKey('parent_uuid')) {
      context.handle(
        _parentUuidMeta,
        parentUuid.isAcceptableOrUnknown(data['parent_uuid']!, _parentUuidMeta),
      );
    } else if (isInserting) {
      context.missing(_parentUuidMeta);
    }
    if (data.containsKey('desc')) {
      context.handle(
        _descMeta,
        desc.isAcceptableOrUnknown(data['desc']!, _descMeta),
      );
    } else if (isInserting) {
      context.missing(_descMeta);
    }
    if (data.containsKey('damage_dices')) {
      context.handle(
        _damageDicesMeta,
        damageDices.isAcceptableOrUnknown(
          data['damage_dices']!,
          _damageDicesMeta,
        ),
      );
    }
    if (data.containsKey('extra_damage_dices')) {
      context.handle(
        _extraDamageDicesMeta,
        extraDamageDices.isAcceptableOrUnknown(
          data['extra_damage_dices']!,
          _extraDamageDicesMeta,
        ),
      );
    }
    if (data.containsKey('pm')) {
      context.handle(_pmMeta, pm.isAcceptableOrUnknown(data['pm']!, _pmMeta));
    }
    if (data.containsKey('cd')) {
      context.handle(_cdMeta, cd.isAcceptableOrUnknown(data['cd']!, _cdMeta));
    }
    if (data.containsKey('equipament_uuid')) {
      context.handle(
        _equipamentUuidMeta,
        equipamentUuid.isAcceptableOrUnknown(
          data['equipament_uuid']!,
          _equipamentUuidMeta,
        ),
      );
    }
    if (data.containsKey('medium_damage_value')) {
      context.handle(
        _mediumDamageValueMeta,
        mediumDamageValue.isAcceptableOrUnknown(
          data['medium_damage_value']!,
          _mediumDamageValueMeta,
        ),
      );
    }
    if (data.containsKey('critical')) {
      context.handle(
        _criticalMeta,
        critical.isAcceptableOrUnknown(data['critical']!, _criticalMeta),
      );
    }
    if (data.containsKey('critical_multiplier')) {
      context.handle(
        _criticalMultiplierMeta,
        criticalMultiplier.isAcceptableOrUnknown(
          data['critical_multiplier']!,
          _criticalMultiplierMeta,
        ),
      );
    }
    if (data.containsKey('type_index')) {
      context.handle(
        _typeIndexMeta,
        typeIndex.isAcceptableOrUnknown(data['type_index']!, _typeIndexMeta),
      );
    } else if (isInserting) {
      context.missing(_typeIndexMeta);
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    } else if (isInserting) {
      context.missing(_createdAtMeta);
    }
    if (data.containsKey('updated_at')) {
      context.handle(
        _updatedAtMeta,
        updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta),
      );
    } else if (isInserting) {
      context.missing(_updatedAtMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {uuid};
  @override
  ActionTableData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return ActionTableData(
      uuid: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}uuid'],
      )!,
      name: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}name'],
      )!,
      parentUuid: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}parent_uuid'],
      )!,
      desc: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}desc'],
      )!,
      damageDices: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}damage_dices'],
      ),
      extraDamageDices: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}extra_damage_dices'],
      ),
      pm: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}pm'],
      ),
      cd: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}cd'],
      ),
      equipamentUuid: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}equipament_uuid'],
      ),
      mediumDamageValue: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}medium_damage_value'],
      ),
      critical: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}critical'],
      ),
      criticalMultiplier: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}critical_multiplier'],
      ),
      typeIndex: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}type_index'],
      )!,
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}created_at'],
      )!,
      updatedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}updated_at'],
      )!,
    );
  }

  @override
  $ActionTableTable createAlias(String alias) {
    return $ActionTableTable(attachedDatabase, alias);
  }
}

class ActionTableData extends DataClass implements Insertable<ActionTableData> {
  final String uuid;
  final String name;
  final String parentUuid;
  final String desc;
  final String? damageDices;
  final String? extraDamageDices;
  final int? pm;
  final int? cd;
  final String? equipamentUuid;
  final int? mediumDamageValue;
  final int? critical;
  final int? criticalMultiplier;
  final int typeIndex;
  final int createdAt;
  final int updatedAt;
  const ActionTableData({
    required this.uuid,
    required this.name,
    required this.parentUuid,
    required this.desc,
    this.damageDices,
    this.extraDamageDices,
    this.pm,
    this.cd,
    this.equipamentUuid,
    this.mediumDamageValue,
    this.critical,
    this.criticalMultiplier,
    required this.typeIndex,
    required this.createdAt,
    required this.updatedAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['uuid'] = Variable<String>(uuid);
    map['name'] = Variable<String>(name);
    map['parent_uuid'] = Variable<String>(parentUuid);
    map['desc'] = Variable<String>(desc);
    if (!nullToAbsent || damageDices != null) {
      map['damage_dices'] = Variable<String>(damageDices);
    }
    if (!nullToAbsent || extraDamageDices != null) {
      map['extra_damage_dices'] = Variable<String>(extraDamageDices);
    }
    if (!nullToAbsent || pm != null) {
      map['pm'] = Variable<int>(pm);
    }
    if (!nullToAbsent || cd != null) {
      map['cd'] = Variable<int>(cd);
    }
    if (!nullToAbsent || equipamentUuid != null) {
      map['equipament_uuid'] = Variable<String>(equipamentUuid);
    }
    if (!nullToAbsent || mediumDamageValue != null) {
      map['medium_damage_value'] = Variable<int>(mediumDamageValue);
    }
    if (!nullToAbsent || critical != null) {
      map['critical'] = Variable<int>(critical);
    }
    if (!nullToAbsent || criticalMultiplier != null) {
      map['critical_multiplier'] = Variable<int>(criticalMultiplier);
    }
    map['type_index'] = Variable<int>(typeIndex);
    map['created_at'] = Variable<int>(createdAt);
    map['updated_at'] = Variable<int>(updatedAt);
    return map;
  }

  ActionTableCompanion toCompanion(bool nullToAbsent) {
    return ActionTableCompanion(
      uuid: Value(uuid),
      name: Value(name),
      parentUuid: Value(parentUuid),
      desc: Value(desc),
      damageDices: damageDices == null && nullToAbsent
          ? const Value.absent()
          : Value(damageDices),
      extraDamageDices: extraDamageDices == null && nullToAbsent
          ? const Value.absent()
          : Value(extraDamageDices),
      pm: pm == null && nullToAbsent ? const Value.absent() : Value(pm),
      cd: cd == null && nullToAbsent ? const Value.absent() : Value(cd),
      equipamentUuid: equipamentUuid == null && nullToAbsent
          ? const Value.absent()
          : Value(equipamentUuid),
      mediumDamageValue: mediumDamageValue == null && nullToAbsent
          ? const Value.absent()
          : Value(mediumDamageValue),
      critical: critical == null && nullToAbsent
          ? const Value.absent()
          : Value(critical),
      criticalMultiplier: criticalMultiplier == null && nullToAbsent
          ? const Value.absent()
          : Value(criticalMultiplier),
      typeIndex: Value(typeIndex),
      createdAt: Value(createdAt),
      updatedAt: Value(updatedAt),
    );
  }

  factory ActionTableData.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return ActionTableData(
      uuid: serializer.fromJson<String>(json['uuid']),
      name: serializer.fromJson<String>(json['name']),
      parentUuid: serializer.fromJson<String>(json['parentUuid']),
      desc: serializer.fromJson<String>(json['desc']),
      damageDices: serializer.fromJson<String?>(json['damageDices']),
      extraDamageDices: serializer.fromJson<String?>(json['extraDamageDices']),
      pm: serializer.fromJson<int?>(json['pm']),
      cd: serializer.fromJson<int?>(json['cd']),
      equipamentUuid: serializer.fromJson<String?>(json['equipamentUuid']),
      mediumDamageValue: serializer.fromJson<int?>(json['mediumDamageValue']),
      critical: serializer.fromJson<int?>(json['critical']),
      criticalMultiplier: serializer.fromJson<int?>(json['criticalMultiplier']),
      typeIndex: serializer.fromJson<int>(json['typeIndex']),
      createdAt: serializer.fromJson<int>(json['createdAt']),
      updatedAt: serializer.fromJson<int>(json['updatedAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'uuid': serializer.toJson<String>(uuid),
      'name': serializer.toJson<String>(name),
      'parentUuid': serializer.toJson<String>(parentUuid),
      'desc': serializer.toJson<String>(desc),
      'damageDices': serializer.toJson<String?>(damageDices),
      'extraDamageDices': serializer.toJson<String?>(extraDamageDices),
      'pm': serializer.toJson<int?>(pm),
      'cd': serializer.toJson<int?>(cd),
      'equipamentUuid': serializer.toJson<String?>(equipamentUuid),
      'mediumDamageValue': serializer.toJson<int?>(mediumDamageValue),
      'critical': serializer.toJson<int?>(critical),
      'criticalMultiplier': serializer.toJson<int?>(criticalMultiplier),
      'typeIndex': serializer.toJson<int>(typeIndex),
      'createdAt': serializer.toJson<int>(createdAt),
      'updatedAt': serializer.toJson<int>(updatedAt),
    };
  }

  ActionTableData copyWith({
    String? uuid,
    String? name,
    String? parentUuid,
    String? desc,
    Value<String?> damageDices = const Value.absent(),
    Value<String?> extraDamageDices = const Value.absent(),
    Value<int?> pm = const Value.absent(),
    Value<int?> cd = const Value.absent(),
    Value<String?> equipamentUuid = const Value.absent(),
    Value<int?> mediumDamageValue = const Value.absent(),
    Value<int?> critical = const Value.absent(),
    Value<int?> criticalMultiplier = const Value.absent(),
    int? typeIndex,
    int? createdAt,
    int? updatedAt,
  }) => ActionTableData(
    uuid: uuid ?? this.uuid,
    name: name ?? this.name,
    parentUuid: parentUuid ?? this.parentUuid,
    desc: desc ?? this.desc,
    damageDices: damageDices.present ? damageDices.value : this.damageDices,
    extraDamageDices: extraDamageDices.present
        ? extraDamageDices.value
        : this.extraDamageDices,
    pm: pm.present ? pm.value : this.pm,
    cd: cd.present ? cd.value : this.cd,
    equipamentUuid: equipamentUuid.present
        ? equipamentUuid.value
        : this.equipamentUuid,
    mediumDamageValue: mediumDamageValue.present
        ? mediumDamageValue.value
        : this.mediumDamageValue,
    critical: critical.present ? critical.value : this.critical,
    criticalMultiplier: criticalMultiplier.present
        ? criticalMultiplier.value
        : this.criticalMultiplier,
    typeIndex: typeIndex ?? this.typeIndex,
    createdAt: createdAt ?? this.createdAt,
    updatedAt: updatedAt ?? this.updatedAt,
  );
  ActionTableData copyWithCompanion(ActionTableCompanion data) {
    return ActionTableData(
      uuid: data.uuid.present ? data.uuid.value : this.uuid,
      name: data.name.present ? data.name.value : this.name,
      parentUuid: data.parentUuid.present
          ? data.parentUuid.value
          : this.parentUuid,
      desc: data.desc.present ? data.desc.value : this.desc,
      damageDices: data.damageDices.present
          ? data.damageDices.value
          : this.damageDices,
      extraDamageDices: data.extraDamageDices.present
          ? data.extraDamageDices.value
          : this.extraDamageDices,
      pm: data.pm.present ? data.pm.value : this.pm,
      cd: data.cd.present ? data.cd.value : this.cd,
      equipamentUuid: data.equipamentUuid.present
          ? data.equipamentUuid.value
          : this.equipamentUuid,
      mediumDamageValue: data.mediumDamageValue.present
          ? data.mediumDamageValue.value
          : this.mediumDamageValue,
      critical: data.critical.present ? data.critical.value : this.critical,
      criticalMultiplier: data.criticalMultiplier.present
          ? data.criticalMultiplier.value
          : this.criticalMultiplier,
      typeIndex: data.typeIndex.present ? data.typeIndex.value : this.typeIndex,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('ActionTableData(')
          ..write('uuid: $uuid, ')
          ..write('name: $name, ')
          ..write('parentUuid: $parentUuid, ')
          ..write('desc: $desc, ')
          ..write('damageDices: $damageDices, ')
          ..write('extraDamageDices: $extraDamageDices, ')
          ..write('pm: $pm, ')
          ..write('cd: $cd, ')
          ..write('equipamentUuid: $equipamentUuid, ')
          ..write('mediumDamageValue: $mediumDamageValue, ')
          ..write('critical: $critical, ')
          ..write('criticalMultiplier: $criticalMultiplier, ')
          ..write('typeIndex: $typeIndex, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    uuid,
    name,
    parentUuid,
    desc,
    damageDices,
    extraDamageDices,
    pm,
    cd,
    equipamentUuid,
    mediumDamageValue,
    critical,
    criticalMultiplier,
    typeIndex,
    createdAt,
    updatedAt,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is ActionTableData &&
          other.uuid == this.uuid &&
          other.name == this.name &&
          other.parentUuid == this.parentUuid &&
          other.desc == this.desc &&
          other.damageDices == this.damageDices &&
          other.extraDamageDices == this.extraDamageDices &&
          other.pm == this.pm &&
          other.cd == this.cd &&
          other.equipamentUuid == this.equipamentUuid &&
          other.mediumDamageValue == this.mediumDamageValue &&
          other.critical == this.critical &&
          other.criticalMultiplier == this.criticalMultiplier &&
          other.typeIndex == this.typeIndex &&
          other.createdAt == this.createdAt &&
          other.updatedAt == this.updatedAt);
}

class ActionTableCompanion extends UpdateCompanion<ActionTableData> {
  final Value<String> uuid;
  final Value<String> name;
  final Value<String> parentUuid;
  final Value<String> desc;
  final Value<String?> damageDices;
  final Value<String?> extraDamageDices;
  final Value<int?> pm;
  final Value<int?> cd;
  final Value<String?> equipamentUuid;
  final Value<int?> mediumDamageValue;
  final Value<int?> critical;
  final Value<int?> criticalMultiplier;
  final Value<int> typeIndex;
  final Value<int> createdAt;
  final Value<int> updatedAt;
  final Value<int> rowid;
  const ActionTableCompanion({
    this.uuid = const Value.absent(),
    this.name = const Value.absent(),
    this.parentUuid = const Value.absent(),
    this.desc = const Value.absent(),
    this.damageDices = const Value.absent(),
    this.extraDamageDices = const Value.absent(),
    this.pm = const Value.absent(),
    this.cd = const Value.absent(),
    this.equipamentUuid = const Value.absent(),
    this.mediumDamageValue = const Value.absent(),
    this.critical = const Value.absent(),
    this.criticalMultiplier = const Value.absent(),
    this.typeIndex = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  ActionTableCompanion.insert({
    required String uuid,
    required String name,
    required String parentUuid,
    required String desc,
    this.damageDices = const Value.absent(),
    this.extraDamageDices = const Value.absent(),
    this.pm = const Value.absent(),
    this.cd = const Value.absent(),
    this.equipamentUuid = const Value.absent(),
    this.mediumDamageValue = const Value.absent(),
    this.critical = const Value.absent(),
    this.criticalMultiplier = const Value.absent(),
    required int typeIndex,
    required int createdAt,
    required int updatedAt,
    this.rowid = const Value.absent(),
  }) : uuid = Value(uuid),
       name = Value(name),
       parentUuid = Value(parentUuid),
       desc = Value(desc),
       typeIndex = Value(typeIndex),
       createdAt = Value(createdAt),
       updatedAt = Value(updatedAt);
  static Insertable<ActionTableData> custom({
    Expression<String>? uuid,
    Expression<String>? name,
    Expression<String>? parentUuid,
    Expression<String>? desc,
    Expression<String>? damageDices,
    Expression<String>? extraDamageDices,
    Expression<int>? pm,
    Expression<int>? cd,
    Expression<String>? equipamentUuid,
    Expression<int>? mediumDamageValue,
    Expression<int>? critical,
    Expression<int>? criticalMultiplier,
    Expression<int>? typeIndex,
    Expression<int>? createdAt,
    Expression<int>? updatedAt,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (uuid != null) 'uuid': uuid,
      if (name != null) 'name': name,
      if (parentUuid != null) 'parent_uuid': parentUuid,
      if (desc != null) 'desc': desc,
      if (damageDices != null) 'damage_dices': damageDices,
      if (extraDamageDices != null) 'extra_damage_dices': extraDamageDices,
      if (pm != null) 'pm': pm,
      if (cd != null) 'cd': cd,
      if (equipamentUuid != null) 'equipament_uuid': equipamentUuid,
      if (mediumDamageValue != null) 'medium_damage_value': mediumDamageValue,
      if (critical != null) 'critical': critical,
      if (criticalMultiplier != null) 'critical_multiplier': criticalMultiplier,
      if (typeIndex != null) 'type_index': typeIndex,
      if (createdAt != null) 'created_at': createdAt,
      if (updatedAt != null) 'updated_at': updatedAt,
      if (rowid != null) 'rowid': rowid,
    });
  }

  ActionTableCompanion copyWith({
    Value<String>? uuid,
    Value<String>? name,
    Value<String>? parentUuid,
    Value<String>? desc,
    Value<String?>? damageDices,
    Value<String?>? extraDamageDices,
    Value<int?>? pm,
    Value<int?>? cd,
    Value<String?>? equipamentUuid,
    Value<int?>? mediumDamageValue,
    Value<int?>? critical,
    Value<int?>? criticalMultiplier,
    Value<int>? typeIndex,
    Value<int>? createdAt,
    Value<int>? updatedAt,
    Value<int>? rowid,
  }) {
    return ActionTableCompanion(
      uuid: uuid ?? this.uuid,
      name: name ?? this.name,
      parentUuid: parentUuid ?? this.parentUuid,
      desc: desc ?? this.desc,
      damageDices: damageDices ?? this.damageDices,
      extraDamageDices: extraDamageDices ?? this.extraDamageDices,
      pm: pm ?? this.pm,
      cd: cd ?? this.cd,
      equipamentUuid: equipamentUuid ?? this.equipamentUuid,
      mediumDamageValue: mediumDamageValue ?? this.mediumDamageValue,
      critical: critical ?? this.critical,
      criticalMultiplier: criticalMultiplier ?? this.criticalMultiplier,
      typeIndex: typeIndex ?? this.typeIndex,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (uuid.present) {
      map['uuid'] = Variable<String>(uuid.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    if (parentUuid.present) {
      map['parent_uuid'] = Variable<String>(parentUuid.value);
    }
    if (desc.present) {
      map['desc'] = Variable<String>(desc.value);
    }
    if (damageDices.present) {
      map['damage_dices'] = Variable<String>(damageDices.value);
    }
    if (extraDamageDices.present) {
      map['extra_damage_dices'] = Variable<String>(extraDamageDices.value);
    }
    if (pm.present) {
      map['pm'] = Variable<int>(pm.value);
    }
    if (cd.present) {
      map['cd'] = Variable<int>(cd.value);
    }
    if (equipamentUuid.present) {
      map['equipament_uuid'] = Variable<String>(equipamentUuid.value);
    }
    if (mediumDamageValue.present) {
      map['medium_damage_value'] = Variable<int>(mediumDamageValue.value);
    }
    if (critical.present) {
      map['critical'] = Variable<int>(critical.value);
    }
    if (criticalMultiplier.present) {
      map['critical_multiplier'] = Variable<int>(criticalMultiplier.value);
    }
    if (typeIndex.present) {
      map['type_index'] = Variable<int>(typeIndex.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<int>(createdAt.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<int>(updatedAt.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('ActionTableCompanion(')
          ..write('uuid: $uuid, ')
          ..write('name: $name, ')
          ..write('parentUuid: $parentUuid, ')
          ..write('desc: $desc, ')
          ..write('damageDices: $damageDices, ')
          ..write('extraDamageDices: $extraDamageDices, ')
          ..write('pm: $pm, ')
          ..write('cd: $cd, ')
          ..write('equipamentUuid: $equipamentUuid, ')
          ..write('mediumDamageValue: $mediumDamageValue, ')
          ..write('critical: $critical, ')
          ..write('criticalMultiplier: $criticalMultiplier, ')
          ..write('typeIndex: $typeIndex, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $ActionHandToHandTableTable extends ActionHandToHandTable
    with TableInfo<$ActionHandToHandTableTable, ActionHandToHandTableData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $ActionHandToHandTableTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _uuidMeta = const VerificationMeta('uuid');
  @override
  late final GeneratedColumn<String> uuid = GeneratedColumn<String>(
    'uuid',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
    'name',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _parentUuidMeta = const VerificationMeta(
    'parentUuid',
  );
  @override
  late final GeneratedColumn<String> parentUuid = GeneratedColumn<String>(
    'parent_uuid',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _descMeta = const VerificationMeta('desc');
  @override
  late final GeneratedColumn<String> desc = GeneratedColumn<String>(
    'desc',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _damageDicesMeta = const VerificationMeta(
    'damageDices',
  );
  @override
  late final GeneratedColumn<String> damageDices = GeneratedColumn<String>(
    'damage_dices',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _extraDamageDicesMeta = const VerificationMeta(
    'extraDamageDices',
  );
  @override
  late final GeneratedColumn<String> extraDamageDices = GeneratedColumn<String>(
    'extra_damage_dices',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _pmMeta = const VerificationMeta('pm');
  @override
  late final GeneratedColumn<int> pm = GeneratedColumn<int>(
    'pm',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _cdMeta = const VerificationMeta('cd');
  @override
  late final GeneratedColumn<int> cd = GeneratedColumn<int>(
    'cd',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _equipamentUuidMeta = const VerificationMeta(
    'equipamentUuid',
  );
  @override
  late final GeneratedColumn<String> equipamentUuid = GeneratedColumn<String>(
    'equipament_uuid',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _mediumDamageValueMeta = const VerificationMeta(
    'mediumDamageValue',
  );
  @override
  late final GeneratedColumn<int> mediumDamageValue = GeneratedColumn<int>(
    'medium_damage_value',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _criticalMeta = const VerificationMeta(
    'critical',
  );
  @override
  late final GeneratedColumn<int> critical = GeneratedColumn<int>(
    'critical',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _criticalMultiplierMeta =
      const VerificationMeta('criticalMultiplier');
  @override
  late final GeneratedColumn<int> criticalMultiplier = GeneratedColumn<int>(
    'critical_multiplier',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _typeIndexMeta = const VerificationMeta(
    'typeIndex',
  );
  @override
  late final GeneratedColumn<int> typeIndex = GeneratedColumn<int>(
    'type_index',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<int> createdAt = GeneratedColumn<int>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _updatedAtMeta = const VerificationMeta(
    'updatedAt',
  );
  @override
  late final GeneratedColumn<int> updatedAt = GeneratedColumn<int>(
    'updated_at',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  @override
  List<GeneratedColumn> get $columns => [
    uuid,
    name,
    parentUuid,
    desc,
    damageDices,
    extraDamageDices,
    pm,
    cd,
    equipamentUuid,
    mediumDamageValue,
    critical,
    criticalMultiplier,
    typeIndex,
    createdAt,
    updatedAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'action_hand_to_hand_table';
  @override
  VerificationContext validateIntegrity(
    Insertable<ActionHandToHandTableData> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('uuid')) {
      context.handle(
        _uuidMeta,
        uuid.isAcceptableOrUnknown(data['uuid']!, _uuidMeta),
      );
    } else if (isInserting) {
      context.missing(_uuidMeta);
    }
    if (data.containsKey('name')) {
      context.handle(
        _nameMeta,
        name.isAcceptableOrUnknown(data['name']!, _nameMeta),
      );
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    if (data.containsKey('parent_uuid')) {
      context.handle(
        _parentUuidMeta,
        parentUuid.isAcceptableOrUnknown(data['parent_uuid']!, _parentUuidMeta),
      );
    } else if (isInserting) {
      context.missing(_parentUuidMeta);
    }
    if (data.containsKey('desc')) {
      context.handle(
        _descMeta,
        desc.isAcceptableOrUnknown(data['desc']!, _descMeta),
      );
    } else if (isInserting) {
      context.missing(_descMeta);
    }
    if (data.containsKey('damage_dices')) {
      context.handle(
        _damageDicesMeta,
        damageDices.isAcceptableOrUnknown(
          data['damage_dices']!,
          _damageDicesMeta,
        ),
      );
    }
    if (data.containsKey('extra_damage_dices')) {
      context.handle(
        _extraDamageDicesMeta,
        extraDamageDices.isAcceptableOrUnknown(
          data['extra_damage_dices']!,
          _extraDamageDicesMeta,
        ),
      );
    }
    if (data.containsKey('pm')) {
      context.handle(_pmMeta, pm.isAcceptableOrUnknown(data['pm']!, _pmMeta));
    }
    if (data.containsKey('cd')) {
      context.handle(_cdMeta, cd.isAcceptableOrUnknown(data['cd']!, _cdMeta));
    }
    if (data.containsKey('equipament_uuid')) {
      context.handle(
        _equipamentUuidMeta,
        equipamentUuid.isAcceptableOrUnknown(
          data['equipament_uuid']!,
          _equipamentUuidMeta,
        ),
      );
    }
    if (data.containsKey('medium_damage_value')) {
      context.handle(
        _mediumDamageValueMeta,
        mediumDamageValue.isAcceptableOrUnknown(
          data['medium_damage_value']!,
          _mediumDamageValueMeta,
        ),
      );
    }
    if (data.containsKey('critical')) {
      context.handle(
        _criticalMeta,
        critical.isAcceptableOrUnknown(data['critical']!, _criticalMeta),
      );
    }
    if (data.containsKey('critical_multiplier')) {
      context.handle(
        _criticalMultiplierMeta,
        criticalMultiplier.isAcceptableOrUnknown(
          data['critical_multiplier']!,
          _criticalMultiplierMeta,
        ),
      );
    }
    if (data.containsKey('type_index')) {
      context.handle(
        _typeIndexMeta,
        typeIndex.isAcceptableOrUnknown(data['type_index']!, _typeIndexMeta),
      );
    } else if (isInserting) {
      context.missing(_typeIndexMeta);
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    } else if (isInserting) {
      context.missing(_createdAtMeta);
    }
    if (data.containsKey('updated_at')) {
      context.handle(
        _updatedAtMeta,
        updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta),
      );
    } else if (isInserting) {
      context.missing(_updatedAtMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {uuid};
  @override
  ActionHandToHandTableData map(
    Map<String, dynamic> data, {
    String? tablePrefix,
  }) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return ActionHandToHandTableData(
      uuid: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}uuid'],
      )!,
      name: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}name'],
      )!,
      parentUuid: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}parent_uuid'],
      )!,
      desc: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}desc'],
      )!,
      damageDices: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}damage_dices'],
      ),
      extraDamageDices: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}extra_damage_dices'],
      ),
      pm: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}pm'],
      ),
      cd: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}cd'],
      ),
      equipamentUuid: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}equipament_uuid'],
      ),
      mediumDamageValue: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}medium_damage_value'],
      ),
      critical: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}critical'],
      ),
      criticalMultiplier: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}critical_multiplier'],
      ),
      typeIndex: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}type_index'],
      )!,
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}created_at'],
      )!,
      updatedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}updated_at'],
      )!,
    );
  }

  @override
  $ActionHandToHandTableTable createAlias(String alias) {
    return $ActionHandToHandTableTable(attachedDatabase, alias);
  }
}

class ActionHandToHandTableData extends DataClass
    implements Insertable<ActionHandToHandTableData> {
  final String uuid;
  final String name;
  final String parentUuid;
  final String desc;
  final String? damageDices;
  final String? extraDamageDices;
  final int? pm;
  final int? cd;
  final String? equipamentUuid;
  final int? mediumDamageValue;
  final int? critical;
  final int? criticalMultiplier;
  final int typeIndex;
  final int createdAt;
  final int updatedAt;
  const ActionHandToHandTableData({
    required this.uuid,
    required this.name,
    required this.parentUuid,
    required this.desc,
    this.damageDices,
    this.extraDamageDices,
    this.pm,
    this.cd,
    this.equipamentUuid,
    this.mediumDamageValue,
    this.critical,
    this.criticalMultiplier,
    required this.typeIndex,
    required this.createdAt,
    required this.updatedAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['uuid'] = Variable<String>(uuid);
    map['name'] = Variable<String>(name);
    map['parent_uuid'] = Variable<String>(parentUuid);
    map['desc'] = Variable<String>(desc);
    if (!nullToAbsent || damageDices != null) {
      map['damage_dices'] = Variable<String>(damageDices);
    }
    if (!nullToAbsent || extraDamageDices != null) {
      map['extra_damage_dices'] = Variable<String>(extraDamageDices);
    }
    if (!nullToAbsent || pm != null) {
      map['pm'] = Variable<int>(pm);
    }
    if (!nullToAbsent || cd != null) {
      map['cd'] = Variable<int>(cd);
    }
    if (!nullToAbsent || equipamentUuid != null) {
      map['equipament_uuid'] = Variable<String>(equipamentUuid);
    }
    if (!nullToAbsent || mediumDamageValue != null) {
      map['medium_damage_value'] = Variable<int>(mediumDamageValue);
    }
    if (!nullToAbsent || critical != null) {
      map['critical'] = Variable<int>(critical);
    }
    if (!nullToAbsent || criticalMultiplier != null) {
      map['critical_multiplier'] = Variable<int>(criticalMultiplier);
    }
    map['type_index'] = Variable<int>(typeIndex);
    map['created_at'] = Variable<int>(createdAt);
    map['updated_at'] = Variable<int>(updatedAt);
    return map;
  }

  ActionHandToHandTableCompanion toCompanion(bool nullToAbsent) {
    return ActionHandToHandTableCompanion(
      uuid: Value(uuid),
      name: Value(name),
      parentUuid: Value(parentUuid),
      desc: Value(desc),
      damageDices: damageDices == null && nullToAbsent
          ? const Value.absent()
          : Value(damageDices),
      extraDamageDices: extraDamageDices == null && nullToAbsent
          ? const Value.absent()
          : Value(extraDamageDices),
      pm: pm == null && nullToAbsent ? const Value.absent() : Value(pm),
      cd: cd == null && nullToAbsent ? const Value.absent() : Value(cd),
      equipamentUuid: equipamentUuid == null && nullToAbsent
          ? const Value.absent()
          : Value(equipamentUuid),
      mediumDamageValue: mediumDamageValue == null && nullToAbsent
          ? const Value.absent()
          : Value(mediumDamageValue),
      critical: critical == null && nullToAbsent
          ? const Value.absent()
          : Value(critical),
      criticalMultiplier: criticalMultiplier == null && nullToAbsent
          ? const Value.absent()
          : Value(criticalMultiplier),
      typeIndex: Value(typeIndex),
      createdAt: Value(createdAt),
      updatedAt: Value(updatedAt),
    );
  }

  factory ActionHandToHandTableData.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return ActionHandToHandTableData(
      uuid: serializer.fromJson<String>(json['uuid']),
      name: serializer.fromJson<String>(json['name']),
      parentUuid: serializer.fromJson<String>(json['parentUuid']),
      desc: serializer.fromJson<String>(json['desc']),
      damageDices: serializer.fromJson<String?>(json['damageDices']),
      extraDamageDices: serializer.fromJson<String?>(json['extraDamageDices']),
      pm: serializer.fromJson<int?>(json['pm']),
      cd: serializer.fromJson<int?>(json['cd']),
      equipamentUuid: serializer.fromJson<String?>(json['equipamentUuid']),
      mediumDamageValue: serializer.fromJson<int?>(json['mediumDamageValue']),
      critical: serializer.fromJson<int?>(json['critical']),
      criticalMultiplier: serializer.fromJson<int?>(json['criticalMultiplier']),
      typeIndex: serializer.fromJson<int>(json['typeIndex']),
      createdAt: serializer.fromJson<int>(json['createdAt']),
      updatedAt: serializer.fromJson<int>(json['updatedAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'uuid': serializer.toJson<String>(uuid),
      'name': serializer.toJson<String>(name),
      'parentUuid': serializer.toJson<String>(parentUuid),
      'desc': serializer.toJson<String>(desc),
      'damageDices': serializer.toJson<String?>(damageDices),
      'extraDamageDices': serializer.toJson<String?>(extraDamageDices),
      'pm': serializer.toJson<int?>(pm),
      'cd': serializer.toJson<int?>(cd),
      'equipamentUuid': serializer.toJson<String?>(equipamentUuid),
      'mediumDamageValue': serializer.toJson<int?>(mediumDamageValue),
      'critical': serializer.toJson<int?>(critical),
      'criticalMultiplier': serializer.toJson<int?>(criticalMultiplier),
      'typeIndex': serializer.toJson<int>(typeIndex),
      'createdAt': serializer.toJson<int>(createdAt),
      'updatedAt': serializer.toJson<int>(updatedAt),
    };
  }

  ActionHandToHandTableData copyWith({
    String? uuid,
    String? name,
    String? parentUuid,
    String? desc,
    Value<String?> damageDices = const Value.absent(),
    Value<String?> extraDamageDices = const Value.absent(),
    Value<int?> pm = const Value.absent(),
    Value<int?> cd = const Value.absent(),
    Value<String?> equipamentUuid = const Value.absent(),
    Value<int?> mediumDamageValue = const Value.absent(),
    Value<int?> critical = const Value.absent(),
    Value<int?> criticalMultiplier = const Value.absent(),
    int? typeIndex,
    int? createdAt,
    int? updatedAt,
  }) => ActionHandToHandTableData(
    uuid: uuid ?? this.uuid,
    name: name ?? this.name,
    parentUuid: parentUuid ?? this.parentUuid,
    desc: desc ?? this.desc,
    damageDices: damageDices.present ? damageDices.value : this.damageDices,
    extraDamageDices: extraDamageDices.present
        ? extraDamageDices.value
        : this.extraDamageDices,
    pm: pm.present ? pm.value : this.pm,
    cd: cd.present ? cd.value : this.cd,
    equipamentUuid: equipamentUuid.present
        ? equipamentUuid.value
        : this.equipamentUuid,
    mediumDamageValue: mediumDamageValue.present
        ? mediumDamageValue.value
        : this.mediumDamageValue,
    critical: critical.present ? critical.value : this.critical,
    criticalMultiplier: criticalMultiplier.present
        ? criticalMultiplier.value
        : this.criticalMultiplier,
    typeIndex: typeIndex ?? this.typeIndex,
    createdAt: createdAt ?? this.createdAt,
    updatedAt: updatedAt ?? this.updatedAt,
  );
  ActionHandToHandTableData copyWithCompanion(
    ActionHandToHandTableCompanion data,
  ) {
    return ActionHandToHandTableData(
      uuid: data.uuid.present ? data.uuid.value : this.uuid,
      name: data.name.present ? data.name.value : this.name,
      parentUuid: data.parentUuid.present
          ? data.parentUuid.value
          : this.parentUuid,
      desc: data.desc.present ? data.desc.value : this.desc,
      damageDices: data.damageDices.present
          ? data.damageDices.value
          : this.damageDices,
      extraDamageDices: data.extraDamageDices.present
          ? data.extraDamageDices.value
          : this.extraDamageDices,
      pm: data.pm.present ? data.pm.value : this.pm,
      cd: data.cd.present ? data.cd.value : this.cd,
      equipamentUuid: data.equipamentUuid.present
          ? data.equipamentUuid.value
          : this.equipamentUuid,
      mediumDamageValue: data.mediumDamageValue.present
          ? data.mediumDamageValue.value
          : this.mediumDamageValue,
      critical: data.critical.present ? data.critical.value : this.critical,
      criticalMultiplier: data.criticalMultiplier.present
          ? data.criticalMultiplier.value
          : this.criticalMultiplier,
      typeIndex: data.typeIndex.present ? data.typeIndex.value : this.typeIndex,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('ActionHandToHandTableData(')
          ..write('uuid: $uuid, ')
          ..write('name: $name, ')
          ..write('parentUuid: $parentUuid, ')
          ..write('desc: $desc, ')
          ..write('damageDices: $damageDices, ')
          ..write('extraDamageDices: $extraDamageDices, ')
          ..write('pm: $pm, ')
          ..write('cd: $cd, ')
          ..write('equipamentUuid: $equipamentUuid, ')
          ..write('mediumDamageValue: $mediumDamageValue, ')
          ..write('critical: $critical, ')
          ..write('criticalMultiplier: $criticalMultiplier, ')
          ..write('typeIndex: $typeIndex, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    uuid,
    name,
    parentUuid,
    desc,
    damageDices,
    extraDamageDices,
    pm,
    cd,
    equipamentUuid,
    mediumDamageValue,
    critical,
    criticalMultiplier,
    typeIndex,
    createdAt,
    updatedAt,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is ActionHandToHandTableData &&
          other.uuid == this.uuid &&
          other.name == this.name &&
          other.parentUuid == this.parentUuid &&
          other.desc == this.desc &&
          other.damageDices == this.damageDices &&
          other.extraDamageDices == this.extraDamageDices &&
          other.pm == this.pm &&
          other.cd == this.cd &&
          other.equipamentUuid == this.equipamentUuid &&
          other.mediumDamageValue == this.mediumDamageValue &&
          other.critical == this.critical &&
          other.criticalMultiplier == this.criticalMultiplier &&
          other.typeIndex == this.typeIndex &&
          other.createdAt == this.createdAt &&
          other.updatedAt == this.updatedAt);
}

class ActionHandToHandTableCompanion
    extends UpdateCompanion<ActionHandToHandTableData> {
  final Value<String> uuid;
  final Value<String> name;
  final Value<String> parentUuid;
  final Value<String> desc;
  final Value<String?> damageDices;
  final Value<String?> extraDamageDices;
  final Value<int?> pm;
  final Value<int?> cd;
  final Value<String?> equipamentUuid;
  final Value<int?> mediumDamageValue;
  final Value<int?> critical;
  final Value<int?> criticalMultiplier;
  final Value<int> typeIndex;
  final Value<int> createdAt;
  final Value<int> updatedAt;
  final Value<int> rowid;
  const ActionHandToHandTableCompanion({
    this.uuid = const Value.absent(),
    this.name = const Value.absent(),
    this.parentUuid = const Value.absent(),
    this.desc = const Value.absent(),
    this.damageDices = const Value.absent(),
    this.extraDamageDices = const Value.absent(),
    this.pm = const Value.absent(),
    this.cd = const Value.absent(),
    this.equipamentUuid = const Value.absent(),
    this.mediumDamageValue = const Value.absent(),
    this.critical = const Value.absent(),
    this.criticalMultiplier = const Value.absent(),
    this.typeIndex = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  ActionHandToHandTableCompanion.insert({
    required String uuid,
    required String name,
    required String parentUuid,
    required String desc,
    this.damageDices = const Value.absent(),
    this.extraDamageDices = const Value.absent(),
    this.pm = const Value.absent(),
    this.cd = const Value.absent(),
    this.equipamentUuid = const Value.absent(),
    this.mediumDamageValue = const Value.absent(),
    this.critical = const Value.absent(),
    this.criticalMultiplier = const Value.absent(),
    required int typeIndex,
    required int createdAt,
    required int updatedAt,
    this.rowid = const Value.absent(),
  }) : uuid = Value(uuid),
       name = Value(name),
       parentUuid = Value(parentUuid),
       desc = Value(desc),
       typeIndex = Value(typeIndex),
       createdAt = Value(createdAt),
       updatedAt = Value(updatedAt);
  static Insertable<ActionHandToHandTableData> custom({
    Expression<String>? uuid,
    Expression<String>? name,
    Expression<String>? parentUuid,
    Expression<String>? desc,
    Expression<String>? damageDices,
    Expression<String>? extraDamageDices,
    Expression<int>? pm,
    Expression<int>? cd,
    Expression<String>? equipamentUuid,
    Expression<int>? mediumDamageValue,
    Expression<int>? critical,
    Expression<int>? criticalMultiplier,
    Expression<int>? typeIndex,
    Expression<int>? createdAt,
    Expression<int>? updatedAt,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (uuid != null) 'uuid': uuid,
      if (name != null) 'name': name,
      if (parentUuid != null) 'parent_uuid': parentUuid,
      if (desc != null) 'desc': desc,
      if (damageDices != null) 'damage_dices': damageDices,
      if (extraDamageDices != null) 'extra_damage_dices': extraDamageDices,
      if (pm != null) 'pm': pm,
      if (cd != null) 'cd': cd,
      if (equipamentUuid != null) 'equipament_uuid': equipamentUuid,
      if (mediumDamageValue != null) 'medium_damage_value': mediumDamageValue,
      if (critical != null) 'critical': critical,
      if (criticalMultiplier != null) 'critical_multiplier': criticalMultiplier,
      if (typeIndex != null) 'type_index': typeIndex,
      if (createdAt != null) 'created_at': createdAt,
      if (updatedAt != null) 'updated_at': updatedAt,
      if (rowid != null) 'rowid': rowid,
    });
  }

  ActionHandToHandTableCompanion copyWith({
    Value<String>? uuid,
    Value<String>? name,
    Value<String>? parentUuid,
    Value<String>? desc,
    Value<String?>? damageDices,
    Value<String?>? extraDamageDices,
    Value<int?>? pm,
    Value<int?>? cd,
    Value<String?>? equipamentUuid,
    Value<int?>? mediumDamageValue,
    Value<int?>? critical,
    Value<int?>? criticalMultiplier,
    Value<int>? typeIndex,
    Value<int>? createdAt,
    Value<int>? updatedAt,
    Value<int>? rowid,
  }) {
    return ActionHandToHandTableCompanion(
      uuid: uuid ?? this.uuid,
      name: name ?? this.name,
      parentUuid: parentUuid ?? this.parentUuid,
      desc: desc ?? this.desc,
      damageDices: damageDices ?? this.damageDices,
      extraDamageDices: extraDamageDices ?? this.extraDamageDices,
      pm: pm ?? this.pm,
      cd: cd ?? this.cd,
      equipamentUuid: equipamentUuid ?? this.equipamentUuid,
      mediumDamageValue: mediumDamageValue ?? this.mediumDamageValue,
      critical: critical ?? this.critical,
      criticalMultiplier: criticalMultiplier ?? this.criticalMultiplier,
      typeIndex: typeIndex ?? this.typeIndex,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (uuid.present) {
      map['uuid'] = Variable<String>(uuid.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    if (parentUuid.present) {
      map['parent_uuid'] = Variable<String>(parentUuid.value);
    }
    if (desc.present) {
      map['desc'] = Variable<String>(desc.value);
    }
    if (damageDices.present) {
      map['damage_dices'] = Variable<String>(damageDices.value);
    }
    if (extraDamageDices.present) {
      map['extra_damage_dices'] = Variable<String>(extraDamageDices.value);
    }
    if (pm.present) {
      map['pm'] = Variable<int>(pm.value);
    }
    if (cd.present) {
      map['cd'] = Variable<int>(cd.value);
    }
    if (equipamentUuid.present) {
      map['equipament_uuid'] = Variable<String>(equipamentUuid.value);
    }
    if (mediumDamageValue.present) {
      map['medium_damage_value'] = Variable<int>(mediumDamageValue.value);
    }
    if (critical.present) {
      map['critical'] = Variable<int>(critical.value);
    }
    if (criticalMultiplier.present) {
      map['critical_multiplier'] = Variable<int>(criticalMultiplier.value);
    }
    if (typeIndex.present) {
      map['type_index'] = Variable<int>(typeIndex.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<int>(createdAt.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<int>(updatedAt.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('ActionHandToHandTableCompanion(')
          ..write('uuid: $uuid, ')
          ..write('name: $name, ')
          ..write('parentUuid: $parentUuid, ')
          ..write('desc: $desc, ')
          ..write('damageDices: $damageDices, ')
          ..write('extraDamageDices: $extraDamageDices, ')
          ..write('pm: $pm, ')
          ..write('cd: $cd, ')
          ..write('equipamentUuid: $equipamentUuid, ')
          ..write('mediumDamageValue: $mediumDamageValue, ')
          ..write('critical: $critical, ')
          ..write('criticalMultiplier: $criticalMultiplier, ')
          ..write('typeIndex: $typeIndex, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $ActionDistanceAttackTableTable extends ActionDistanceAttackTable
    with
        TableInfo<
          $ActionDistanceAttackTableTable,
          ActionDistanceAttackTableData
        > {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $ActionDistanceAttackTableTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _uuidMeta = const VerificationMeta('uuid');
  @override
  late final GeneratedColumn<String> uuid = GeneratedColumn<String>(
    'uuid',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
    'name',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _parentUuidMeta = const VerificationMeta(
    'parentUuid',
  );
  @override
  late final GeneratedColumn<String> parentUuid = GeneratedColumn<String>(
    'parent_uuid',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _descMeta = const VerificationMeta('desc');
  @override
  late final GeneratedColumn<String> desc = GeneratedColumn<String>(
    'desc',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _damageDicesMeta = const VerificationMeta(
    'damageDices',
  );
  @override
  late final GeneratedColumn<String> damageDices = GeneratedColumn<String>(
    'damage_dices',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _extraDamageDicesMeta = const VerificationMeta(
    'extraDamageDices',
  );
  @override
  late final GeneratedColumn<String> extraDamageDices = GeneratedColumn<String>(
    'extra_damage_dices',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _pmMeta = const VerificationMeta('pm');
  @override
  late final GeneratedColumn<int> pm = GeneratedColumn<int>(
    'pm',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _cdMeta = const VerificationMeta('cd');
  @override
  late final GeneratedColumn<int> cd = GeneratedColumn<int>(
    'cd',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _equipamentUuidMeta = const VerificationMeta(
    'equipamentUuid',
  );
  @override
  late final GeneratedColumn<String> equipamentUuid = GeneratedColumn<String>(
    'equipament_uuid',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _mediumDamageValueMeta = const VerificationMeta(
    'mediumDamageValue',
  );
  @override
  late final GeneratedColumn<int> mediumDamageValue = GeneratedColumn<int>(
    'medium_damage_value',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _criticalMeta = const VerificationMeta(
    'critical',
  );
  @override
  late final GeneratedColumn<int> critical = GeneratedColumn<int>(
    'critical',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _criticalMultiplierMeta =
      const VerificationMeta('criticalMultiplier');
  @override
  late final GeneratedColumn<int> criticalMultiplier = GeneratedColumn<int>(
    'critical_multiplier',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _typeIndexMeta = const VerificationMeta(
    'typeIndex',
  );
  @override
  late final GeneratedColumn<int> typeIndex = GeneratedColumn<int>(
    'type_index',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<int> createdAt = GeneratedColumn<int>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _updatedAtMeta = const VerificationMeta(
    'updatedAt',
  );
  @override
  late final GeneratedColumn<int> updatedAt = GeneratedColumn<int>(
    'updated_at',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  @override
  List<GeneratedColumn> get $columns => [
    uuid,
    name,
    parentUuid,
    desc,
    damageDices,
    extraDamageDices,
    pm,
    cd,
    equipamentUuid,
    mediumDamageValue,
    critical,
    criticalMultiplier,
    typeIndex,
    createdAt,
    updatedAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'action_distance_attack_table';
  @override
  VerificationContext validateIntegrity(
    Insertable<ActionDistanceAttackTableData> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('uuid')) {
      context.handle(
        _uuidMeta,
        uuid.isAcceptableOrUnknown(data['uuid']!, _uuidMeta),
      );
    } else if (isInserting) {
      context.missing(_uuidMeta);
    }
    if (data.containsKey('name')) {
      context.handle(
        _nameMeta,
        name.isAcceptableOrUnknown(data['name']!, _nameMeta),
      );
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    if (data.containsKey('parent_uuid')) {
      context.handle(
        _parentUuidMeta,
        parentUuid.isAcceptableOrUnknown(data['parent_uuid']!, _parentUuidMeta),
      );
    } else if (isInserting) {
      context.missing(_parentUuidMeta);
    }
    if (data.containsKey('desc')) {
      context.handle(
        _descMeta,
        desc.isAcceptableOrUnknown(data['desc']!, _descMeta),
      );
    } else if (isInserting) {
      context.missing(_descMeta);
    }
    if (data.containsKey('damage_dices')) {
      context.handle(
        _damageDicesMeta,
        damageDices.isAcceptableOrUnknown(
          data['damage_dices']!,
          _damageDicesMeta,
        ),
      );
    }
    if (data.containsKey('extra_damage_dices')) {
      context.handle(
        _extraDamageDicesMeta,
        extraDamageDices.isAcceptableOrUnknown(
          data['extra_damage_dices']!,
          _extraDamageDicesMeta,
        ),
      );
    }
    if (data.containsKey('pm')) {
      context.handle(_pmMeta, pm.isAcceptableOrUnknown(data['pm']!, _pmMeta));
    }
    if (data.containsKey('cd')) {
      context.handle(_cdMeta, cd.isAcceptableOrUnknown(data['cd']!, _cdMeta));
    }
    if (data.containsKey('equipament_uuid')) {
      context.handle(
        _equipamentUuidMeta,
        equipamentUuid.isAcceptableOrUnknown(
          data['equipament_uuid']!,
          _equipamentUuidMeta,
        ),
      );
    }
    if (data.containsKey('medium_damage_value')) {
      context.handle(
        _mediumDamageValueMeta,
        mediumDamageValue.isAcceptableOrUnknown(
          data['medium_damage_value']!,
          _mediumDamageValueMeta,
        ),
      );
    }
    if (data.containsKey('critical')) {
      context.handle(
        _criticalMeta,
        critical.isAcceptableOrUnknown(data['critical']!, _criticalMeta),
      );
    }
    if (data.containsKey('critical_multiplier')) {
      context.handle(
        _criticalMultiplierMeta,
        criticalMultiplier.isAcceptableOrUnknown(
          data['critical_multiplier']!,
          _criticalMultiplierMeta,
        ),
      );
    }
    if (data.containsKey('type_index')) {
      context.handle(
        _typeIndexMeta,
        typeIndex.isAcceptableOrUnknown(data['type_index']!, _typeIndexMeta),
      );
    } else if (isInserting) {
      context.missing(_typeIndexMeta);
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    } else if (isInserting) {
      context.missing(_createdAtMeta);
    }
    if (data.containsKey('updated_at')) {
      context.handle(
        _updatedAtMeta,
        updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta),
      );
    } else if (isInserting) {
      context.missing(_updatedAtMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {uuid};
  @override
  ActionDistanceAttackTableData map(
    Map<String, dynamic> data, {
    String? tablePrefix,
  }) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return ActionDistanceAttackTableData(
      uuid: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}uuid'],
      )!,
      name: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}name'],
      )!,
      parentUuid: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}parent_uuid'],
      )!,
      desc: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}desc'],
      )!,
      damageDices: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}damage_dices'],
      ),
      extraDamageDices: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}extra_damage_dices'],
      ),
      pm: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}pm'],
      ),
      cd: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}cd'],
      ),
      equipamentUuid: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}equipament_uuid'],
      ),
      mediumDamageValue: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}medium_damage_value'],
      ),
      critical: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}critical'],
      ),
      criticalMultiplier: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}critical_multiplier'],
      ),
      typeIndex: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}type_index'],
      )!,
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}created_at'],
      )!,
      updatedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}updated_at'],
      )!,
    );
  }

  @override
  $ActionDistanceAttackTableTable createAlias(String alias) {
    return $ActionDistanceAttackTableTable(attachedDatabase, alias);
  }
}

class ActionDistanceAttackTableData extends DataClass
    implements Insertable<ActionDistanceAttackTableData> {
  final String uuid;
  final String name;
  final String parentUuid;
  final String desc;
  final String? damageDices;
  final String? extraDamageDices;
  final int? pm;
  final int? cd;
  final String? equipamentUuid;
  final int? mediumDamageValue;
  final int? critical;
  final int? criticalMultiplier;
  final int typeIndex;
  final int createdAt;
  final int updatedAt;
  const ActionDistanceAttackTableData({
    required this.uuid,
    required this.name,
    required this.parentUuid,
    required this.desc,
    this.damageDices,
    this.extraDamageDices,
    this.pm,
    this.cd,
    this.equipamentUuid,
    this.mediumDamageValue,
    this.critical,
    this.criticalMultiplier,
    required this.typeIndex,
    required this.createdAt,
    required this.updatedAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['uuid'] = Variable<String>(uuid);
    map['name'] = Variable<String>(name);
    map['parent_uuid'] = Variable<String>(parentUuid);
    map['desc'] = Variable<String>(desc);
    if (!nullToAbsent || damageDices != null) {
      map['damage_dices'] = Variable<String>(damageDices);
    }
    if (!nullToAbsent || extraDamageDices != null) {
      map['extra_damage_dices'] = Variable<String>(extraDamageDices);
    }
    if (!nullToAbsent || pm != null) {
      map['pm'] = Variable<int>(pm);
    }
    if (!nullToAbsent || cd != null) {
      map['cd'] = Variable<int>(cd);
    }
    if (!nullToAbsent || equipamentUuid != null) {
      map['equipament_uuid'] = Variable<String>(equipamentUuid);
    }
    if (!nullToAbsent || mediumDamageValue != null) {
      map['medium_damage_value'] = Variable<int>(mediumDamageValue);
    }
    if (!nullToAbsent || critical != null) {
      map['critical'] = Variable<int>(critical);
    }
    if (!nullToAbsent || criticalMultiplier != null) {
      map['critical_multiplier'] = Variable<int>(criticalMultiplier);
    }
    map['type_index'] = Variable<int>(typeIndex);
    map['created_at'] = Variable<int>(createdAt);
    map['updated_at'] = Variable<int>(updatedAt);
    return map;
  }

  ActionDistanceAttackTableCompanion toCompanion(bool nullToAbsent) {
    return ActionDistanceAttackTableCompanion(
      uuid: Value(uuid),
      name: Value(name),
      parentUuid: Value(parentUuid),
      desc: Value(desc),
      damageDices: damageDices == null && nullToAbsent
          ? const Value.absent()
          : Value(damageDices),
      extraDamageDices: extraDamageDices == null && nullToAbsent
          ? const Value.absent()
          : Value(extraDamageDices),
      pm: pm == null && nullToAbsent ? const Value.absent() : Value(pm),
      cd: cd == null && nullToAbsent ? const Value.absent() : Value(cd),
      equipamentUuid: equipamentUuid == null && nullToAbsent
          ? const Value.absent()
          : Value(equipamentUuid),
      mediumDamageValue: mediumDamageValue == null && nullToAbsent
          ? const Value.absent()
          : Value(mediumDamageValue),
      critical: critical == null && nullToAbsent
          ? const Value.absent()
          : Value(critical),
      criticalMultiplier: criticalMultiplier == null && nullToAbsent
          ? const Value.absent()
          : Value(criticalMultiplier),
      typeIndex: Value(typeIndex),
      createdAt: Value(createdAt),
      updatedAt: Value(updatedAt),
    );
  }

  factory ActionDistanceAttackTableData.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return ActionDistanceAttackTableData(
      uuid: serializer.fromJson<String>(json['uuid']),
      name: serializer.fromJson<String>(json['name']),
      parentUuid: serializer.fromJson<String>(json['parentUuid']),
      desc: serializer.fromJson<String>(json['desc']),
      damageDices: serializer.fromJson<String?>(json['damageDices']),
      extraDamageDices: serializer.fromJson<String?>(json['extraDamageDices']),
      pm: serializer.fromJson<int?>(json['pm']),
      cd: serializer.fromJson<int?>(json['cd']),
      equipamentUuid: serializer.fromJson<String?>(json['equipamentUuid']),
      mediumDamageValue: serializer.fromJson<int?>(json['mediumDamageValue']),
      critical: serializer.fromJson<int?>(json['critical']),
      criticalMultiplier: serializer.fromJson<int?>(json['criticalMultiplier']),
      typeIndex: serializer.fromJson<int>(json['typeIndex']),
      createdAt: serializer.fromJson<int>(json['createdAt']),
      updatedAt: serializer.fromJson<int>(json['updatedAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'uuid': serializer.toJson<String>(uuid),
      'name': serializer.toJson<String>(name),
      'parentUuid': serializer.toJson<String>(parentUuid),
      'desc': serializer.toJson<String>(desc),
      'damageDices': serializer.toJson<String?>(damageDices),
      'extraDamageDices': serializer.toJson<String?>(extraDamageDices),
      'pm': serializer.toJson<int?>(pm),
      'cd': serializer.toJson<int?>(cd),
      'equipamentUuid': serializer.toJson<String?>(equipamentUuid),
      'mediumDamageValue': serializer.toJson<int?>(mediumDamageValue),
      'critical': serializer.toJson<int?>(critical),
      'criticalMultiplier': serializer.toJson<int?>(criticalMultiplier),
      'typeIndex': serializer.toJson<int>(typeIndex),
      'createdAt': serializer.toJson<int>(createdAt),
      'updatedAt': serializer.toJson<int>(updatedAt),
    };
  }

  ActionDistanceAttackTableData copyWith({
    String? uuid,
    String? name,
    String? parentUuid,
    String? desc,
    Value<String?> damageDices = const Value.absent(),
    Value<String?> extraDamageDices = const Value.absent(),
    Value<int?> pm = const Value.absent(),
    Value<int?> cd = const Value.absent(),
    Value<String?> equipamentUuid = const Value.absent(),
    Value<int?> mediumDamageValue = const Value.absent(),
    Value<int?> critical = const Value.absent(),
    Value<int?> criticalMultiplier = const Value.absent(),
    int? typeIndex,
    int? createdAt,
    int? updatedAt,
  }) => ActionDistanceAttackTableData(
    uuid: uuid ?? this.uuid,
    name: name ?? this.name,
    parentUuid: parentUuid ?? this.parentUuid,
    desc: desc ?? this.desc,
    damageDices: damageDices.present ? damageDices.value : this.damageDices,
    extraDamageDices: extraDamageDices.present
        ? extraDamageDices.value
        : this.extraDamageDices,
    pm: pm.present ? pm.value : this.pm,
    cd: cd.present ? cd.value : this.cd,
    equipamentUuid: equipamentUuid.present
        ? equipamentUuid.value
        : this.equipamentUuid,
    mediumDamageValue: mediumDamageValue.present
        ? mediumDamageValue.value
        : this.mediumDamageValue,
    critical: critical.present ? critical.value : this.critical,
    criticalMultiplier: criticalMultiplier.present
        ? criticalMultiplier.value
        : this.criticalMultiplier,
    typeIndex: typeIndex ?? this.typeIndex,
    createdAt: createdAt ?? this.createdAt,
    updatedAt: updatedAt ?? this.updatedAt,
  );
  ActionDistanceAttackTableData copyWithCompanion(
    ActionDistanceAttackTableCompanion data,
  ) {
    return ActionDistanceAttackTableData(
      uuid: data.uuid.present ? data.uuid.value : this.uuid,
      name: data.name.present ? data.name.value : this.name,
      parentUuid: data.parentUuid.present
          ? data.parentUuid.value
          : this.parentUuid,
      desc: data.desc.present ? data.desc.value : this.desc,
      damageDices: data.damageDices.present
          ? data.damageDices.value
          : this.damageDices,
      extraDamageDices: data.extraDamageDices.present
          ? data.extraDamageDices.value
          : this.extraDamageDices,
      pm: data.pm.present ? data.pm.value : this.pm,
      cd: data.cd.present ? data.cd.value : this.cd,
      equipamentUuid: data.equipamentUuid.present
          ? data.equipamentUuid.value
          : this.equipamentUuid,
      mediumDamageValue: data.mediumDamageValue.present
          ? data.mediumDamageValue.value
          : this.mediumDamageValue,
      critical: data.critical.present ? data.critical.value : this.critical,
      criticalMultiplier: data.criticalMultiplier.present
          ? data.criticalMultiplier.value
          : this.criticalMultiplier,
      typeIndex: data.typeIndex.present ? data.typeIndex.value : this.typeIndex,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('ActionDistanceAttackTableData(')
          ..write('uuid: $uuid, ')
          ..write('name: $name, ')
          ..write('parentUuid: $parentUuid, ')
          ..write('desc: $desc, ')
          ..write('damageDices: $damageDices, ')
          ..write('extraDamageDices: $extraDamageDices, ')
          ..write('pm: $pm, ')
          ..write('cd: $cd, ')
          ..write('equipamentUuid: $equipamentUuid, ')
          ..write('mediumDamageValue: $mediumDamageValue, ')
          ..write('critical: $critical, ')
          ..write('criticalMultiplier: $criticalMultiplier, ')
          ..write('typeIndex: $typeIndex, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    uuid,
    name,
    parentUuid,
    desc,
    damageDices,
    extraDamageDices,
    pm,
    cd,
    equipamentUuid,
    mediumDamageValue,
    critical,
    criticalMultiplier,
    typeIndex,
    createdAt,
    updatedAt,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is ActionDistanceAttackTableData &&
          other.uuid == this.uuid &&
          other.name == this.name &&
          other.parentUuid == this.parentUuid &&
          other.desc == this.desc &&
          other.damageDices == this.damageDices &&
          other.extraDamageDices == this.extraDamageDices &&
          other.pm == this.pm &&
          other.cd == this.cd &&
          other.equipamentUuid == this.equipamentUuid &&
          other.mediumDamageValue == this.mediumDamageValue &&
          other.critical == this.critical &&
          other.criticalMultiplier == this.criticalMultiplier &&
          other.typeIndex == this.typeIndex &&
          other.createdAt == this.createdAt &&
          other.updatedAt == this.updatedAt);
}

class ActionDistanceAttackTableCompanion
    extends UpdateCompanion<ActionDistanceAttackTableData> {
  final Value<String> uuid;
  final Value<String> name;
  final Value<String> parentUuid;
  final Value<String> desc;
  final Value<String?> damageDices;
  final Value<String?> extraDamageDices;
  final Value<int?> pm;
  final Value<int?> cd;
  final Value<String?> equipamentUuid;
  final Value<int?> mediumDamageValue;
  final Value<int?> critical;
  final Value<int?> criticalMultiplier;
  final Value<int> typeIndex;
  final Value<int> createdAt;
  final Value<int> updatedAt;
  final Value<int> rowid;
  const ActionDistanceAttackTableCompanion({
    this.uuid = const Value.absent(),
    this.name = const Value.absent(),
    this.parentUuid = const Value.absent(),
    this.desc = const Value.absent(),
    this.damageDices = const Value.absent(),
    this.extraDamageDices = const Value.absent(),
    this.pm = const Value.absent(),
    this.cd = const Value.absent(),
    this.equipamentUuid = const Value.absent(),
    this.mediumDamageValue = const Value.absent(),
    this.critical = const Value.absent(),
    this.criticalMultiplier = const Value.absent(),
    this.typeIndex = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  ActionDistanceAttackTableCompanion.insert({
    required String uuid,
    required String name,
    required String parentUuid,
    required String desc,
    this.damageDices = const Value.absent(),
    this.extraDamageDices = const Value.absent(),
    this.pm = const Value.absent(),
    this.cd = const Value.absent(),
    this.equipamentUuid = const Value.absent(),
    this.mediumDamageValue = const Value.absent(),
    this.critical = const Value.absent(),
    this.criticalMultiplier = const Value.absent(),
    required int typeIndex,
    required int createdAt,
    required int updatedAt,
    this.rowid = const Value.absent(),
  }) : uuid = Value(uuid),
       name = Value(name),
       parentUuid = Value(parentUuid),
       desc = Value(desc),
       typeIndex = Value(typeIndex),
       createdAt = Value(createdAt),
       updatedAt = Value(updatedAt);
  static Insertable<ActionDistanceAttackTableData> custom({
    Expression<String>? uuid,
    Expression<String>? name,
    Expression<String>? parentUuid,
    Expression<String>? desc,
    Expression<String>? damageDices,
    Expression<String>? extraDamageDices,
    Expression<int>? pm,
    Expression<int>? cd,
    Expression<String>? equipamentUuid,
    Expression<int>? mediumDamageValue,
    Expression<int>? critical,
    Expression<int>? criticalMultiplier,
    Expression<int>? typeIndex,
    Expression<int>? createdAt,
    Expression<int>? updatedAt,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (uuid != null) 'uuid': uuid,
      if (name != null) 'name': name,
      if (parentUuid != null) 'parent_uuid': parentUuid,
      if (desc != null) 'desc': desc,
      if (damageDices != null) 'damage_dices': damageDices,
      if (extraDamageDices != null) 'extra_damage_dices': extraDamageDices,
      if (pm != null) 'pm': pm,
      if (cd != null) 'cd': cd,
      if (equipamentUuid != null) 'equipament_uuid': equipamentUuid,
      if (mediumDamageValue != null) 'medium_damage_value': mediumDamageValue,
      if (critical != null) 'critical': critical,
      if (criticalMultiplier != null) 'critical_multiplier': criticalMultiplier,
      if (typeIndex != null) 'type_index': typeIndex,
      if (createdAt != null) 'created_at': createdAt,
      if (updatedAt != null) 'updated_at': updatedAt,
      if (rowid != null) 'rowid': rowid,
    });
  }

  ActionDistanceAttackTableCompanion copyWith({
    Value<String>? uuid,
    Value<String>? name,
    Value<String>? parentUuid,
    Value<String>? desc,
    Value<String?>? damageDices,
    Value<String?>? extraDamageDices,
    Value<int?>? pm,
    Value<int?>? cd,
    Value<String?>? equipamentUuid,
    Value<int?>? mediumDamageValue,
    Value<int?>? critical,
    Value<int?>? criticalMultiplier,
    Value<int>? typeIndex,
    Value<int>? createdAt,
    Value<int>? updatedAt,
    Value<int>? rowid,
  }) {
    return ActionDistanceAttackTableCompanion(
      uuid: uuid ?? this.uuid,
      name: name ?? this.name,
      parentUuid: parentUuid ?? this.parentUuid,
      desc: desc ?? this.desc,
      damageDices: damageDices ?? this.damageDices,
      extraDamageDices: extraDamageDices ?? this.extraDamageDices,
      pm: pm ?? this.pm,
      cd: cd ?? this.cd,
      equipamentUuid: equipamentUuid ?? this.equipamentUuid,
      mediumDamageValue: mediumDamageValue ?? this.mediumDamageValue,
      critical: critical ?? this.critical,
      criticalMultiplier: criticalMultiplier ?? this.criticalMultiplier,
      typeIndex: typeIndex ?? this.typeIndex,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (uuid.present) {
      map['uuid'] = Variable<String>(uuid.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    if (parentUuid.present) {
      map['parent_uuid'] = Variable<String>(parentUuid.value);
    }
    if (desc.present) {
      map['desc'] = Variable<String>(desc.value);
    }
    if (damageDices.present) {
      map['damage_dices'] = Variable<String>(damageDices.value);
    }
    if (extraDamageDices.present) {
      map['extra_damage_dices'] = Variable<String>(extraDamageDices.value);
    }
    if (pm.present) {
      map['pm'] = Variable<int>(pm.value);
    }
    if (cd.present) {
      map['cd'] = Variable<int>(cd.value);
    }
    if (equipamentUuid.present) {
      map['equipament_uuid'] = Variable<String>(equipamentUuid.value);
    }
    if (mediumDamageValue.present) {
      map['medium_damage_value'] = Variable<int>(mediumDamageValue.value);
    }
    if (critical.present) {
      map['critical'] = Variable<int>(critical.value);
    }
    if (criticalMultiplier.present) {
      map['critical_multiplier'] = Variable<int>(criticalMultiplier.value);
    }
    if (typeIndex.present) {
      map['type_index'] = Variable<int>(typeIndex.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<int>(createdAt.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<int>(updatedAt.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('ActionDistanceAttackTableCompanion(')
          ..write('uuid: $uuid, ')
          ..write('name: $name, ')
          ..write('parentUuid: $parentUuid, ')
          ..write('desc: $desc, ')
          ..write('damageDices: $damageDices, ')
          ..write('extraDamageDices: $extraDamageDices, ')
          ..write('pm: $pm, ')
          ..write('cd: $cd, ')
          ..write('equipamentUuid: $equipamentUuid, ')
          ..write('mediumDamageValue: $mediumDamageValue, ')
          ..write('critical: $critical, ')
          ..write('criticalMultiplier: $criticalMultiplier, ')
          ..write('typeIndex: $typeIndex, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $ExpertiseTableTable extends ExpertiseTable
    with TableInfo<$ExpertiseTableTable, ExpertiseTableData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $ExpertiseTableTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _uuidMeta = const VerificationMeta('uuid');
  @override
  late final GeneratedColumn<String> uuid = GeneratedColumn<String>(
    'uuid',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
    'name',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _parentUuidMeta = const VerificationMeta(
    'parentUuid',
  );
  @override
  late final GeneratedColumn<String> parentUuid = GeneratedColumn<String>(
    'parent_uuid',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _atributeIndexMeta = const VerificationMeta(
    'atributeIndex',
  );
  @override
  late final GeneratedColumn<int> atributeIndex = GeneratedColumn<int>(
    'atribute_index',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _bonusMeta = const VerificationMeta('bonus');
  @override
  late final GeneratedColumn<int> bonus = GeneratedColumn<int>(
    'bonus',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _valueFinalMeta = const VerificationMeta(
    'valueFinal',
  );
  @override
  late final GeneratedColumn<int> valueFinal = GeneratedColumn<int>(
    'value_final',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _isTrainedMeta = const VerificationMeta(
    'isTrained',
  );
  @override
  late final GeneratedColumn<bool> isTrained = GeneratedColumn<bool>(
    'is_trained',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_trained" IN (0, 1))',
    ),
  );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<int> createdAt = GeneratedColumn<int>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _updatedAtMeta = const VerificationMeta(
    'updatedAt',
  );
  @override
  late final GeneratedColumn<int> updatedAt = GeneratedColumn<int>(
    'updated_at',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  @override
  List<GeneratedColumn> get $columns => [
    uuid,
    name,
    parentUuid,
    id,
    atributeIndex,
    bonus,
    valueFinal,
    isTrained,
    createdAt,
    updatedAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'expertise_table';
  @override
  VerificationContext validateIntegrity(
    Insertable<ExpertiseTableData> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('uuid')) {
      context.handle(
        _uuidMeta,
        uuid.isAcceptableOrUnknown(data['uuid']!, _uuidMeta),
      );
    } else if (isInserting) {
      context.missing(_uuidMeta);
    }
    if (data.containsKey('name')) {
      context.handle(
        _nameMeta,
        name.isAcceptableOrUnknown(data['name']!, _nameMeta),
      );
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    if (data.containsKey('parent_uuid')) {
      context.handle(
        _parentUuidMeta,
        parentUuid.isAcceptableOrUnknown(data['parent_uuid']!, _parentUuidMeta),
      );
    } else if (isInserting) {
      context.missing(_parentUuidMeta);
    }
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('atribute_index')) {
      context.handle(
        _atributeIndexMeta,
        atributeIndex.isAcceptableOrUnknown(
          data['atribute_index']!,
          _atributeIndexMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_atributeIndexMeta);
    }
    if (data.containsKey('bonus')) {
      context.handle(
        _bonusMeta,
        bonus.isAcceptableOrUnknown(data['bonus']!, _bonusMeta),
      );
    }
    if (data.containsKey('value_final')) {
      context.handle(
        _valueFinalMeta,
        valueFinal.isAcceptableOrUnknown(data['value_final']!, _valueFinalMeta),
      );
    }
    if (data.containsKey('is_trained')) {
      context.handle(
        _isTrainedMeta,
        isTrained.isAcceptableOrUnknown(data['is_trained']!, _isTrainedMeta),
      );
    } else if (isInserting) {
      context.missing(_isTrainedMeta);
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    } else if (isInserting) {
      context.missing(_createdAtMeta);
    }
    if (data.containsKey('updated_at')) {
      context.handle(
        _updatedAtMeta,
        updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta),
      );
    } else if (isInserting) {
      context.missing(_updatedAtMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {uuid};
  @override
  ExpertiseTableData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return ExpertiseTableData(
      uuid: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}uuid'],
      )!,
      name: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}name'],
      )!,
      parentUuid: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}parent_uuid'],
      )!,
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}id'],
      )!,
      atributeIndex: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}atribute_index'],
      )!,
      bonus: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}bonus'],
      ),
      valueFinal: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}value_final'],
      ),
      isTrained: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_trained'],
      )!,
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}created_at'],
      )!,
      updatedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}updated_at'],
      )!,
    );
  }

  @override
  $ExpertiseTableTable createAlias(String alias) {
    return $ExpertiseTableTable(attachedDatabase, alias);
  }
}

class ExpertiseTableData extends DataClass
    implements Insertable<ExpertiseTableData> {
  final String uuid;
  final String name;
  final String parentUuid;
  final int id;
  final int atributeIndex;
  final int? bonus;
  final int? valueFinal;
  final bool isTrained;
  final int createdAt;
  final int updatedAt;
  const ExpertiseTableData({
    required this.uuid,
    required this.name,
    required this.parentUuid,
    required this.id,
    required this.atributeIndex,
    this.bonus,
    this.valueFinal,
    required this.isTrained,
    required this.createdAt,
    required this.updatedAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['uuid'] = Variable<String>(uuid);
    map['name'] = Variable<String>(name);
    map['parent_uuid'] = Variable<String>(parentUuid);
    map['id'] = Variable<int>(id);
    map['atribute_index'] = Variable<int>(atributeIndex);
    if (!nullToAbsent || bonus != null) {
      map['bonus'] = Variable<int>(bonus);
    }
    if (!nullToAbsent || valueFinal != null) {
      map['value_final'] = Variable<int>(valueFinal);
    }
    map['is_trained'] = Variable<bool>(isTrained);
    map['created_at'] = Variable<int>(createdAt);
    map['updated_at'] = Variable<int>(updatedAt);
    return map;
  }

  ExpertiseTableCompanion toCompanion(bool nullToAbsent) {
    return ExpertiseTableCompanion(
      uuid: Value(uuid),
      name: Value(name),
      parentUuid: Value(parentUuid),
      id: Value(id),
      atributeIndex: Value(atributeIndex),
      bonus: bonus == null && nullToAbsent
          ? const Value.absent()
          : Value(bonus),
      valueFinal: valueFinal == null && nullToAbsent
          ? const Value.absent()
          : Value(valueFinal),
      isTrained: Value(isTrained),
      createdAt: Value(createdAt),
      updatedAt: Value(updatedAt),
    );
  }

  factory ExpertiseTableData.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return ExpertiseTableData(
      uuid: serializer.fromJson<String>(json['uuid']),
      name: serializer.fromJson<String>(json['name']),
      parentUuid: serializer.fromJson<String>(json['parentUuid']),
      id: serializer.fromJson<int>(json['id']),
      atributeIndex: serializer.fromJson<int>(json['atributeIndex']),
      bonus: serializer.fromJson<int?>(json['bonus']),
      valueFinal: serializer.fromJson<int?>(json['valueFinal']),
      isTrained: serializer.fromJson<bool>(json['isTrained']),
      createdAt: serializer.fromJson<int>(json['createdAt']),
      updatedAt: serializer.fromJson<int>(json['updatedAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'uuid': serializer.toJson<String>(uuid),
      'name': serializer.toJson<String>(name),
      'parentUuid': serializer.toJson<String>(parentUuid),
      'id': serializer.toJson<int>(id),
      'atributeIndex': serializer.toJson<int>(atributeIndex),
      'bonus': serializer.toJson<int?>(bonus),
      'valueFinal': serializer.toJson<int?>(valueFinal),
      'isTrained': serializer.toJson<bool>(isTrained),
      'createdAt': serializer.toJson<int>(createdAt),
      'updatedAt': serializer.toJson<int>(updatedAt),
    };
  }

  ExpertiseTableData copyWith({
    String? uuid,
    String? name,
    String? parentUuid,
    int? id,
    int? atributeIndex,
    Value<int?> bonus = const Value.absent(),
    Value<int?> valueFinal = const Value.absent(),
    bool? isTrained,
    int? createdAt,
    int? updatedAt,
  }) => ExpertiseTableData(
    uuid: uuid ?? this.uuid,
    name: name ?? this.name,
    parentUuid: parentUuid ?? this.parentUuid,
    id: id ?? this.id,
    atributeIndex: atributeIndex ?? this.atributeIndex,
    bonus: bonus.present ? bonus.value : this.bonus,
    valueFinal: valueFinal.present ? valueFinal.value : this.valueFinal,
    isTrained: isTrained ?? this.isTrained,
    createdAt: createdAt ?? this.createdAt,
    updatedAt: updatedAt ?? this.updatedAt,
  );
  ExpertiseTableData copyWithCompanion(ExpertiseTableCompanion data) {
    return ExpertiseTableData(
      uuid: data.uuid.present ? data.uuid.value : this.uuid,
      name: data.name.present ? data.name.value : this.name,
      parentUuid: data.parentUuid.present
          ? data.parentUuid.value
          : this.parentUuid,
      id: data.id.present ? data.id.value : this.id,
      atributeIndex: data.atributeIndex.present
          ? data.atributeIndex.value
          : this.atributeIndex,
      bonus: data.bonus.present ? data.bonus.value : this.bonus,
      valueFinal: data.valueFinal.present
          ? data.valueFinal.value
          : this.valueFinal,
      isTrained: data.isTrained.present ? data.isTrained.value : this.isTrained,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('ExpertiseTableData(')
          ..write('uuid: $uuid, ')
          ..write('name: $name, ')
          ..write('parentUuid: $parentUuid, ')
          ..write('id: $id, ')
          ..write('atributeIndex: $atributeIndex, ')
          ..write('bonus: $bonus, ')
          ..write('valueFinal: $valueFinal, ')
          ..write('isTrained: $isTrained, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    uuid,
    name,
    parentUuid,
    id,
    atributeIndex,
    bonus,
    valueFinal,
    isTrained,
    createdAt,
    updatedAt,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is ExpertiseTableData &&
          other.uuid == this.uuid &&
          other.name == this.name &&
          other.parentUuid == this.parentUuid &&
          other.id == this.id &&
          other.atributeIndex == this.atributeIndex &&
          other.bonus == this.bonus &&
          other.valueFinal == this.valueFinal &&
          other.isTrained == this.isTrained &&
          other.createdAt == this.createdAt &&
          other.updatedAt == this.updatedAt);
}

class ExpertiseTableCompanion extends UpdateCompanion<ExpertiseTableData> {
  final Value<String> uuid;
  final Value<String> name;
  final Value<String> parentUuid;
  final Value<int> id;
  final Value<int> atributeIndex;
  final Value<int?> bonus;
  final Value<int?> valueFinal;
  final Value<bool> isTrained;
  final Value<int> createdAt;
  final Value<int> updatedAt;
  final Value<int> rowid;
  const ExpertiseTableCompanion({
    this.uuid = const Value.absent(),
    this.name = const Value.absent(),
    this.parentUuid = const Value.absent(),
    this.id = const Value.absent(),
    this.atributeIndex = const Value.absent(),
    this.bonus = const Value.absent(),
    this.valueFinal = const Value.absent(),
    this.isTrained = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  ExpertiseTableCompanion.insert({
    required String uuid,
    required String name,
    required String parentUuid,
    required int id,
    required int atributeIndex,
    this.bonus = const Value.absent(),
    this.valueFinal = const Value.absent(),
    required bool isTrained,
    required int createdAt,
    required int updatedAt,
    this.rowid = const Value.absent(),
  }) : uuid = Value(uuid),
       name = Value(name),
       parentUuid = Value(parentUuid),
       id = Value(id),
       atributeIndex = Value(atributeIndex),
       isTrained = Value(isTrained),
       createdAt = Value(createdAt),
       updatedAt = Value(updatedAt);
  static Insertable<ExpertiseTableData> custom({
    Expression<String>? uuid,
    Expression<String>? name,
    Expression<String>? parentUuid,
    Expression<int>? id,
    Expression<int>? atributeIndex,
    Expression<int>? bonus,
    Expression<int>? valueFinal,
    Expression<bool>? isTrained,
    Expression<int>? createdAt,
    Expression<int>? updatedAt,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (uuid != null) 'uuid': uuid,
      if (name != null) 'name': name,
      if (parentUuid != null) 'parent_uuid': parentUuid,
      if (id != null) 'id': id,
      if (atributeIndex != null) 'atribute_index': atributeIndex,
      if (bonus != null) 'bonus': bonus,
      if (valueFinal != null) 'value_final': valueFinal,
      if (isTrained != null) 'is_trained': isTrained,
      if (createdAt != null) 'created_at': createdAt,
      if (updatedAt != null) 'updated_at': updatedAt,
      if (rowid != null) 'rowid': rowid,
    });
  }

  ExpertiseTableCompanion copyWith({
    Value<String>? uuid,
    Value<String>? name,
    Value<String>? parentUuid,
    Value<int>? id,
    Value<int>? atributeIndex,
    Value<int?>? bonus,
    Value<int?>? valueFinal,
    Value<bool>? isTrained,
    Value<int>? createdAt,
    Value<int>? updatedAt,
    Value<int>? rowid,
  }) {
    return ExpertiseTableCompanion(
      uuid: uuid ?? this.uuid,
      name: name ?? this.name,
      parentUuid: parentUuid ?? this.parentUuid,
      id: id ?? this.id,
      atributeIndex: atributeIndex ?? this.atributeIndex,
      bonus: bonus ?? this.bonus,
      valueFinal: valueFinal ?? this.valueFinal,
      isTrained: isTrained ?? this.isTrained,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (uuid.present) {
      map['uuid'] = Variable<String>(uuid.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    if (parentUuid.present) {
      map['parent_uuid'] = Variable<String>(parentUuid.value);
    }
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (atributeIndex.present) {
      map['atribute_index'] = Variable<int>(atributeIndex.value);
    }
    if (bonus.present) {
      map['bonus'] = Variable<int>(bonus.value);
    }
    if (valueFinal.present) {
      map['value_final'] = Variable<int>(valueFinal.value);
    }
    if (isTrained.present) {
      map['is_trained'] = Variable<bool>(isTrained.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<int>(createdAt.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<int>(updatedAt.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('ExpertiseTableCompanion(')
          ..write('uuid: $uuid, ')
          ..write('name: $name, ')
          ..write('parentUuid: $parentUuid, ')
          ..write('id: $id, ')
          ..write('atributeIndex: $atributeIndex, ')
          ..write('bonus: $bonus, ')
          ..write('valueFinal: $valueFinal, ')
          ..write('isTrained: $isTrained, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $MenaceLinkBoardTableTable extends MenaceLinkBoardTable
    with TableInfo<$MenaceLinkBoardTableTable, MenaceLinkBoardTableData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $MenaceLinkBoardTableTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _uuidMeta = const VerificationMeta('uuid');
  @override
  late final GeneratedColumn<String> uuid = GeneratedColumn<String>(
    'uuid',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _menaceUuidMeta = const VerificationMeta(
    'menaceUuid',
  );
  @override
  late final GeneratedColumn<String> menaceUuid = GeneratedColumn<String>(
    'menace_uuid',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _boardUuidMeta = const VerificationMeta(
    'boardUuid',
  );
  @override
  late final GeneratedColumn<String> boardUuid = GeneratedColumn<String>(
    'board_uuid',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  @override
  List<GeneratedColumn> get $columns => [uuid, menaceUuid, boardUuid];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'menace_link_board_table';
  @override
  VerificationContext validateIntegrity(
    Insertable<MenaceLinkBoardTableData> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('uuid')) {
      context.handle(
        _uuidMeta,
        uuid.isAcceptableOrUnknown(data['uuid']!, _uuidMeta),
      );
    } else if (isInserting) {
      context.missing(_uuidMeta);
    }
    if (data.containsKey('menace_uuid')) {
      context.handle(
        _menaceUuidMeta,
        menaceUuid.isAcceptableOrUnknown(data['menace_uuid']!, _menaceUuidMeta),
      );
    } else if (isInserting) {
      context.missing(_menaceUuidMeta);
    }
    if (data.containsKey('board_uuid')) {
      context.handle(
        _boardUuidMeta,
        boardUuid.isAcceptableOrUnknown(data['board_uuid']!, _boardUuidMeta),
      );
    } else if (isInserting) {
      context.missing(_boardUuidMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {uuid};
  @override
  MenaceLinkBoardTableData map(
    Map<String, dynamic> data, {
    String? tablePrefix,
  }) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return MenaceLinkBoardTableData(
      uuid: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}uuid'],
      )!,
      menaceUuid: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}menace_uuid'],
      )!,
      boardUuid: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}board_uuid'],
      )!,
    );
  }

  @override
  $MenaceLinkBoardTableTable createAlias(String alias) {
    return $MenaceLinkBoardTableTable(attachedDatabase, alias);
  }
}

class MenaceLinkBoardTableData extends DataClass
    implements Insertable<MenaceLinkBoardTableData> {
  final String uuid;
  final String menaceUuid;
  final String boardUuid;
  const MenaceLinkBoardTableData({
    required this.uuid,
    required this.menaceUuid,
    required this.boardUuid,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['uuid'] = Variable<String>(uuid);
    map['menace_uuid'] = Variable<String>(menaceUuid);
    map['board_uuid'] = Variable<String>(boardUuid);
    return map;
  }

  MenaceLinkBoardTableCompanion toCompanion(bool nullToAbsent) {
    return MenaceLinkBoardTableCompanion(
      uuid: Value(uuid),
      menaceUuid: Value(menaceUuid),
      boardUuid: Value(boardUuid),
    );
  }

  factory MenaceLinkBoardTableData.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return MenaceLinkBoardTableData(
      uuid: serializer.fromJson<String>(json['uuid']),
      menaceUuid: serializer.fromJson<String>(json['menaceUuid']),
      boardUuid: serializer.fromJson<String>(json['boardUuid']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'uuid': serializer.toJson<String>(uuid),
      'menaceUuid': serializer.toJson<String>(menaceUuid),
      'boardUuid': serializer.toJson<String>(boardUuid),
    };
  }

  MenaceLinkBoardTableData copyWith({
    String? uuid,
    String? menaceUuid,
    String? boardUuid,
  }) => MenaceLinkBoardTableData(
    uuid: uuid ?? this.uuid,
    menaceUuid: menaceUuid ?? this.menaceUuid,
    boardUuid: boardUuid ?? this.boardUuid,
  );
  MenaceLinkBoardTableData copyWithCompanion(
    MenaceLinkBoardTableCompanion data,
  ) {
    return MenaceLinkBoardTableData(
      uuid: data.uuid.present ? data.uuid.value : this.uuid,
      menaceUuid: data.menaceUuid.present
          ? data.menaceUuid.value
          : this.menaceUuid,
      boardUuid: data.boardUuid.present ? data.boardUuid.value : this.boardUuid,
    );
  }

  @override
  String toString() {
    return (StringBuffer('MenaceLinkBoardTableData(')
          ..write('uuid: $uuid, ')
          ..write('menaceUuid: $menaceUuid, ')
          ..write('boardUuid: $boardUuid')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(uuid, menaceUuid, boardUuid);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is MenaceLinkBoardTableData &&
          other.uuid == this.uuid &&
          other.menaceUuid == this.menaceUuid &&
          other.boardUuid == this.boardUuid);
}

class MenaceLinkBoardTableCompanion
    extends UpdateCompanion<MenaceLinkBoardTableData> {
  final Value<String> uuid;
  final Value<String> menaceUuid;
  final Value<String> boardUuid;
  final Value<int> rowid;
  const MenaceLinkBoardTableCompanion({
    this.uuid = const Value.absent(),
    this.menaceUuid = const Value.absent(),
    this.boardUuid = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  MenaceLinkBoardTableCompanion.insert({
    required String uuid,
    required String menaceUuid,
    required String boardUuid,
    this.rowid = const Value.absent(),
  }) : uuid = Value(uuid),
       menaceUuid = Value(menaceUuid),
       boardUuid = Value(boardUuid);
  static Insertable<MenaceLinkBoardTableData> custom({
    Expression<String>? uuid,
    Expression<String>? menaceUuid,
    Expression<String>? boardUuid,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (uuid != null) 'uuid': uuid,
      if (menaceUuid != null) 'menace_uuid': menaceUuid,
      if (boardUuid != null) 'board_uuid': boardUuid,
      if (rowid != null) 'rowid': rowid,
    });
  }

  MenaceLinkBoardTableCompanion copyWith({
    Value<String>? uuid,
    Value<String>? menaceUuid,
    Value<String>? boardUuid,
    Value<int>? rowid,
  }) {
    return MenaceLinkBoardTableCompanion(
      uuid: uuid ?? this.uuid,
      menaceUuid: menaceUuid ?? this.menaceUuid,
      boardUuid: boardUuid ?? this.boardUuid,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (uuid.present) {
      map['uuid'] = Variable<String>(uuid.value);
    }
    if (menaceUuid.present) {
      map['menace_uuid'] = Variable<String>(menaceUuid.value);
    }
    if (boardUuid.present) {
      map['board_uuid'] = Variable<String>(boardUuid.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('MenaceLinkBoardTableCompanion(')
          ..write('uuid: $uuid, ')
          ..write('menaceUuid: $menaceUuid, ')
          ..write('boardUuid: $boardUuid, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $ConfigTableTable extends ConfigTable
    with TableInfo<$ConfigTableTable, ConfigTableData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $ConfigTableTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(1),
  );
  static const VerificationMeta _modeIndexMeta = const VerificationMeta(
    'modeIndex',
  );
  @override
  late final GeneratedColumn<int> modeIndex = GeneratedColumn<int>(
    'mode_index',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _showApresetationMeta = const VerificationMeta(
    'showApresetation',
  );
  @override
  late final GeneratedColumn<bool> showApresetation = GeneratedColumn<bool>(
    'show_apresetation',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("show_apresetation" IN (0, 1))',
    ),
    defaultValue: const Constant(false),
  );
  static const VerificationMeta _enableBottomBackButtonMeta =
      const VerificationMeta('enableBottomBackButton');
  @override
  late final GeneratedColumn<bool> enableBottomBackButton =
      GeneratedColumn<bool>(
        'enable_bottom_back_button',
        aliasedName,
        false,
        type: DriftSqlType.bool,
        requiredDuringInsert: false,
        defaultConstraints: GeneratedColumn.constraintIsAlways(
          'CHECK ("enable_bottom_back_button" IN (0, 1))',
        ),
        defaultValue: const Constant(true),
      );
  static const VerificationMeta _enableHomeTipesMeta = const VerificationMeta(
    'enableHomeTipes',
  );
  @override
  late final GeneratedColumn<bool> enableHomeTipes = GeneratedColumn<bool>(
    'enable_home_tipes',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("enable_home_tipes" IN (0, 1))',
    ),
    defaultValue: const Constant(true),
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    modeIndex,
    showApresetation,
    enableBottomBackButton,
    enableHomeTipes,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'config_table';
  @override
  VerificationContext validateIntegrity(
    Insertable<ConfigTableData> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('mode_index')) {
      context.handle(
        _modeIndexMeta,
        modeIndex.isAcceptableOrUnknown(data['mode_index']!, _modeIndexMeta),
      );
    }
    if (data.containsKey('show_apresetation')) {
      context.handle(
        _showApresetationMeta,
        showApresetation.isAcceptableOrUnknown(
          data['show_apresetation']!,
          _showApresetationMeta,
        ),
      );
    }
    if (data.containsKey('enable_bottom_back_button')) {
      context.handle(
        _enableBottomBackButtonMeta,
        enableBottomBackButton.isAcceptableOrUnknown(
          data['enable_bottom_back_button']!,
          _enableBottomBackButtonMeta,
        ),
      );
    }
    if (data.containsKey('enable_home_tipes')) {
      context.handle(
        _enableHomeTipesMeta,
        enableHomeTipes.isAcceptableOrUnknown(
          data['enable_home_tipes']!,
          _enableHomeTipesMeta,
        ),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  ConfigTableData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return ConfigTableData(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}id'],
      )!,
      modeIndex: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}mode_index'],
      )!,
      showApresetation: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}show_apresetation'],
      )!,
      enableBottomBackButton: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}enable_bottom_back_button'],
      )!,
      enableHomeTipes: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}enable_home_tipes'],
      )!,
    );
  }

  @override
  $ConfigTableTable createAlias(String alias) {
    return $ConfigTableTable(attachedDatabase, alias);
  }
}

class ConfigTableData extends DataClass implements Insertable<ConfigTableData> {
  final int id;
  final int modeIndex;
  final bool showApresetation;
  final bool enableBottomBackButton;
  final bool enableHomeTipes;
  const ConfigTableData({
    required this.id,
    required this.modeIndex,
    required this.showApresetation,
    required this.enableBottomBackButton,
    required this.enableHomeTipes,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['mode_index'] = Variable<int>(modeIndex);
    map['show_apresetation'] = Variable<bool>(showApresetation);
    map['enable_bottom_back_button'] = Variable<bool>(enableBottomBackButton);
    map['enable_home_tipes'] = Variable<bool>(enableHomeTipes);
    return map;
  }

  ConfigTableCompanion toCompanion(bool nullToAbsent) {
    return ConfigTableCompanion(
      id: Value(id),
      modeIndex: Value(modeIndex),
      showApresetation: Value(showApresetation),
      enableBottomBackButton: Value(enableBottomBackButton),
      enableHomeTipes: Value(enableHomeTipes),
    );
  }

  factory ConfigTableData.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return ConfigTableData(
      id: serializer.fromJson<int>(json['id']),
      modeIndex: serializer.fromJson<int>(json['modeIndex']),
      showApresetation: serializer.fromJson<bool>(json['showApresetation']),
      enableBottomBackButton: serializer.fromJson<bool>(
        json['enableBottomBackButton'],
      ),
      enableHomeTipes: serializer.fromJson<bool>(json['enableHomeTipes']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'modeIndex': serializer.toJson<int>(modeIndex),
      'showApresetation': serializer.toJson<bool>(showApresetation),
      'enableBottomBackButton': serializer.toJson<bool>(enableBottomBackButton),
      'enableHomeTipes': serializer.toJson<bool>(enableHomeTipes),
    };
  }

  ConfigTableData copyWith({
    int? id,
    int? modeIndex,
    bool? showApresetation,
    bool? enableBottomBackButton,
    bool? enableHomeTipes,
  }) => ConfigTableData(
    id: id ?? this.id,
    modeIndex: modeIndex ?? this.modeIndex,
    showApresetation: showApresetation ?? this.showApresetation,
    enableBottomBackButton:
        enableBottomBackButton ?? this.enableBottomBackButton,
    enableHomeTipes: enableHomeTipes ?? this.enableHomeTipes,
  );
  ConfigTableData copyWithCompanion(ConfigTableCompanion data) {
    return ConfigTableData(
      id: data.id.present ? data.id.value : this.id,
      modeIndex: data.modeIndex.present ? data.modeIndex.value : this.modeIndex,
      showApresetation: data.showApresetation.present
          ? data.showApresetation.value
          : this.showApresetation,
      enableBottomBackButton: data.enableBottomBackButton.present
          ? data.enableBottomBackButton.value
          : this.enableBottomBackButton,
      enableHomeTipes: data.enableHomeTipes.present
          ? data.enableHomeTipes.value
          : this.enableHomeTipes,
    );
  }

  @override
  String toString() {
    return (StringBuffer('ConfigTableData(')
          ..write('id: $id, ')
          ..write('modeIndex: $modeIndex, ')
          ..write('showApresetation: $showApresetation, ')
          ..write('enableBottomBackButton: $enableBottomBackButton, ')
          ..write('enableHomeTipes: $enableHomeTipes')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    id,
    modeIndex,
    showApresetation,
    enableBottomBackButton,
    enableHomeTipes,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is ConfigTableData &&
          other.id == this.id &&
          other.modeIndex == this.modeIndex &&
          other.showApresetation == this.showApresetation &&
          other.enableBottomBackButton == this.enableBottomBackButton &&
          other.enableHomeTipes == this.enableHomeTipes);
}

class ConfigTableCompanion extends UpdateCompanion<ConfigTableData> {
  final Value<int> id;
  final Value<int> modeIndex;
  final Value<bool> showApresetation;
  final Value<bool> enableBottomBackButton;
  final Value<bool> enableHomeTipes;
  const ConfigTableCompanion({
    this.id = const Value.absent(),
    this.modeIndex = const Value.absent(),
    this.showApresetation = const Value.absent(),
    this.enableBottomBackButton = const Value.absent(),
    this.enableHomeTipes = const Value.absent(),
  });
  ConfigTableCompanion.insert({
    this.id = const Value.absent(),
    this.modeIndex = const Value.absent(),
    this.showApresetation = const Value.absent(),
    this.enableBottomBackButton = const Value.absent(),
    this.enableHomeTipes = const Value.absent(),
  });
  static Insertable<ConfigTableData> custom({
    Expression<int>? id,
    Expression<int>? modeIndex,
    Expression<bool>? showApresetation,
    Expression<bool>? enableBottomBackButton,
    Expression<bool>? enableHomeTipes,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (modeIndex != null) 'mode_index': modeIndex,
      if (showApresetation != null) 'show_apresetation': showApresetation,
      if (enableBottomBackButton != null)
        'enable_bottom_back_button': enableBottomBackButton,
      if (enableHomeTipes != null) 'enable_home_tipes': enableHomeTipes,
    });
  }

  ConfigTableCompanion copyWith({
    Value<int>? id,
    Value<int>? modeIndex,
    Value<bool>? showApresetation,
    Value<bool>? enableBottomBackButton,
    Value<bool>? enableHomeTipes,
  }) {
    return ConfigTableCompanion(
      id: id ?? this.id,
      modeIndex: modeIndex ?? this.modeIndex,
      showApresetation: showApresetation ?? this.showApresetation,
      enableBottomBackButton:
          enableBottomBackButton ?? this.enableBottomBackButton,
      enableHomeTipes: enableHomeTipes ?? this.enableHomeTipes,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (modeIndex.present) {
      map['mode_index'] = Variable<int>(modeIndex.value);
    }
    if (showApresetation.present) {
      map['show_apresetation'] = Variable<bool>(showApresetation.value);
    }
    if (enableBottomBackButton.present) {
      map['enable_bottom_back_button'] = Variable<bool>(
        enableBottomBackButton.value,
      );
    }
    if (enableHomeTipes.present) {
      map['enable_home_tipes'] = Variable<bool>(enableHomeTipes.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('ConfigTableCompanion(')
          ..write('id: $id, ')
          ..write('modeIndex: $modeIndex, ')
          ..write('showApresetation: $showApresetation, ')
          ..write('enableBottomBackButton: $enableBottomBackButton, ')
          ..write('enableHomeTipes: $enableHomeTipes')
          ..write(')'))
        .toString();
  }
}

class $CharacterTableTable extends CharacterTable
    with TableInfo<$CharacterTableTable, CharacterTableData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $CharacterTableTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _uuidMeta = const VerificationMeta('uuid');
  @override
  late final GeneratedColumn<String> uuid = GeneratedColumn<String>(
    'uuid',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
    'name',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _imagePathMeta = const VerificationMeta(
    'imagePath',
  );
  @override
  late final GeneratedColumn<String> imagePath = GeneratedColumn<String>(
    'image_path',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _imageAssetMeta = const VerificationMeta(
    'imageAsset',
  );
  @override
  late final GeneratedColumn<String> imageAsset = GeneratedColumn<String>(
    'image_asset',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _displacementMeta = const VerificationMeta(
    'displacement',
  );
  @override
  late final GeneratedColumn<String> displacement = GeneratedColumn<String>(
    'displacement',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _sensesMeta = const VerificationMeta('senses');
  @override
  late final GeneratedColumn<String> senses = GeneratedColumn<String>(
    'senses',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _divinityIdMeta = const VerificationMeta(
    'divinityId',
  );
  @override
  late final GeneratedColumn<int> divinityId = GeneratedColumn<int>(
    'divinity_id',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _defenseMeta = const VerificationMeta(
    'defense',
  );
  @override
  late final GeneratedColumn<int> defense = GeneratedColumn<int>(
    'defense',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _lifeMeta = const VerificationMeta('life');
  @override
  late final GeneratedColumn<int> life = GeneratedColumn<int>(
    'life',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _manaMeta = const VerificationMeta('mana');
  @override
  late final GeneratedColumn<int> mana = GeneratedColumn<int>(
    'mana',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _strengthMeta = const VerificationMeta(
    'strength',
  );
  @override
  late final GeneratedColumn<int> strength = GeneratedColumn<int>(
    'strength',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _dexterityMeta = const VerificationMeta(
    'dexterity',
  );
  @override
  late final GeneratedColumn<int> dexterity = GeneratedColumn<int>(
    'dexterity',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _constitutionMeta = const VerificationMeta(
    'constitution',
  );
  @override
  late final GeneratedColumn<int> constitution = GeneratedColumn<int>(
    'constitution',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _intelligenceMeta = const VerificationMeta(
    'intelligence',
  );
  @override
  late final GeneratedColumn<int> intelligence = GeneratedColumn<int>(
    'intelligence',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _wisdomMeta = const VerificationMeta('wisdom');
  @override
  late final GeneratedColumn<int> wisdom = GeneratedColumn<int>(
    'wisdom',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _charismaMeta = const VerificationMeta(
    'charisma',
  );
  @override
  late final GeneratedColumn<int> charisma = GeneratedColumn<int>(
    'charisma',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _creatureSizeIndexMeta = const VerificationMeta(
    'creatureSizeIndex',
  );
  @override
  late final GeneratedColumn<int> creatureSizeIndex = GeneratedColumn<int>(
    'creature_size_index',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _broodIndexMeta = const VerificationMeta(
    'broodIndex',
  );
  @override
  late final GeneratedColumn<int> broodIndex = GeneratedColumn<int>(
    'brood_index',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _grimoireUuidMeta = const VerificationMeta(
    'grimoireUuid',
  );
  @override
  late final GeneratedColumn<String> grimoireUuid = GeneratedColumn<String>(
    'grimoire_uuid',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<int> createdAt = GeneratedColumn<int>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _updatedAtMeta = const VerificationMeta(
    'updatedAt',
  );
  @override
  late final GeneratedColumn<int> updatedAt = GeneratedColumn<int>(
    'updated_at',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _trainedExpertisesIndexesMeta =
      const VerificationMeta('trainedExpertisesIndexes');
  @override
  late final GeneratedColumn<String> trainedExpertisesIndexes =
      GeneratedColumn<String>(
        'trained_expertises_indexes',
        aliasedName,
        true,
        type: DriftSqlType.string,
        requiredDuringInsert: false,
      );
  static const VerificationMeta _aligmentIndexMeta = const VerificationMeta(
    'aligmentIndex',
  );
  @override
  late final GeneratedColumn<int> aligmentIndex = GeneratedColumn<int>(
    'aligment_index',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  @override
  List<GeneratedColumn> get $columns => [
    uuid,
    name,
    imagePath,
    imageAsset,
    displacement,
    senses,
    divinityId,
    defense,
    life,
    mana,
    strength,
    dexterity,
    constitution,
    intelligence,
    wisdom,
    charisma,
    creatureSizeIndex,
    broodIndex,
    grimoireUuid,
    createdAt,
    updatedAt,
    trainedExpertisesIndexes,
    aligmentIndex,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'character_table';
  @override
  VerificationContext validateIntegrity(
    Insertable<CharacterTableData> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('uuid')) {
      context.handle(
        _uuidMeta,
        uuid.isAcceptableOrUnknown(data['uuid']!, _uuidMeta),
      );
    } else if (isInserting) {
      context.missing(_uuidMeta);
    }
    if (data.containsKey('name')) {
      context.handle(
        _nameMeta,
        name.isAcceptableOrUnknown(data['name']!, _nameMeta),
      );
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    if (data.containsKey('image_path')) {
      context.handle(
        _imagePathMeta,
        imagePath.isAcceptableOrUnknown(data['image_path']!, _imagePathMeta),
      );
    }
    if (data.containsKey('image_asset')) {
      context.handle(
        _imageAssetMeta,
        imageAsset.isAcceptableOrUnknown(data['image_asset']!, _imageAssetMeta),
      );
    }
    if (data.containsKey('displacement')) {
      context.handle(
        _displacementMeta,
        displacement.isAcceptableOrUnknown(
          data['displacement']!,
          _displacementMeta,
        ),
      );
    }
    if (data.containsKey('senses')) {
      context.handle(
        _sensesMeta,
        senses.isAcceptableOrUnknown(data['senses']!, _sensesMeta),
      );
    }
    if (data.containsKey('divinity_id')) {
      context.handle(
        _divinityIdMeta,
        divinityId.isAcceptableOrUnknown(data['divinity_id']!, _divinityIdMeta),
      );
    }
    if (data.containsKey('defense')) {
      context.handle(
        _defenseMeta,
        defense.isAcceptableOrUnknown(data['defense']!, _defenseMeta),
      );
    } else if (isInserting) {
      context.missing(_defenseMeta);
    }
    if (data.containsKey('life')) {
      context.handle(
        _lifeMeta,
        life.isAcceptableOrUnknown(data['life']!, _lifeMeta),
      );
    } else if (isInserting) {
      context.missing(_lifeMeta);
    }
    if (data.containsKey('mana')) {
      context.handle(
        _manaMeta,
        mana.isAcceptableOrUnknown(data['mana']!, _manaMeta),
      );
    } else if (isInserting) {
      context.missing(_manaMeta);
    }
    if (data.containsKey('strength')) {
      context.handle(
        _strengthMeta,
        strength.isAcceptableOrUnknown(data['strength']!, _strengthMeta),
      );
    } else if (isInserting) {
      context.missing(_strengthMeta);
    }
    if (data.containsKey('dexterity')) {
      context.handle(
        _dexterityMeta,
        dexterity.isAcceptableOrUnknown(data['dexterity']!, _dexterityMeta),
      );
    } else if (isInserting) {
      context.missing(_dexterityMeta);
    }
    if (data.containsKey('constitution')) {
      context.handle(
        _constitutionMeta,
        constitution.isAcceptableOrUnknown(
          data['constitution']!,
          _constitutionMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_constitutionMeta);
    }
    if (data.containsKey('intelligence')) {
      context.handle(
        _intelligenceMeta,
        intelligence.isAcceptableOrUnknown(
          data['intelligence']!,
          _intelligenceMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_intelligenceMeta);
    }
    if (data.containsKey('wisdom')) {
      context.handle(
        _wisdomMeta,
        wisdom.isAcceptableOrUnknown(data['wisdom']!, _wisdomMeta),
      );
    } else if (isInserting) {
      context.missing(_wisdomMeta);
    }
    if (data.containsKey('charisma')) {
      context.handle(
        _charismaMeta,
        charisma.isAcceptableOrUnknown(data['charisma']!, _charismaMeta),
      );
    } else if (isInserting) {
      context.missing(_charismaMeta);
    }
    if (data.containsKey('creature_size_index')) {
      context.handle(
        _creatureSizeIndexMeta,
        creatureSizeIndex.isAcceptableOrUnknown(
          data['creature_size_index']!,
          _creatureSizeIndexMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_creatureSizeIndexMeta);
    }
    if (data.containsKey('brood_index')) {
      context.handle(
        _broodIndexMeta,
        broodIndex.isAcceptableOrUnknown(data['brood_index']!, _broodIndexMeta),
      );
    } else if (isInserting) {
      context.missing(_broodIndexMeta);
    }
    if (data.containsKey('grimoire_uuid')) {
      context.handle(
        _grimoireUuidMeta,
        grimoireUuid.isAcceptableOrUnknown(
          data['grimoire_uuid']!,
          _grimoireUuidMeta,
        ),
      );
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    } else if (isInserting) {
      context.missing(_createdAtMeta);
    }
    if (data.containsKey('updated_at')) {
      context.handle(
        _updatedAtMeta,
        updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta),
      );
    } else if (isInserting) {
      context.missing(_updatedAtMeta);
    }
    if (data.containsKey('trained_expertises_indexes')) {
      context.handle(
        _trainedExpertisesIndexesMeta,
        trainedExpertisesIndexes.isAcceptableOrUnknown(
          data['trained_expertises_indexes']!,
          _trainedExpertisesIndexesMeta,
        ),
      );
    }
    if (data.containsKey('aligment_index')) {
      context.handle(
        _aligmentIndexMeta,
        aligmentIndex.isAcceptableOrUnknown(
          data['aligment_index']!,
          _aligmentIndexMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_aligmentIndexMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {uuid};
  @override
  CharacterTableData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return CharacterTableData(
      uuid: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}uuid'],
      )!,
      name: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}name'],
      )!,
      imagePath: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}image_path'],
      ),
      imageAsset: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}image_asset'],
      ),
      displacement: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}displacement'],
      ),
      senses: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}senses'],
      ),
      divinityId: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}divinity_id'],
      ),
      defense: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}defense'],
      )!,
      life: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}life'],
      )!,
      mana: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}mana'],
      )!,
      strength: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}strength'],
      )!,
      dexterity: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}dexterity'],
      )!,
      constitution: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}constitution'],
      )!,
      intelligence: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}intelligence'],
      )!,
      wisdom: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}wisdom'],
      )!,
      charisma: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}charisma'],
      )!,
      creatureSizeIndex: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}creature_size_index'],
      )!,
      broodIndex: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}brood_index'],
      )!,
      grimoireUuid: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}grimoire_uuid'],
      ),
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}created_at'],
      )!,
      updatedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}updated_at'],
      )!,
      trainedExpertisesIndexes: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}trained_expertises_indexes'],
      ),
      aligmentIndex: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}aligment_index'],
      )!,
    );
  }

  @override
  $CharacterTableTable createAlias(String alias) {
    return $CharacterTableTable(attachedDatabase, alias);
  }
}

class CharacterTableData extends DataClass
    implements Insertable<CharacterTableData> {
  final String uuid;
  final String name;
  final String? imagePath;
  final String? imageAsset;
  final String? displacement;
  final String? senses;
  final int? divinityId;
  final int defense;
  final int life;
  final int mana;
  final int strength;
  final int dexterity;
  final int constitution;
  final int intelligence;
  final int wisdom;
  final int charisma;
  final int creatureSizeIndex;
  final int broodIndex;
  final String? grimoireUuid;
  final int createdAt;
  final int updatedAt;
  final String? trainedExpertisesIndexes;
  final int aligmentIndex;
  const CharacterTableData({
    required this.uuid,
    required this.name,
    this.imagePath,
    this.imageAsset,
    this.displacement,
    this.senses,
    this.divinityId,
    required this.defense,
    required this.life,
    required this.mana,
    required this.strength,
    required this.dexterity,
    required this.constitution,
    required this.intelligence,
    required this.wisdom,
    required this.charisma,
    required this.creatureSizeIndex,
    required this.broodIndex,
    this.grimoireUuid,
    required this.createdAt,
    required this.updatedAt,
    this.trainedExpertisesIndexes,
    required this.aligmentIndex,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['uuid'] = Variable<String>(uuid);
    map['name'] = Variable<String>(name);
    if (!nullToAbsent || imagePath != null) {
      map['image_path'] = Variable<String>(imagePath);
    }
    if (!nullToAbsent || imageAsset != null) {
      map['image_asset'] = Variable<String>(imageAsset);
    }
    if (!nullToAbsent || displacement != null) {
      map['displacement'] = Variable<String>(displacement);
    }
    if (!nullToAbsent || senses != null) {
      map['senses'] = Variable<String>(senses);
    }
    if (!nullToAbsent || divinityId != null) {
      map['divinity_id'] = Variable<int>(divinityId);
    }
    map['defense'] = Variable<int>(defense);
    map['life'] = Variable<int>(life);
    map['mana'] = Variable<int>(mana);
    map['strength'] = Variable<int>(strength);
    map['dexterity'] = Variable<int>(dexterity);
    map['constitution'] = Variable<int>(constitution);
    map['intelligence'] = Variable<int>(intelligence);
    map['wisdom'] = Variable<int>(wisdom);
    map['charisma'] = Variable<int>(charisma);
    map['creature_size_index'] = Variable<int>(creatureSizeIndex);
    map['brood_index'] = Variable<int>(broodIndex);
    if (!nullToAbsent || grimoireUuid != null) {
      map['grimoire_uuid'] = Variable<String>(grimoireUuid);
    }
    map['created_at'] = Variable<int>(createdAt);
    map['updated_at'] = Variable<int>(updatedAt);
    if (!nullToAbsent || trainedExpertisesIndexes != null) {
      map['trained_expertises_indexes'] = Variable<String>(
        trainedExpertisesIndexes,
      );
    }
    map['aligment_index'] = Variable<int>(aligmentIndex);
    return map;
  }

  CharacterTableCompanion toCompanion(bool nullToAbsent) {
    return CharacterTableCompanion(
      uuid: Value(uuid),
      name: Value(name),
      imagePath: imagePath == null && nullToAbsent
          ? const Value.absent()
          : Value(imagePath),
      imageAsset: imageAsset == null && nullToAbsent
          ? const Value.absent()
          : Value(imageAsset),
      displacement: displacement == null && nullToAbsent
          ? const Value.absent()
          : Value(displacement),
      senses: senses == null && nullToAbsent
          ? const Value.absent()
          : Value(senses),
      divinityId: divinityId == null && nullToAbsent
          ? const Value.absent()
          : Value(divinityId),
      defense: Value(defense),
      life: Value(life),
      mana: Value(mana),
      strength: Value(strength),
      dexterity: Value(dexterity),
      constitution: Value(constitution),
      intelligence: Value(intelligence),
      wisdom: Value(wisdom),
      charisma: Value(charisma),
      creatureSizeIndex: Value(creatureSizeIndex),
      broodIndex: Value(broodIndex),
      grimoireUuid: grimoireUuid == null && nullToAbsent
          ? const Value.absent()
          : Value(grimoireUuid),
      createdAt: Value(createdAt),
      updatedAt: Value(updatedAt),
      trainedExpertisesIndexes: trainedExpertisesIndexes == null && nullToAbsent
          ? const Value.absent()
          : Value(trainedExpertisesIndexes),
      aligmentIndex: Value(aligmentIndex),
    );
  }

  factory CharacterTableData.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return CharacterTableData(
      uuid: serializer.fromJson<String>(json['uuid']),
      name: serializer.fromJson<String>(json['name']),
      imagePath: serializer.fromJson<String?>(json['imagePath']),
      imageAsset: serializer.fromJson<String?>(json['imageAsset']),
      displacement: serializer.fromJson<String?>(json['displacement']),
      senses: serializer.fromJson<String?>(json['senses']),
      divinityId: serializer.fromJson<int?>(json['divinityId']),
      defense: serializer.fromJson<int>(json['defense']),
      life: serializer.fromJson<int>(json['life']),
      mana: serializer.fromJson<int>(json['mana']),
      strength: serializer.fromJson<int>(json['strength']),
      dexterity: serializer.fromJson<int>(json['dexterity']),
      constitution: serializer.fromJson<int>(json['constitution']),
      intelligence: serializer.fromJson<int>(json['intelligence']),
      wisdom: serializer.fromJson<int>(json['wisdom']),
      charisma: serializer.fromJson<int>(json['charisma']),
      creatureSizeIndex: serializer.fromJson<int>(json['creatureSizeIndex']),
      broodIndex: serializer.fromJson<int>(json['broodIndex']),
      grimoireUuid: serializer.fromJson<String?>(json['grimoireUuid']),
      createdAt: serializer.fromJson<int>(json['createdAt']),
      updatedAt: serializer.fromJson<int>(json['updatedAt']),
      trainedExpertisesIndexes: serializer.fromJson<String?>(
        json['trainedExpertisesIndexes'],
      ),
      aligmentIndex: serializer.fromJson<int>(json['aligmentIndex']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'uuid': serializer.toJson<String>(uuid),
      'name': serializer.toJson<String>(name),
      'imagePath': serializer.toJson<String?>(imagePath),
      'imageAsset': serializer.toJson<String?>(imageAsset),
      'displacement': serializer.toJson<String?>(displacement),
      'senses': serializer.toJson<String?>(senses),
      'divinityId': serializer.toJson<int?>(divinityId),
      'defense': serializer.toJson<int>(defense),
      'life': serializer.toJson<int>(life),
      'mana': serializer.toJson<int>(mana),
      'strength': serializer.toJson<int>(strength),
      'dexterity': serializer.toJson<int>(dexterity),
      'constitution': serializer.toJson<int>(constitution),
      'intelligence': serializer.toJson<int>(intelligence),
      'wisdom': serializer.toJson<int>(wisdom),
      'charisma': serializer.toJson<int>(charisma),
      'creatureSizeIndex': serializer.toJson<int>(creatureSizeIndex),
      'broodIndex': serializer.toJson<int>(broodIndex),
      'grimoireUuid': serializer.toJson<String?>(grimoireUuid),
      'createdAt': serializer.toJson<int>(createdAt),
      'updatedAt': serializer.toJson<int>(updatedAt),
      'trainedExpertisesIndexes': serializer.toJson<String?>(
        trainedExpertisesIndexes,
      ),
      'aligmentIndex': serializer.toJson<int>(aligmentIndex),
    };
  }

  CharacterTableData copyWith({
    String? uuid,
    String? name,
    Value<String?> imagePath = const Value.absent(),
    Value<String?> imageAsset = const Value.absent(),
    Value<String?> displacement = const Value.absent(),
    Value<String?> senses = const Value.absent(),
    Value<int?> divinityId = const Value.absent(),
    int? defense,
    int? life,
    int? mana,
    int? strength,
    int? dexterity,
    int? constitution,
    int? intelligence,
    int? wisdom,
    int? charisma,
    int? creatureSizeIndex,
    int? broodIndex,
    Value<String?> grimoireUuid = const Value.absent(),
    int? createdAt,
    int? updatedAt,
    Value<String?> trainedExpertisesIndexes = const Value.absent(),
    int? aligmentIndex,
  }) => CharacterTableData(
    uuid: uuid ?? this.uuid,
    name: name ?? this.name,
    imagePath: imagePath.present ? imagePath.value : this.imagePath,
    imageAsset: imageAsset.present ? imageAsset.value : this.imageAsset,
    displacement: displacement.present ? displacement.value : this.displacement,
    senses: senses.present ? senses.value : this.senses,
    divinityId: divinityId.present ? divinityId.value : this.divinityId,
    defense: defense ?? this.defense,
    life: life ?? this.life,
    mana: mana ?? this.mana,
    strength: strength ?? this.strength,
    dexterity: dexterity ?? this.dexterity,
    constitution: constitution ?? this.constitution,
    intelligence: intelligence ?? this.intelligence,
    wisdom: wisdom ?? this.wisdom,
    charisma: charisma ?? this.charisma,
    creatureSizeIndex: creatureSizeIndex ?? this.creatureSizeIndex,
    broodIndex: broodIndex ?? this.broodIndex,
    grimoireUuid: grimoireUuid.present ? grimoireUuid.value : this.grimoireUuid,
    createdAt: createdAt ?? this.createdAt,
    updatedAt: updatedAt ?? this.updatedAt,
    trainedExpertisesIndexes: trainedExpertisesIndexes.present
        ? trainedExpertisesIndexes.value
        : this.trainedExpertisesIndexes,
    aligmentIndex: aligmentIndex ?? this.aligmentIndex,
  );
  CharacterTableData copyWithCompanion(CharacterTableCompanion data) {
    return CharacterTableData(
      uuid: data.uuid.present ? data.uuid.value : this.uuid,
      name: data.name.present ? data.name.value : this.name,
      imagePath: data.imagePath.present ? data.imagePath.value : this.imagePath,
      imageAsset: data.imageAsset.present
          ? data.imageAsset.value
          : this.imageAsset,
      displacement: data.displacement.present
          ? data.displacement.value
          : this.displacement,
      senses: data.senses.present ? data.senses.value : this.senses,
      divinityId: data.divinityId.present
          ? data.divinityId.value
          : this.divinityId,
      defense: data.defense.present ? data.defense.value : this.defense,
      life: data.life.present ? data.life.value : this.life,
      mana: data.mana.present ? data.mana.value : this.mana,
      strength: data.strength.present ? data.strength.value : this.strength,
      dexterity: data.dexterity.present ? data.dexterity.value : this.dexterity,
      constitution: data.constitution.present
          ? data.constitution.value
          : this.constitution,
      intelligence: data.intelligence.present
          ? data.intelligence.value
          : this.intelligence,
      wisdom: data.wisdom.present ? data.wisdom.value : this.wisdom,
      charisma: data.charisma.present ? data.charisma.value : this.charisma,
      creatureSizeIndex: data.creatureSizeIndex.present
          ? data.creatureSizeIndex.value
          : this.creatureSizeIndex,
      broodIndex: data.broodIndex.present
          ? data.broodIndex.value
          : this.broodIndex,
      grimoireUuid: data.grimoireUuid.present
          ? data.grimoireUuid.value
          : this.grimoireUuid,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
      trainedExpertisesIndexes: data.trainedExpertisesIndexes.present
          ? data.trainedExpertisesIndexes.value
          : this.trainedExpertisesIndexes,
      aligmentIndex: data.aligmentIndex.present
          ? data.aligmentIndex.value
          : this.aligmentIndex,
    );
  }

  @override
  String toString() {
    return (StringBuffer('CharacterTableData(')
          ..write('uuid: $uuid, ')
          ..write('name: $name, ')
          ..write('imagePath: $imagePath, ')
          ..write('imageAsset: $imageAsset, ')
          ..write('displacement: $displacement, ')
          ..write('senses: $senses, ')
          ..write('divinityId: $divinityId, ')
          ..write('defense: $defense, ')
          ..write('life: $life, ')
          ..write('mana: $mana, ')
          ..write('strength: $strength, ')
          ..write('dexterity: $dexterity, ')
          ..write('constitution: $constitution, ')
          ..write('intelligence: $intelligence, ')
          ..write('wisdom: $wisdom, ')
          ..write('charisma: $charisma, ')
          ..write('creatureSizeIndex: $creatureSizeIndex, ')
          ..write('broodIndex: $broodIndex, ')
          ..write('grimoireUuid: $grimoireUuid, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('trainedExpertisesIndexes: $trainedExpertisesIndexes, ')
          ..write('aligmentIndex: $aligmentIndex')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hashAll([
    uuid,
    name,
    imagePath,
    imageAsset,
    displacement,
    senses,
    divinityId,
    defense,
    life,
    mana,
    strength,
    dexterity,
    constitution,
    intelligence,
    wisdom,
    charisma,
    creatureSizeIndex,
    broodIndex,
    grimoireUuid,
    createdAt,
    updatedAt,
    trainedExpertisesIndexes,
    aligmentIndex,
  ]);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is CharacterTableData &&
          other.uuid == this.uuid &&
          other.name == this.name &&
          other.imagePath == this.imagePath &&
          other.imageAsset == this.imageAsset &&
          other.displacement == this.displacement &&
          other.senses == this.senses &&
          other.divinityId == this.divinityId &&
          other.defense == this.defense &&
          other.life == this.life &&
          other.mana == this.mana &&
          other.strength == this.strength &&
          other.dexterity == this.dexterity &&
          other.constitution == this.constitution &&
          other.intelligence == this.intelligence &&
          other.wisdom == this.wisdom &&
          other.charisma == this.charisma &&
          other.creatureSizeIndex == this.creatureSizeIndex &&
          other.broodIndex == this.broodIndex &&
          other.grimoireUuid == this.grimoireUuid &&
          other.createdAt == this.createdAt &&
          other.updatedAt == this.updatedAt &&
          other.trainedExpertisesIndexes == this.trainedExpertisesIndexes &&
          other.aligmentIndex == this.aligmentIndex);
}

class CharacterTableCompanion extends UpdateCompanion<CharacterTableData> {
  final Value<String> uuid;
  final Value<String> name;
  final Value<String?> imagePath;
  final Value<String?> imageAsset;
  final Value<String?> displacement;
  final Value<String?> senses;
  final Value<int?> divinityId;
  final Value<int> defense;
  final Value<int> life;
  final Value<int> mana;
  final Value<int> strength;
  final Value<int> dexterity;
  final Value<int> constitution;
  final Value<int> intelligence;
  final Value<int> wisdom;
  final Value<int> charisma;
  final Value<int> creatureSizeIndex;
  final Value<int> broodIndex;
  final Value<String?> grimoireUuid;
  final Value<int> createdAt;
  final Value<int> updatedAt;
  final Value<String?> trainedExpertisesIndexes;
  final Value<int> aligmentIndex;
  final Value<int> rowid;
  const CharacterTableCompanion({
    this.uuid = const Value.absent(),
    this.name = const Value.absent(),
    this.imagePath = const Value.absent(),
    this.imageAsset = const Value.absent(),
    this.displacement = const Value.absent(),
    this.senses = const Value.absent(),
    this.divinityId = const Value.absent(),
    this.defense = const Value.absent(),
    this.life = const Value.absent(),
    this.mana = const Value.absent(),
    this.strength = const Value.absent(),
    this.dexterity = const Value.absent(),
    this.constitution = const Value.absent(),
    this.intelligence = const Value.absent(),
    this.wisdom = const Value.absent(),
    this.charisma = const Value.absent(),
    this.creatureSizeIndex = const Value.absent(),
    this.broodIndex = const Value.absent(),
    this.grimoireUuid = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.trainedExpertisesIndexes = const Value.absent(),
    this.aligmentIndex = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  CharacterTableCompanion.insert({
    required String uuid,
    required String name,
    this.imagePath = const Value.absent(),
    this.imageAsset = const Value.absent(),
    this.displacement = const Value.absent(),
    this.senses = const Value.absent(),
    this.divinityId = const Value.absent(),
    required int defense,
    required int life,
    required int mana,
    required int strength,
    required int dexterity,
    required int constitution,
    required int intelligence,
    required int wisdom,
    required int charisma,
    required int creatureSizeIndex,
    required int broodIndex,
    this.grimoireUuid = const Value.absent(),
    required int createdAt,
    required int updatedAt,
    this.trainedExpertisesIndexes = const Value.absent(),
    required int aligmentIndex,
    this.rowid = const Value.absent(),
  }) : uuid = Value(uuid),
       name = Value(name),
       defense = Value(defense),
       life = Value(life),
       mana = Value(mana),
       strength = Value(strength),
       dexterity = Value(dexterity),
       constitution = Value(constitution),
       intelligence = Value(intelligence),
       wisdom = Value(wisdom),
       charisma = Value(charisma),
       creatureSizeIndex = Value(creatureSizeIndex),
       broodIndex = Value(broodIndex),
       createdAt = Value(createdAt),
       updatedAt = Value(updatedAt),
       aligmentIndex = Value(aligmentIndex);
  static Insertable<CharacterTableData> custom({
    Expression<String>? uuid,
    Expression<String>? name,
    Expression<String>? imagePath,
    Expression<String>? imageAsset,
    Expression<String>? displacement,
    Expression<String>? senses,
    Expression<int>? divinityId,
    Expression<int>? defense,
    Expression<int>? life,
    Expression<int>? mana,
    Expression<int>? strength,
    Expression<int>? dexterity,
    Expression<int>? constitution,
    Expression<int>? intelligence,
    Expression<int>? wisdom,
    Expression<int>? charisma,
    Expression<int>? creatureSizeIndex,
    Expression<int>? broodIndex,
    Expression<String>? grimoireUuid,
    Expression<int>? createdAt,
    Expression<int>? updatedAt,
    Expression<String>? trainedExpertisesIndexes,
    Expression<int>? aligmentIndex,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (uuid != null) 'uuid': uuid,
      if (name != null) 'name': name,
      if (imagePath != null) 'image_path': imagePath,
      if (imageAsset != null) 'image_asset': imageAsset,
      if (displacement != null) 'displacement': displacement,
      if (senses != null) 'senses': senses,
      if (divinityId != null) 'divinity_id': divinityId,
      if (defense != null) 'defense': defense,
      if (life != null) 'life': life,
      if (mana != null) 'mana': mana,
      if (strength != null) 'strength': strength,
      if (dexterity != null) 'dexterity': dexterity,
      if (constitution != null) 'constitution': constitution,
      if (intelligence != null) 'intelligence': intelligence,
      if (wisdom != null) 'wisdom': wisdom,
      if (charisma != null) 'charisma': charisma,
      if (creatureSizeIndex != null) 'creature_size_index': creatureSizeIndex,
      if (broodIndex != null) 'brood_index': broodIndex,
      if (grimoireUuid != null) 'grimoire_uuid': grimoireUuid,
      if (createdAt != null) 'created_at': createdAt,
      if (updatedAt != null) 'updated_at': updatedAt,
      if (trainedExpertisesIndexes != null)
        'trained_expertises_indexes': trainedExpertisesIndexes,
      if (aligmentIndex != null) 'aligment_index': aligmentIndex,
      if (rowid != null) 'rowid': rowid,
    });
  }

  CharacterTableCompanion copyWith({
    Value<String>? uuid,
    Value<String>? name,
    Value<String?>? imagePath,
    Value<String?>? imageAsset,
    Value<String?>? displacement,
    Value<String?>? senses,
    Value<int?>? divinityId,
    Value<int>? defense,
    Value<int>? life,
    Value<int>? mana,
    Value<int>? strength,
    Value<int>? dexterity,
    Value<int>? constitution,
    Value<int>? intelligence,
    Value<int>? wisdom,
    Value<int>? charisma,
    Value<int>? creatureSizeIndex,
    Value<int>? broodIndex,
    Value<String?>? grimoireUuid,
    Value<int>? createdAt,
    Value<int>? updatedAt,
    Value<String?>? trainedExpertisesIndexes,
    Value<int>? aligmentIndex,
    Value<int>? rowid,
  }) {
    return CharacterTableCompanion(
      uuid: uuid ?? this.uuid,
      name: name ?? this.name,
      imagePath: imagePath ?? this.imagePath,
      imageAsset: imageAsset ?? this.imageAsset,
      displacement: displacement ?? this.displacement,
      senses: senses ?? this.senses,
      divinityId: divinityId ?? this.divinityId,
      defense: defense ?? this.defense,
      life: life ?? this.life,
      mana: mana ?? this.mana,
      strength: strength ?? this.strength,
      dexterity: dexterity ?? this.dexterity,
      constitution: constitution ?? this.constitution,
      intelligence: intelligence ?? this.intelligence,
      wisdom: wisdom ?? this.wisdom,
      charisma: charisma ?? this.charisma,
      creatureSizeIndex: creatureSizeIndex ?? this.creatureSizeIndex,
      broodIndex: broodIndex ?? this.broodIndex,
      grimoireUuid: grimoireUuid ?? this.grimoireUuid,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
      trainedExpertisesIndexes:
          trainedExpertisesIndexes ?? this.trainedExpertisesIndexes,
      aligmentIndex: aligmentIndex ?? this.aligmentIndex,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (uuid.present) {
      map['uuid'] = Variable<String>(uuid.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    if (imagePath.present) {
      map['image_path'] = Variable<String>(imagePath.value);
    }
    if (imageAsset.present) {
      map['image_asset'] = Variable<String>(imageAsset.value);
    }
    if (displacement.present) {
      map['displacement'] = Variable<String>(displacement.value);
    }
    if (senses.present) {
      map['senses'] = Variable<String>(senses.value);
    }
    if (divinityId.present) {
      map['divinity_id'] = Variable<int>(divinityId.value);
    }
    if (defense.present) {
      map['defense'] = Variable<int>(defense.value);
    }
    if (life.present) {
      map['life'] = Variable<int>(life.value);
    }
    if (mana.present) {
      map['mana'] = Variable<int>(mana.value);
    }
    if (strength.present) {
      map['strength'] = Variable<int>(strength.value);
    }
    if (dexterity.present) {
      map['dexterity'] = Variable<int>(dexterity.value);
    }
    if (constitution.present) {
      map['constitution'] = Variable<int>(constitution.value);
    }
    if (intelligence.present) {
      map['intelligence'] = Variable<int>(intelligence.value);
    }
    if (wisdom.present) {
      map['wisdom'] = Variable<int>(wisdom.value);
    }
    if (charisma.present) {
      map['charisma'] = Variable<int>(charisma.value);
    }
    if (creatureSizeIndex.present) {
      map['creature_size_index'] = Variable<int>(creatureSizeIndex.value);
    }
    if (broodIndex.present) {
      map['brood_index'] = Variable<int>(broodIndex.value);
    }
    if (grimoireUuid.present) {
      map['grimoire_uuid'] = Variable<String>(grimoireUuid.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<int>(createdAt.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<int>(updatedAt.value);
    }
    if (trainedExpertisesIndexes.present) {
      map['trained_expertises_indexes'] = Variable<String>(
        trainedExpertisesIndexes.value,
      );
    }
    if (aligmentIndex.present) {
      map['aligment_index'] = Variable<int>(aligmentIndex.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('CharacterTableCompanion(')
          ..write('uuid: $uuid, ')
          ..write('name: $name, ')
          ..write('imagePath: $imagePath, ')
          ..write('imageAsset: $imageAsset, ')
          ..write('displacement: $displacement, ')
          ..write('senses: $senses, ')
          ..write('divinityId: $divinityId, ')
          ..write('defense: $defense, ')
          ..write('life: $life, ')
          ..write('mana: $mana, ')
          ..write('strength: $strength, ')
          ..write('dexterity: $dexterity, ')
          ..write('constitution: $constitution, ')
          ..write('intelligence: $intelligence, ')
          ..write('wisdom: $wisdom, ')
          ..write('charisma: $charisma, ')
          ..write('creatureSizeIndex: $creatureSizeIndex, ')
          ..write('broodIndex: $broodIndex, ')
          ..write('grimoireUuid: $grimoireUuid, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('trainedExpertisesIndexes: $trainedExpertisesIndexes, ')
          ..write('aligmentIndex: $aligmentIndex, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $ClasseCharacterTableTable extends ClasseCharacterTable
    with TableInfo<$ClasseCharacterTableTable, ClasseCharacterTableData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $ClasseCharacterTableTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _uuidMeta = const VerificationMeta('uuid');
  @override
  late final GeneratedColumn<String> uuid = GeneratedColumn<String>(
    'uuid',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _characterUuidMeta = const VerificationMeta(
    'characterUuid',
  );
  @override
  late final GeneratedColumn<String> characterUuid = GeneratedColumn<String>(
    'character_uuid',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _typeIndexMeta = const VerificationMeta(
    'typeIndex',
  );
  @override
  late final GeneratedColumn<int> typeIndex = GeneratedColumn<int>(
    'type_index',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _levelMeta = const VerificationMeta('level');
  @override
  late final GeneratedColumn<int> level = GeneratedColumn<int>(
    'level',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  @override
  List<GeneratedColumn> get $columns => [uuid, characterUuid, typeIndex, level];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'classe_character_table';
  @override
  VerificationContext validateIntegrity(
    Insertable<ClasseCharacterTableData> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('uuid')) {
      context.handle(
        _uuidMeta,
        uuid.isAcceptableOrUnknown(data['uuid']!, _uuidMeta),
      );
    } else if (isInserting) {
      context.missing(_uuidMeta);
    }
    if (data.containsKey('character_uuid')) {
      context.handle(
        _characterUuidMeta,
        characterUuid.isAcceptableOrUnknown(
          data['character_uuid']!,
          _characterUuidMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_characterUuidMeta);
    }
    if (data.containsKey('type_index')) {
      context.handle(
        _typeIndexMeta,
        typeIndex.isAcceptableOrUnknown(data['type_index']!, _typeIndexMeta),
      );
    } else if (isInserting) {
      context.missing(_typeIndexMeta);
    }
    if (data.containsKey('level')) {
      context.handle(
        _levelMeta,
        level.isAcceptableOrUnknown(data['level']!, _levelMeta),
      );
    } else if (isInserting) {
      context.missing(_levelMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {uuid};
  @override
  ClasseCharacterTableData map(
    Map<String, dynamic> data, {
    String? tablePrefix,
  }) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return ClasseCharacterTableData(
      uuid: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}uuid'],
      )!,
      characterUuid: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}character_uuid'],
      )!,
      typeIndex: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}type_index'],
      )!,
      level: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}level'],
      )!,
    );
  }

  @override
  $ClasseCharacterTableTable createAlias(String alias) {
    return $ClasseCharacterTableTable(attachedDatabase, alias);
  }
}

class ClasseCharacterTableData extends DataClass
    implements Insertable<ClasseCharacterTableData> {
  final String uuid;
  final String characterUuid;
  final int typeIndex;
  final int level;
  const ClasseCharacterTableData({
    required this.uuid,
    required this.characterUuid,
    required this.typeIndex,
    required this.level,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['uuid'] = Variable<String>(uuid);
    map['character_uuid'] = Variable<String>(characterUuid);
    map['type_index'] = Variable<int>(typeIndex);
    map['level'] = Variable<int>(level);
    return map;
  }

  ClasseCharacterTableCompanion toCompanion(bool nullToAbsent) {
    return ClasseCharacterTableCompanion(
      uuid: Value(uuid),
      characterUuid: Value(characterUuid),
      typeIndex: Value(typeIndex),
      level: Value(level),
    );
  }

  factory ClasseCharacterTableData.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return ClasseCharacterTableData(
      uuid: serializer.fromJson<String>(json['uuid']),
      characterUuid: serializer.fromJson<String>(json['characterUuid']),
      typeIndex: serializer.fromJson<int>(json['typeIndex']),
      level: serializer.fromJson<int>(json['level']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'uuid': serializer.toJson<String>(uuid),
      'characterUuid': serializer.toJson<String>(characterUuid),
      'typeIndex': serializer.toJson<int>(typeIndex),
      'level': serializer.toJson<int>(level),
    };
  }

  ClasseCharacterTableData copyWith({
    String? uuid,
    String? characterUuid,
    int? typeIndex,
    int? level,
  }) => ClasseCharacterTableData(
    uuid: uuid ?? this.uuid,
    characterUuid: characterUuid ?? this.characterUuid,
    typeIndex: typeIndex ?? this.typeIndex,
    level: level ?? this.level,
  );
  ClasseCharacterTableData copyWithCompanion(
    ClasseCharacterTableCompanion data,
  ) {
    return ClasseCharacterTableData(
      uuid: data.uuid.present ? data.uuid.value : this.uuid,
      characterUuid: data.characterUuid.present
          ? data.characterUuid.value
          : this.characterUuid,
      typeIndex: data.typeIndex.present ? data.typeIndex.value : this.typeIndex,
      level: data.level.present ? data.level.value : this.level,
    );
  }

  @override
  String toString() {
    return (StringBuffer('ClasseCharacterTableData(')
          ..write('uuid: $uuid, ')
          ..write('characterUuid: $characterUuid, ')
          ..write('typeIndex: $typeIndex, ')
          ..write('level: $level')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(uuid, characterUuid, typeIndex, level);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is ClasseCharacterTableData &&
          other.uuid == this.uuid &&
          other.characterUuid == this.characterUuid &&
          other.typeIndex == this.typeIndex &&
          other.level == this.level);
}

class ClasseCharacterTableCompanion
    extends UpdateCompanion<ClasseCharacterTableData> {
  final Value<String> uuid;
  final Value<String> characterUuid;
  final Value<int> typeIndex;
  final Value<int> level;
  final Value<int> rowid;
  const ClasseCharacterTableCompanion({
    this.uuid = const Value.absent(),
    this.characterUuid = const Value.absent(),
    this.typeIndex = const Value.absent(),
    this.level = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  ClasseCharacterTableCompanion.insert({
    required String uuid,
    required String characterUuid,
    required int typeIndex,
    required int level,
    this.rowid = const Value.absent(),
  }) : uuid = Value(uuid),
       characterUuid = Value(characterUuid),
       typeIndex = Value(typeIndex),
       level = Value(level);
  static Insertable<ClasseCharacterTableData> custom({
    Expression<String>? uuid,
    Expression<String>? characterUuid,
    Expression<int>? typeIndex,
    Expression<int>? level,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (uuid != null) 'uuid': uuid,
      if (characterUuid != null) 'character_uuid': characterUuid,
      if (typeIndex != null) 'type_index': typeIndex,
      if (level != null) 'level': level,
      if (rowid != null) 'rowid': rowid,
    });
  }

  ClasseCharacterTableCompanion copyWith({
    Value<String>? uuid,
    Value<String>? characterUuid,
    Value<int>? typeIndex,
    Value<int>? level,
    Value<int>? rowid,
  }) {
    return ClasseCharacterTableCompanion(
      uuid: uuid ?? this.uuid,
      characterUuid: characterUuid ?? this.characterUuid,
      typeIndex: typeIndex ?? this.typeIndex,
      level: level ?? this.level,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (uuid.present) {
      map['uuid'] = Variable<String>(uuid.value);
    }
    if (characterUuid.present) {
      map['character_uuid'] = Variable<String>(characterUuid.value);
    }
    if (typeIndex.present) {
      map['type_index'] = Variable<int>(typeIndex.value);
    }
    if (level.present) {
      map['level'] = Variable<int>(level.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('ClasseCharacterTableCompanion(')
          ..write('uuid: $uuid, ')
          ..write('characterUuid: $characterUuid, ')
          ..write('typeIndex: $typeIndex, ')
          ..write('level: $level, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $OriginTableTable extends OriginTable
    with TableInfo<$OriginTableTable, OriginTableData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $OriginTableTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _uuidMeta = const VerificationMeta('uuid');
  @override
  late final GeneratedColumn<String> uuid = GeneratedColumn<String>(
    'uuid',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _characterUuidMeta = const VerificationMeta(
    'characterUuid',
  );
  @override
  late final GeneratedColumn<String> characterUuid = GeneratedColumn<String>(
    'character_uuid',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
    'name',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _descMeta = const VerificationMeta('desc');
  @override
  late final GeneratedColumn<String> desc = GeneratedColumn<String>(
    'desc',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<int> createdAt = GeneratedColumn<int>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _updatedAtMeta = const VerificationMeta(
    'updatedAt',
  );
  @override
  late final GeneratedColumn<int> updatedAt = GeneratedColumn<int>(
    'updated_at',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  @override
  List<GeneratedColumn> get $columns => [
    uuid,
    characterUuid,
    name,
    desc,
    createdAt,
    updatedAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'origin_table';
  @override
  VerificationContext validateIntegrity(
    Insertable<OriginTableData> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('uuid')) {
      context.handle(
        _uuidMeta,
        uuid.isAcceptableOrUnknown(data['uuid']!, _uuidMeta),
      );
    } else if (isInserting) {
      context.missing(_uuidMeta);
    }
    if (data.containsKey('character_uuid')) {
      context.handle(
        _characterUuidMeta,
        characterUuid.isAcceptableOrUnknown(
          data['character_uuid']!,
          _characterUuidMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_characterUuidMeta);
    }
    if (data.containsKey('name')) {
      context.handle(
        _nameMeta,
        name.isAcceptableOrUnknown(data['name']!, _nameMeta),
      );
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    if (data.containsKey('desc')) {
      context.handle(
        _descMeta,
        desc.isAcceptableOrUnknown(data['desc']!, _descMeta),
      );
    } else if (isInserting) {
      context.missing(_descMeta);
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    } else if (isInserting) {
      context.missing(_createdAtMeta);
    }
    if (data.containsKey('updated_at')) {
      context.handle(
        _updatedAtMeta,
        updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta),
      );
    } else if (isInserting) {
      context.missing(_updatedAtMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {uuid};
  @override
  OriginTableData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return OriginTableData(
      uuid: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}uuid'],
      )!,
      characterUuid: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}character_uuid'],
      )!,
      name: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}name'],
      )!,
      desc: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}desc'],
      )!,
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}created_at'],
      )!,
      updatedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}updated_at'],
      )!,
    );
  }

  @override
  $OriginTableTable createAlias(String alias) {
    return $OriginTableTable(attachedDatabase, alias);
  }
}

class OriginTableData extends DataClass implements Insertable<OriginTableData> {
  final String uuid;
  final String characterUuid;
  final String name;
  final String desc;
  final int createdAt;
  final int updatedAt;
  const OriginTableData({
    required this.uuid,
    required this.characterUuid,
    required this.name,
    required this.desc,
    required this.createdAt,
    required this.updatedAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['uuid'] = Variable<String>(uuid);
    map['character_uuid'] = Variable<String>(characterUuid);
    map['name'] = Variable<String>(name);
    map['desc'] = Variable<String>(desc);
    map['created_at'] = Variable<int>(createdAt);
    map['updated_at'] = Variable<int>(updatedAt);
    return map;
  }

  OriginTableCompanion toCompanion(bool nullToAbsent) {
    return OriginTableCompanion(
      uuid: Value(uuid),
      characterUuid: Value(characterUuid),
      name: Value(name),
      desc: Value(desc),
      createdAt: Value(createdAt),
      updatedAt: Value(updatedAt),
    );
  }

  factory OriginTableData.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return OriginTableData(
      uuid: serializer.fromJson<String>(json['uuid']),
      characterUuid: serializer.fromJson<String>(json['characterUuid']),
      name: serializer.fromJson<String>(json['name']),
      desc: serializer.fromJson<String>(json['desc']),
      createdAt: serializer.fromJson<int>(json['createdAt']),
      updatedAt: serializer.fromJson<int>(json['updatedAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'uuid': serializer.toJson<String>(uuid),
      'characterUuid': serializer.toJson<String>(characterUuid),
      'name': serializer.toJson<String>(name),
      'desc': serializer.toJson<String>(desc),
      'createdAt': serializer.toJson<int>(createdAt),
      'updatedAt': serializer.toJson<int>(updatedAt),
    };
  }

  OriginTableData copyWith({
    String? uuid,
    String? characterUuid,
    String? name,
    String? desc,
    int? createdAt,
    int? updatedAt,
  }) => OriginTableData(
    uuid: uuid ?? this.uuid,
    characterUuid: characterUuid ?? this.characterUuid,
    name: name ?? this.name,
    desc: desc ?? this.desc,
    createdAt: createdAt ?? this.createdAt,
    updatedAt: updatedAt ?? this.updatedAt,
  );
  OriginTableData copyWithCompanion(OriginTableCompanion data) {
    return OriginTableData(
      uuid: data.uuid.present ? data.uuid.value : this.uuid,
      characterUuid: data.characterUuid.present
          ? data.characterUuid.value
          : this.characterUuid,
      name: data.name.present ? data.name.value : this.name,
      desc: data.desc.present ? data.desc.value : this.desc,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('OriginTableData(')
          ..write('uuid: $uuid, ')
          ..write('characterUuid: $characterUuid, ')
          ..write('name: $name, ')
          ..write('desc: $desc, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode =>
      Object.hash(uuid, characterUuid, name, desc, createdAt, updatedAt);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is OriginTableData &&
          other.uuid == this.uuid &&
          other.characterUuid == this.characterUuid &&
          other.name == this.name &&
          other.desc == this.desc &&
          other.createdAt == this.createdAt &&
          other.updatedAt == this.updatedAt);
}

class OriginTableCompanion extends UpdateCompanion<OriginTableData> {
  final Value<String> uuid;
  final Value<String> characterUuid;
  final Value<String> name;
  final Value<String> desc;
  final Value<int> createdAt;
  final Value<int> updatedAt;
  final Value<int> rowid;
  const OriginTableCompanion({
    this.uuid = const Value.absent(),
    this.characterUuid = const Value.absent(),
    this.name = const Value.absent(),
    this.desc = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  OriginTableCompanion.insert({
    required String uuid,
    required String characterUuid,
    required String name,
    required String desc,
    required int createdAt,
    required int updatedAt,
    this.rowid = const Value.absent(),
  }) : uuid = Value(uuid),
       characterUuid = Value(characterUuid),
       name = Value(name),
       desc = Value(desc),
       createdAt = Value(createdAt),
       updatedAt = Value(updatedAt);
  static Insertable<OriginTableData> custom({
    Expression<String>? uuid,
    Expression<String>? characterUuid,
    Expression<String>? name,
    Expression<String>? desc,
    Expression<int>? createdAt,
    Expression<int>? updatedAt,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (uuid != null) 'uuid': uuid,
      if (characterUuid != null) 'character_uuid': characterUuid,
      if (name != null) 'name': name,
      if (desc != null) 'desc': desc,
      if (createdAt != null) 'created_at': createdAt,
      if (updatedAt != null) 'updated_at': updatedAt,
      if (rowid != null) 'rowid': rowid,
    });
  }

  OriginTableCompanion copyWith({
    Value<String>? uuid,
    Value<String>? characterUuid,
    Value<String>? name,
    Value<String>? desc,
    Value<int>? createdAt,
    Value<int>? updatedAt,
    Value<int>? rowid,
  }) {
    return OriginTableCompanion(
      uuid: uuid ?? this.uuid,
      characterUuid: characterUuid ?? this.characterUuid,
      name: name ?? this.name,
      desc: desc ?? this.desc,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (uuid.present) {
      map['uuid'] = Variable<String>(uuid.value);
    }
    if (characterUuid.present) {
      map['character_uuid'] = Variable<String>(characterUuid.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    if (desc.present) {
      map['desc'] = Variable<String>(desc.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<int>(createdAt.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<int>(updatedAt.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('OriginTableCompanion(')
          ..write('uuid: $uuid, ')
          ..write('characterUuid: $characterUuid, ')
          ..write('name: $name, ')
          ..write('desc: $desc, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $PowerTableTable extends PowerTable
    with TableInfo<$PowerTableTable, PowerTableData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $PowerTableTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _uuidMeta = const VerificationMeta('uuid');
  @override
  late final GeneratedColumn<String> uuid = GeneratedColumn<String>(
    'uuid',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
    'name',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _descMeta = const VerificationMeta('desc');
  @override
  late final GeneratedColumn<String> desc = GeneratedColumn<String>(
    'desc',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _characterUuidMeta = const VerificationMeta(
    'characterUuid',
  );
  @override
  late final GeneratedColumn<String> characterUuid = GeneratedColumn<String>(
    'character_uuid',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _typeIndexMeta = const VerificationMeta(
    'typeIndex',
  );
  @override
  late final GeneratedColumn<int> typeIndex = GeneratedColumn<int>(
    'type_index',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<int> createdAt = GeneratedColumn<int>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _updatedAtMeta = const VerificationMeta(
    'updatedAt',
  );
  @override
  late final GeneratedColumn<int> updatedAt = GeneratedColumn<int>(
    'updated_at',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  @override
  List<GeneratedColumn> get $columns => [
    uuid,
    name,
    desc,
    characterUuid,
    typeIndex,
    createdAt,
    updatedAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'power_table';
  @override
  VerificationContext validateIntegrity(
    Insertable<PowerTableData> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('uuid')) {
      context.handle(
        _uuidMeta,
        uuid.isAcceptableOrUnknown(data['uuid']!, _uuidMeta),
      );
    } else if (isInserting) {
      context.missing(_uuidMeta);
    }
    if (data.containsKey('name')) {
      context.handle(
        _nameMeta,
        name.isAcceptableOrUnknown(data['name']!, _nameMeta),
      );
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    if (data.containsKey('desc')) {
      context.handle(
        _descMeta,
        desc.isAcceptableOrUnknown(data['desc']!, _descMeta),
      );
    } else if (isInserting) {
      context.missing(_descMeta);
    }
    if (data.containsKey('character_uuid')) {
      context.handle(
        _characterUuidMeta,
        characterUuid.isAcceptableOrUnknown(
          data['character_uuid']!,
          _characterUuidMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_characterUuidMeta);
    }
    if (data.containsKey('type_index')) {
      context.handle(
        _typeIndexMeta,
        typeIndex.isAcceptableOrUnknown(data['type_index']!, _typeIndexMeta),
      );
    } else if (isInserting) {
      context.missing(_typeIndexMeta);
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    } else if (isInserting) {
      context.missing(_createdAtMeta);
    }
    if (data.containsKey('updated_at')) {
      context.handle(
        _updatedAtMeta,
        updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta),
      );
    } else if (isInserting) {
      context.missing(_updatedAtMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {uuid};
  @override
  PowerTableData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return PowerTableData(
      uuid: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}uuid'],
      )!,
      name: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}name'],
      )!,
      desc: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}desc'],
      )!,
      characterUuid: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}character_uuid'],
      )!,
      typeIndex: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}type_index'],
      )!,
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}created_at'],
      )!,
      updatedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}updated_at'],
      )!,
    );
  }

  @override
  $PowerTableTable createAlias(String alias) {
    return $PowerTableTable(attachedDatabase, alias);
  }
}

class PowerTableData extends DataClass implements Insertable<PowerTableData> {
  final String uuid;
  final String name;
  final String desc;
  final String characterUuid;
  final int typeIndex;
  final int createdAt;
  final int updatedAt;
  const PowerTableData({
    required this.uuid,
    required this.name,
    required this.desc,
    required this.characterUuid,
    required this.typeIndex,
    required this.createdAt,
    required this.updatedAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['uuid'] = Variable<String>(uuid);
    map['name'] = Variable<String>(name);
    map['desc'] = Variable<String>(desc);
    map['character_uuid'] = Variable<String>(characterUuid);
    map['type_index'] = Variable<int>(typeIndex);
    map['created_at'] = Variable<int>(createdAt);
    map['updated_at'] = Variable<int>(updatedAt);
    return map;
  }

  PowerTableCompanion toCompanion(bool nullToAbsent) {
    return PowerTableCompanion(
      uuid: Value(uuid),
      name: Value(name),
      desc: Value(desc),
      characterUuid: Value(characterUuid),
      typeIndex: Value(typeIndex),
      createdAt: Value(createdAt),
      updatedAt: Value(updatedAt),
    );
  }

  factory PowerTableData.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return PowerTableData(
      uuid: serializer.fromJson<String>(json['uuid']),
      name: serializer.fromJson<String>(json['name']),
      desc: serializer.fromJson<String>(json['desc']),
      characterUuid: serializer.fromJson<String>(json['characterUuid']),
      typeIndex: serializer.fromJson<int>(json['typeIndex']),
      createdAt: serializer.fromJson<int>(json['createdAt']),
      updatedAt: serializer.fromJson<int>(json['updatedAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'uuid': serializer.toJson<String>(uuid),
      'name': serializer.toJson<String>(name),
      'desc': serializer.toJson<String>(desc),
      'characterUuid': serializer.toJson<String>(characterUuid),
      'typeIndex': serializer.toJson<int>(typeIndex),
      'createdAt': serializer.toJson<int>(createdAt),
      'updatedAt': serializer.toJson<int>(updatedAt),
    };
  }

  PowerTableData copyWith({
    String? uuid,
    String? name,
    String? desc,
    String? characterUuid,
    int? typeIndex,
    int? createdAt,
    int? updatedAt,
  }) => PowerTableData(
    uuid: uuid ?? this.uuid,
    name: name ?? this.name,
    desc: desc ?? this.desc,
    characterUuid: characterUuid ?? this.characterUuid,
    typeIndex: typeIndex ?? this.typeIndex,
    createdAt: createdAt ?? this.createdAt,
    updatedAt: updatedAt ?? this.updatedAt,
  );
  PowerTableData copyWithCompanion(PowerTableCompanion data) {
    return PowerTableData(
      uuid: data.uuid.present ? data.uuid.value : this.uuid,
      name: data.name.present ? data.name.value : this.name,
      desc: data.desc.present ? data.desc.value : this.desc,
      characterUuid: data.characterUuid.present
          ? data.characterUuid.value
          : this.characterUuid,
      typeIndex: data.typeIndex.present ? data.typeIndex.value : this.typeIndex,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('PowerTableData(')
          ..write('uuid: $uuid, ')
          ..write('name: $name, ')
          ..write('desc: $desc, ')
          ..write('characterUuid: $characterUuid, ')
          ..write('typeIndex: $typeIndex, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    uuid,
    name,
    desc,
    characterUuid,
    typeIndex,
    createdAt,
    updatedAt,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is PowerTableData &&
          other.uuid == this.uuid &&
          other.name == this.name &&
          other.desc == this.desc &&
          other.characterUuid == this.characterUuid &&
          other.typeIndex == this.typeIndex &&
          other.createdAt == this.createdAt &&
          other.updatedAt == this.updatedAt);
}

class PowerTableCompanion extends UpdateCompanion<PowerTableData> {
  final Value<String> uuid;
  final Value<String> name;
  final Value<String> desc;
  final Value<String> characterUuid;
  final Value<int> typeIndex;
  final Value<int> createdAt;
  final Value<int> updatedAt;
  final Value<int> rowid;
  const PowerTableCompanion({
    this.uuid = const Value.absent(),
    this.name = const Value.absent(),
    this.desc = const Value.absent(),
    this.characterUuid = const Value.absent(),
    this.typeIndex = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  PowerTableCompanion.insert({
    required String uuid,
    required String name,
    required String desc,
    required String characterUuid,
    required int typeIndex,
    required int createdAt,
    required int updatedAt,
    this.rowid = const Value.absent(),
  }) : uuid = Value(uuid),
       name = Value(name),
       desc = Value(desc),
       characterUuid = Value(characterUuid),
       typeIndex = Value(typeIndex),
       createdAt = Value(createdAt),
       updatedAt = Value(updatedAt);
  static Insertable<PowerTableData> custom({
    Expression<String>? uuid,
    Expression<String>? name,
    Expression<String>? desc,
    Expression<String>? characterUuid,
    Expression<int>? typeIndex,
    Expression<int>? createdAt,
    Expression<int>? updatedAt,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (uuid != null) 'uuid': uuid,
      if (name != null) 'name': name,
      if (desc != null) 'desc': desc,
      if (characterUuid != null) 'character_uuid': characterUuid,
      if (typeIndex != null) 'type_index': typeIndex,
      if (createdAt != null) 'created_at': createdAt,
      if (updatedAt != null) 'updated_at': updatedAt,
      if (rowid != null) 'rowid': rowid,
    });
  }

  PowerTableCompanion copyWith({
    Value<String>? uuid,
    Value<String>? name,
    Value<String>? desc,
    Value<String>? characterUuid,
    Value<int>? typeIndex,
    Value<int>? createdAt,
    Value<int>? updatedAt,
    Value<int>? rowid,
  }) {
    return PowerTableCompanion(
      uuid: uuid ?? this.uuid,
      name: name ?? this.name,
      desc: desc ?? this.desc,
      characterUuid: characterUuid ?? this.characterUuid,
      typeIndex: typeIndex ?? this.typeIndex,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (uuid.present) {
      map['uuid'] = Variable<String>(uuid.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    if (desc.present) {
      map['desc'] = Variable<String>(desc.value);
    }
    if (characterUuid.present) {
      map['character_uuid'] = Variable<String>(characterUuid.value);
    }
    if (typeIndex.present) {
      map['type_index'] = Variable<int>(typeIndex.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<int>(createdAt.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<int>(updatedAt.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('PowerTableCompanion(')
          ..write('uuid: $uuid, ')
          ..write('name: $name, ')
          ..write('desc: $desc, ')
          ..write('characterUuid: $characterUuid, ')
          ..write('typeIndex: $typeIndex, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $CharacterBoardTableTable extends CharacterBoardTable
    with TableInfo<$CharacterBoardTableTable, CharacterBoardTableData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $CharacterBoardTableTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _uuidMeta = const VerificationMeta('uuid');
  @override
  late final GeneratedColumn<String> uuid = GeneratedColumn<String>(
    'uuid',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _parentuuidMeta = const VerificationMeta(
    'parentuuid',
  );
  @override
  late final GeneratedColumn<String> parentuuid = GeneratedColumn<String>(
    'parentuuid',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _boarduuidMeta = const VerificationMeta(
    'boarduuid',
  );
  @override
  late final GeneratedColumn<String> boarduuid = GeneratedColumn<String>(
    'boarduuid',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
    'name',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _imagePathMeta = const VerificationMeta(
    'imagePath',
  );
  @override
  late final GeneratedColumn<String> imagePath = GeneratedColumn<String>(
    'image_path',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _imageAssetMeta = const VerificationMeta(
    'imageAsset',
  );
  @override
  late final GeneratedColumn<String> imageAsset = GeneratedColumn<String>(
    'image_asset',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _displacementMeta = const VerificationMeta(
    'displacement',
  );
  @override
  late final GeneratedColumn<String> displacement = GeneratedColumn<String>(
    'displacement',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _sensesMeta = const VerificationMeta('senses');
  @override
  late final GeneratedColumn<String> senses = GeneratedColumn<String>(
    'senses',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _divinityIdMeta = const VerificationMeta(
    'divinityId',
  );
  @override
  late final GeneratedColumn<int> divinityId = GeneratedColumn<int>(
    'divinity_id',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _defenseMeta = const VerificationMeta(
    'defense',
  );
  @override
  late final GeneratedColumn<int> defense = GeneratedColumn<int>(
    'defense',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _lifeMeta = const VerificationMeta('life');
  @override
  late final GeneratedColumn<int> life = GeneratedColumn<int>(
    'life',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _manaMeta = const VerificationMeta('mana');
  @override
  late final GeneratedColumn<int> mana = GeneratedColumn<int>(
    'mana',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _strengthMeta = const VerificationMeta(
    'strength',
  );
  @override
  late final GeneratedColumn<int> strength = GeneratedColumn<int>(
    'strength',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _dexterityMeta = const VerificationMeta(
    'dexterity',
  );
  @override
  late final GeneratedColumn<int> dexterity = GeneratedColumn<int>(
    'dexterity',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _constitutionMeta = const VerificationMeta(
    'constitution',
  );
  @override
  late final GeneratedColumn<int> constitution = GeneratedColumn<int>(
    'constitution',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _intelligenceMeta = const VerificationMeta(
    'intelligence',
  );
  @override
  late final GeneratedColumn<int> intelligence = GeneratedColumn<int>(
    'intelligence',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _wisdomMeta = const VerificationMeta('wisdom');
  @override
  late final GeneratedColumn<int> wisdom = GeneratedColumn<int>(
    'wisdom',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _charismaMeta = const VerificationMeta(
    'charisma',
  );
  @override
  late final GeneratedColumn<int> charisma = GeneratedColumn<int>(
    'charisma',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _creatureSizeIndexMeta = const VerificationMeta(
    'creatureSizeIndex',
  );
  @override
  late final GeneratedColumn<int> creatureSizeIndex = GeneratedColumn<int>(
    'creature_size_index',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _broodIndexMeta = const VerificationMeta(
    'broodIndex',
  );
  @override
  late final GeneratedColumn<int> broodIndex = GeneratedColumn<int>(
    'brood_index',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _grimoireUuidMeta = const VerificationMeta(
    'grimoireUuid',
  );
  @override
  late final GeneratedColumn<String> grimoireUuid = GeneratedColumn<String>(
    'grimoire_uuid',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<int> createdAt = GeneratedColumn<int>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _updatedAtMeta = const VerificationMeta(
    'updatedAt',
  );
  @override
  late final GeneratedColumn<int> updatedAt = GeneratedColumn<int>(
    'updated_at',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _isAliveMeta = const VerificationMeta(
    'isAlive',
  );
  @override
  late final GeneratedColumn<bool> isAlive = GeneratedColumn<bool>(
    'is_alive',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_alive" IN (0, 1))',
    ),
  );
  static const VerificationMeta _aligmentIndexMeta = const VerificationMeta(
    'aligmentIndex',
  );
  @override
  late final GeneratedColumn<int> aligmentIndex = GeneratedColumn<int>(
    'aligment_index',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _currentLifeMeta = const VerificationMeta(
    'currentLife',
  );
  @override
  late final GeneratedColumn<int> currentLife = GeneratedColumn<int>(
    'current_life',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _currentManaMeta = const VerificationMeta(
    'currentMana',
  );
  @override
  late final GeneratedColumn<int> currentMana = GeneratedColumn<int>(
    'current_mana',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _inLeftHandMeta = const VerificationMeta(
    'inLeftHand',
  );
  @override
  late final GeneratedColumn<String> inLeftHand = GeneratedColumn<String>(
    'in_left_hand',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _inRightHandMeta = const VerificationMeta(
    'inRightHand',
  );
  @override
  late final GeneratedColumn<String> inRightHand = GeneratedColumn<String>(
    'in_right_hand',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _inTwoHandsMeta = const VerificationMeta(
    'inTwoHands',
  );
  @override
  late final GeneratedColumn<String> inTwoHands = GeneratedColumn<String>(
    'in_two_hands',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _inWearableSlotsMeta = const VerificationMeta(
    'inWearableSlots',
  );
  @override
  late final GeneratedColumn<String> inWearableSlots = GeneratedColumn<String>(
    'in_wearable_slots',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _handToHandAtributeIndexMeta =
      const VerificationMeta('handToHandAtributeIndex');
  @override
  late final GeneratedColumn<int> handToHandAtributeIndex =
      GeneratedColumn<int>(
        'hand_to_hand_atribute_index',
        aliasedName,
        true,
        type: DriftSqlType.int,
        requiredDuringInsert: false,
      );
  @override
  List<GeneratedColumn> get $columns => [
    uuid,
    parentuuid,
    boarduuid,
    name,
    imagePath,
    imageAsset,
    displacement,
    senses,
    divinityId,
    defense,
    life,
    mana,
    strength,
    dexterity,
    constitution,
    intelligence,
    wisdom,
    charisma,
    creatureSizeIndex,
    broodIndex,
    grimoireUuid,
    createdAt,
    updatedAt,
    isAlive,
    aligmentIndex,
    currentLife,
    currentMana,
    inLeftHand,
    inRightHand,
    inTwoHands,
    inWearableSlots,
    handToHandAtributeIndex,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'character_board_table';
  @override
  VerificationContext validateIntegrity(
    Insertable<CharacterBoardTableData> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('uuid')) {
      context.handle(
        _uuidMeta,
        uuid.isAcceptableOrUnknown(data['uuid']!, _uuidMeta),
      );
    } else if (isInserting) {
      context.missing(_uuidMeta);
    }
    if (data.containsKey('parentuuid')) {
      context.handle(
        _parentuuidMeta,
        parentuuid.isAcceptableOrUnknown(data['parentuuid']!, _parentuuidMeta),
      );
    } else if (isInserting) {
      context.missing(_parentuuidMeta);
    }
    if (data.containsKey('boarduuid')) {
      context.handle(
        _boarduuidMeta,
        boarduuid.isAcceptableOrUnknown(data['boarduuid']!, _boarduuidMeta),
      );
    } else if (isInserting) {
      context.missing(_boarduuidMeta);
    }
    if (data.containsKey('name')) {
      context.handle(
        _nameMeta,
        name.isAcceptableOrUnknown(data['name']!, _nameMeta),
      );
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    if (data.containsKey('image_path')) {
      context.handle(
        _imagePathMeta,
        imagePath.isAcceptableOrUnknown(data['image_path']!, _imagePathMeta),
      );
    }
    if (data.containsKey('image_asset')) {
      context.handle(
        _imageAssetMeta,
        imageAsset.isAcceptableOrUnknown(data['image_asset']!, _imageAssetMeta),
      );
    }
    if (data.containsKey('displacement')) {
      context.handle(
        _displacementMeta,
        displacement.isAcceptableOrUnknown(
          data['displacement']!,
          _displacementMeta,
        ),
      );
    }
    if (data.containsKey('senses')) {
      context.handle(
        _sensesMeta,
        senses.isAcceptableOrUnknown(data['senses']!, _sensesMeta),
      );
    }
    if (data.containsKey('divinity_id')) {
      context.handle(
        _divinityIdMeta,
        divinityId.isAcceptableOrUnknown(data['divinity_id']!, _divinityIdMeta),
      );
    }
    if (data.containsKey('defense')) {
      context.handle(
        _defenseMeta,
        defense.isAcceptableOrUnknown(data['defense']!, _defenseMeta),
      );
    } else if (isInserting) {
      context.missing(_defenseMeta);
    }
    if (data.containsKey('life')) {
      context.handle(
        _lifeMeta,
        life.isAcceptableOrUnknown(data['life']!, _lifeMeta),
      );
    } else if (isInserting) {
      context.missing(_lifeMeta);
    }
    if (data.containsKey('mana')) {
      context.handle(
        _manaMeta,
        mana.isAcceptableOrUnknown(data['mana']!, _manaMeta),
      );
    } else if (isInserting) {
      context.missing(_manaMeta);
    }
    if (data.containsKey('strength')) {
      context.handle(
        _strengthMeta,
        strength.isAcceptableOrUnknown(data['strength']!, _strengthMeta),
      );
    } else if (isInserting) {
      context.missing(_strengthMeta);
    }
    if (data.containsKey('dexterity')) {
      context.handle(
        _dexterityMeta,
        dexterity.isAcceptableOrUnknown(data['dexterity']!, _dexterityMeta),
      );
    } else if (isInserting) {
      context.missing(_dexterityMeta);
    }
    if (data.containsKey('constitution')) {
      context.handle(
        _constitutionMeta,
        constitution.isAcceptableOrUnknown(
          data['constitution']!,
          _constitutionMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_constitutionMeta);
    }
    if (data.containsKey('intelligence')) {
      context.handle(
        _intelligenceMeta,
        intelligence.isAcceptableOrUnknown(
          data['intelligence']!,
          _intelligenceMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_intelligenceMeta);
    }
    if (data.containsKey('wisdom')) {
      context.handle(
        _wisdomMeta,
        wisdom.isAcceptableOrUnknown(data['wisdom']!, _wisdomMeta),
      );
    } else if (isInserting) {
      context.missing(_wisdomMeta);
    }
    if (data.containsKey('charisma')) {
      context.handle(
        _charismaMeta,
        charisma.isAcceptableOrUnknown(data['charisma']!, _charismaMeta),
      );
    } else if (isInserting) {
      context.missing(_charismaMeta);
    }
    if (data.containsKey('creature_size_index')) {
      context.handle(
        _creatureSizeIndexMeta,
        creatureSizeIndex.isAcceptableOrUnknown(
          data['creature_size_index']!,
          _creatureSizeIndexMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_creatureSizeIndexMeta);
    }
    if (data.containsKey('brood_index')) {
      context.handle(
        _broodIndexMeta,
        broodIndex.isAcceptableOrUnknown(data['brood_index']!, _broodIndexMeta),
      );
    } else if (isInserting) {
      context.missing(_broodIndexMeta);
    }
    if (data.containsKey('grimoire_uuid')) {
      context.handle(
        _grimoireUuidMeta,
        grimoireUuid.isAcceptableOrUnknown(
          data['grimoire_uuid']!,
          _grimoireUuidMeta,
        ),
      );
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    } else if (isInserting) {
      context.missing(_createdAtMeta);
    }
    if (data.containsKey('updated_at')) {
      context.handle(
        _updatedAtMeta,
        updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta),
      );
    } else if (isInserting) {
      context.missing(_updatedAtMeta);
    }
    if (data.containsKey('is_alive')) {
      context.handle(
        _isAliveMeta,
        isAlive.isAcceptableOrUnknown(data['is_alive']!, _isAliveMeta),
      );
    } else if (isInserting) {
      context.missing(_isAliveMeta);
    }
    if (data.containsKey('aligment_index')) {
      context.handle(
        _aligmentIndexMeta,
        aligmentIndex.isAcceptableOrUnknown(
          data['aligment_index']!,
          _aligmentIndexMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_aligmentIndexMeta);
    }
    if (data.containsKey('current_life')) {
      context.handle(
        _currentLifeMeta,
        currentLife.isAcceptableOrUnknown(
          data['current_life']!,
          _currentLifeMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_currentLifeMeta);
    }
    if (data.containsKey('current_mana')) {
      context.handle(
        _currentManaMeta,
        currentMana.isAcceptableOrUnknown(
          data['current_mana']!,
          _currentManaMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_currentManaMeta);
    }
    if (data.containsKey('in_left_hand')) {
      context.handle(
        _inLeftHandMeta,
        inLeftHand.isAcceptableOrUnknown(
          data['in_left_hand']!,
          _inLeftHandMeta,
        ),
      );
    }
    if (data.containsKey('in_right_hand')) {
      context.handle(
        _inRightHandMeta,
        inRightHand.isAcceptableOrUnknown(
          data['in_right_hand']!,
          _inRightHandMeta,
        ),
      );
    }
    if (data.containsKey('in_two_hands')) {
      context.handle(
        _inTwoHandsMeta,
        inTwoHands.isAcceptableOrUnknown(
          data['in_two_hands']!,
          _inTwoHandsMeta,
        ),
      );
    }
    if (data.containsKey('in_wearable_slots')) {
      context.handle(
        _inWearableSlotsMeta,
        inWearableSlots.isAcceptableOrUnknown(
          data['in_wearable_slots']!,
          _inWearableSlotsMeta,
        ),
      );
    }
    if (data.containsKey('hand_to_hand_atribute_index')) {
      context.handle(
        _handToHandAtributeIndexMeta,
        handToHandAtributeIndex.isAcceptableOrUnknown(
          data['hand_to_hand_atribute_index']!,
          _handToHandAtributeIndexMeta,
        ),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {uuid};
  @override
  CharacterBoardTableData map(
    Map<String, dynamic> data, {
    String? tablePrefix,
  }) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return CharacterBoardTableData(
      uuid: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}uuid'],
      )!,
      parentuuid: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}parentuuid'],
      )!,
      boarduuid: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}boarduuid'],
      )!,
      name: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}name'],
      )!,
      imagePath: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}image_path'],
      ),
      imageAsset: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}image_asset'],
      ),
      displacement: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}displacement'],
      ),
      senses: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}senses'],
      ),
      divinityId: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}divinity_id'],
      ),
      defense: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}defense'],
      )!,
      life: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}life'],
      )!,
      mana: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}mana'],
      )!,
      strength: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}strength'],
      )!,
      dexterity: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}dexterity'],
      )!,
      constitution: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}constitution'],
      )!,
      intelligence: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}intelligence'],
      )!,
      wisdom: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}wisdom'],
      )!,
      charisma: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}charisma'],
      )!,
      creatureSizeIndex: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}creature_size_index'],
      )!,
      broodIndex: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}brood_index'],
      )!,
      grimoireUuid: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}grimoire_uuid'],
      ),
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}created_at'],
      )!,
      updatedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}updated_at'],
      )!,
      isAlive: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_alive'],
      )!,
      aligmentIndex: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}aligment_index'],
      )!,
      currentLife: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}current_life'],
      )!,
      currentMana: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}current_mana'],
      )!,
      inLeftHand: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}in_left_hand'],
      ),
      inRightHand: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}in_right_hand'],
      ),
      inTwoHands: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}in_two_hands'],
      ),
      inWearableSlots: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}in_wearable_slots'],
      ),
      handToHandAtributeIndex: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}hand_to_hand_atribute_index'],
      ),
    );
  }

  @override
  $CharacterBoardTableTable createAlias(String alias) {
    return $CharacterBoardTableTable(attachedDatabase, alias);
  }
}

class CharacterBoardTableData extends DataClass
    implements Insertable<CharacterBoardTableData> {
  final String uuid;
  final String parentuuid;
  final String boarduuid;
  final String name;
  final String? imagePath;
  final String? imageAsset;
  final String? displacement;
  final String? senses;
  final int? divinityId;
  final int defense;
  final int life;
  final int mana;
  final int strength;
  final int dexterity;
  final int constitution;
  final int intelligence;
  final int wisdom;
  final int charisma;
  final int creatureSizeIndex;
  final int broodIndex;
  final String? grimoireUuid;
  final int createdAt;
  final int updatedAt;
  final bool isAlive;
  final int aligmentIndex;
  final int currentLife;
  final int currentMana;
  final String? inLeftHand;
  final String? inRightHand;
  final String? inTwoHands;
  final String? inWearableSlots;
  final int? handToHandAtributeIndex;
  const CharacterBoardTableData({
    required this.uuid,
    required this.parentuuid,
    required this.boarduuid,
    required this.name,
    this.imagePath,
    this.imageAsset,
    this.displacement,
    this.senses,
    this.divinityId,
    required this.defense,
    required this.life,
    required this.mana,
    required this.strength,
    required this.dexterity,
    required this.constitution,
    required this.intelligence,
    required this.wisdom,
    required this.charisma,
    required this.creatureSizeIndex,
    required this.broodIndex,
    this.grimoireUuid,
    required this.createdAt,
    required this.updatedAt,
    required this.isAlive,
    required this.aligmentIndex,
    required this.currentLife,
    required this.currentMana,
    this.inLeftHand,
    this.inRightHand,
    this.inTwoHands,
    this.inWearableSlots,
    this.handToHandAtributeIndex,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['uuid'] = Variable<String>(uuid);
    map['parentuuid'] = Variable<String>(parentuuid);
    map['boarduuid'] = Variable<String>(boarduuid);
    map['name'] = Variable<String>(name);
    if (!nullToAbsent || imagePath != null) {
      map['image_path'] = Variable<String>(imagePath);
    }
    if (!nullToAbsent || imageAsset != null) {
      map['image_asset'] = Variable<String>(imageAsset);
    }
    if (!nullToAbsent || displacement != null) {
      map['displacement'] = Variable<String>(displacement);
    }
    if (!nullToAbsent || senses != null) {
      map['senses'] = Variable<String>(senses);
    }
    if (!nullToAbsent || divinityId != null) {
      map['divinity_id'] = Variable<int>(divinityId);
    }
    map['defense'] = Variable<int>(defense);
    map['life'] = Variable<int>(life);
    map['mana'] = Variable<int>(mana);
    map['strength'] = Variable<int>(strength);
    map['dexterity'] = Variable<int>(dexterity);
    map['constitution'] = Variable<int>(constitution);
    map['intelligence'] = Variable<int>(intelligence);
    map['wisdom'] = Variable<int>(wisdom);
    map['charisma'] = Variable<int>(charisma);
    map['creature_size_index'] = Variable<int>(creatureSizeIndex);
    map['brood_index'] = Variable<int>(broodIndex);
    if (!nullToAbsent || grimoireUuid != null) {
      map['grimoire_uuid'] = Variable<String>(grimoireUuid);
    }
    map['created_at'] = Variable<int>(createdAt);
    map['updated_at'] = Variable<int>(updatedAt);
    map['is_alive'] = Variable<bool>(isAlive);
    map['aligment_index'] = Variable<int>(aligmentIndex);
    map['current_life'] = Variable<int>(currentLife);
    map['current_mana'] = Variable<int>(currentMana);
    if (!nullToAbsent || inLeftHand != null) {
      map['in_left_hand'] = Variable<String>(inLeftHand);
    }
    if (!nullToAbsent || inRightHand != null) {
      map['in_right_hand'] = Variable<String>(inRightHand);
    }
    if (!nullToAbsent || inTwoHands != null) {
      map['in_two_hands'] = Variable<String>(inTwoHands);
    }
    if (!nullToAbsent || inWearableSlots != null) {
      map['in_wearable_slots'] = Variable<String>(inWearableSlots);
    }
    if (!nullToAbsent || handToHandAtributeIndex != null) {
      map['hand_to_hand_atribute_index'] = Variable<int>(
        handToHandAtributeIndex,
      );
    }
    return map;
  }

  CharacterBoardTableCompanion toCompanion(bool nullToAbsent) {
    return CharacterBoardTableCompanion(
      uuid: Value(uuid),
      parentuuid: Value(parentuuid),
      boarduuid: Value(boarduuid),
      name: Value(name),
      imagePath: imagePath == null && nullToAbsent
          ? const Value.absent()
          : Value(imagePath),
      imageAsset: imageAsset == null && nullToAbsent
          ? const Value.absent()
          : Value(imageAsset),
      displacement: displacement == null && nullToAbsent
          ? const Value.absent()
          : Value(displacement),
      senses: senses == null && nullToAbsent
          ? const Value.absent()
          : Value(senses),
      divinityId: divinityId == null && nullToAbsent
          ? const Value.absent()
          : Value(divinityId),
      defense: Value(defense),
      life: Value(life),
      mana: Value(mana),
      strength: Value(strength),
      dexterity: Value(dexterity),
      constitution: Value(constitution),
      intelligence: Value(intelligence),
      wisdom: Value(wisdom),
      charisma: Value(charisma),
      creatureSizeIndex: Value(creatureSizeIndex),
      broodIndex: Value(broodIndex),
      grimoireUuid: grimoireUuid == null && nullToAbsent
          ? const Value.absent()
          : Value(grimoireUuid),
      createdAt: Value(createdAt),
      updatedAt: Value(updatedAt),
      isAlive: Value(isAlive),
      aligmentIndex: Value(aligmentIndex),
      currentLife: Value(currentLife),
      currentMana: Value(currentMana),
      inLeftHand: inLeftHand == null && nullToAbsent
          ? const Value.absent()
          : Value(inLeftHand),
      inRightHand: inRightHand == null && nullToAbsent
          ? const Value.absent()
          : Value(inRightHand),
      inTwoHands: inTwoHands == null && nullToAbsent
          ? const Value.absent()
          : Value(inTwoHands),
      inWearableSlots: inWearableSlots == null && nullToAbsent
          ? const Value.absent()
          : Value(inWearableSlots),
      handToHandAtributeIndex: handToHandAtributeIndex == null && nullToAbsent
          ? const Value.absent()
          : Value(handToHandAtributeIndex),
    );
  }

  factory CharacterBoardTableData.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return CharacterBoardTableData(
      uuid: serializer.fromJson<String>(json['uuid']),
      parentuuid: serializer.fromJson<String>(json['parentuuid']),
      boarduuid: serializer.fromJson<String>(json['boarduuid']),
      name: serializer.fromJson<String>(json['name']),
      imagePath: serializer.fromJson<String?>(json['imagePath']),
      imageAsset: serializer.fromJson<String?>(json['imageAsset']),
      displacement: serializer.fromJson<String?>(json['displacement']),
      senses: serializer.fromJson<String?>(json['senses']),
      divinityId: serializer.fromJson<int?>(json['divinityId']),
      defense: serializer.fromJson<int>(json['defense']),
      life: serializer.fromJson<int>(json['life']),
      mana: serializer.fromJson<int>(json['mana']),
      strength: serializer.fromJson<int>(json['strength']),
      dexterity: serializer.fromJson<int>(json['dexterity']),
      constitution: serializer.fromJson<int>(json['constitution']),
      intelligence: serializer.fromJson<int>(json['intelligence']),
      wisdom: serializer.fromJson<int>(json['wisdom']),
      charisma: serializer.fromJson<int>(json['charisma']),
      creatureSizeIndex: serializer.fromJson<int>(json['creatureSizeIndex']),
      broodIndex: serializer.fromJson<int>(json['broodIndex']),
      grimoireUuid: serializer.fromJson<String?>(json['grimoireUuid']),
      createdAt: serializer.fromJson<int>(json['createdAt']),
      updatedAt: serializer.fromJson<int>(json['updatedAt']),
      isAlive: serializer.fromJson<bool>(json['isAlive']),
      aligmentIndex: serializer.fromJson<int>(json['aligmentIndex']),
      currentLife: serializer.fromJson<int>(json['currentLife']),
      currentMana: serializer.fromJson<int>(json['currentMana']),
      inLeftHand: serializer.fromJson<String?>(json['inLeftHand']),
      inRightHand: serializer.fromJson<String?>(json['inRightHand']),
      inTwoHands: serializer.fromJson<String?>(json['inTwoHands']),
      inWearableSlots: serializer.fromJson<String?>(json['inWearableSlots']),
      handToHandAtributeIndex: serializer.fromJson<int?>(
        json['handToHandAtributeIndex'],
      ),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'uuid': serializer.toJson<String>(uuid),
      'parentuuid': serializer.toJson<String>(parentuuid),
      'boarduuid': serializer.toJson<String>(boarduuid),
      'name': serializer.toJson<String>(name),
      'imagePath': serializer.toJson<String?>(imagePath),
      'imageAsset': serializer.toJson<String?>(imageAsset),
      'displacement': serializer.toJson<String?>(displacement),
      'senses': serializer.toJson<String?>(senses),
      'divinityId': serializer.toJson<int?>(divinityId),
      'defense': serializer.toJson<int>(defense),
      'life': serializer.toJson<int>(life),
      'mana': serializer.toJson<int>(mana),
      'strength': serializer.toJson<int>(strength),
      'dexterity': serializer.toJson<int>(dexterity),
      'constitution': serializer.toJson<int>(constitution),
      'intelligence': serializer.toJson<int>(intelligence),
      'wisdom': serializer.toJson<int>(wisdom),
      'charisma': serializer.toJson<int>(charisma),
      'creatureSizeIndex': serializer.toJson<int>(creatureSizeIndex),
      'broodIndex': serializer.toJson<int>(broodIndex),
      'grimoireUuid': serializer.toJson<String?>(grimoireUuid),
      'createdAt': serializer.toJson<int>(createdAt),
      'updatedAt': serializer.toJson<int>(updatedAt),
      'isAlive': serializer.toJson<bool>(isAlive),
      'aligmentIndex': serializer.toJson<int>(aligmentIndex),
      'currentLife': serializer.toJson<int>(currentLife),
      'currentMana': serializer.toJson<int>(currentMana),
      'inLeftHand': serializer.toJson<String?>(inLeftHand),
      'inRightHand': serializer.toJson<String?>(inRightHand),
      'inTwoHands': serializer.toJson<String?>(inTwoHands),
      'inWearableSlots': serializer.toJson<String?>(inWearableSlots),
      'handToHandAtributeIndex': serializer.toJson<int?>(
        handToHandAtributeIndex,
      ),
    };
  }

  CharacterBoardTableData copyWith({
    String? uuid,
    String? parentuuid,
    String? boarduuid,
    String? name,
    Value<String?> imagePath = const Value.absent(),
    Value<String?> imageAsset = const Value.absent(),
    Value<String?> displacement = const Value.absent(),
    Value<String?> senses = const Value.absent(),
    Value<int?> divinityId = const Value.absent(),
    int? defense,
    int? life,
    int? mana,
    int? strength,
    int? dexterity,
    int? constitution,
    int? intelligence,
    int? wisdom,
    int? charisma,
    int? creatureSizeIndex,
    int? broodIndex,
    Value<String?> grimoireUuid = const Value.absent(),
    int? createdAt,
    int? updatedAt,
    bool? isAlive,
    int? aligmentIndex,
    int? currentLife,
    int? currentMana,
    Value<String?> inLeftHand = const Value.absent(),
    Value<String?> inRightHand = const Value.absent(),
    Value<String?> inTwoHands = const Value.absent(),
    Value<String?> inWearableSlots = const Value.absent(),
    Value<int?> handToHandAtributeIndex = const Value.absent(),
  }) => CharacterBoardTableData(
    uuid: uuid ?? this.uuid,
    parentuuid: parentuuid ?? this.parentuuid,
    boarduuid: boarduuid ?? this.boarduuid,
    name: name ?? this.name,
    imagePath: imagePath.present ? imagePath.value : this.imagePath,
    imageAsset: imageAsset.present ? imageAsset.value : this.imageAsset,
    displacement: displacement.present ? displacement.value : this.displacement,
    senses: senses.present ? senses.value : this.senses,
    divinityId: divinityId.present ? divinityId.value : this.divinityId,
    defense: defense ?? this.defense,
    life: life ?? this.life,
    mana: mana ?? this.mana,
    strength: strength ?? this.strength,
    dexterity: dexterity ?? this.dexterity,
    constitution: constitution ?? this.constitution,
    intelligence: intelligence ?? this.intelligence,
    wisdom: wisdom ?? this.wisdom,
    charisma: charisma ?? this.charisma,
    creatureSizeIndex: creatureSizeIndex ?? this.creatureSizeIndex,
    broodIndex: broodIndex ?? this.broodIndex,
    grimoireUuid: grimoireUuid.present ? grimoireUuid.value : this.grimoireUuid,
    createdAt: createdAt ?? this.createdAt,
    updatedAt: updatedAt ?? this.updatedAt,
    isAlive: isAlive ?? this.isAlive,
    aligmentIndex: aligmentIndex ?? this.aligmentIndex,
    currentLife: currentLife ?? this.currentLife,
    currentMana: currentMana ?? this.currentMana,
    inLeftHand: inLeftHand.present ? inLeftHand.value : this.inLeftHand,
    inRightHand: inRightHand.present ? inRightHand.value : this.inRightHand,
    inTwoHands: inTwoHands.present ? inTwoHands.value : this.inTwoHands,
    inWearableSlots: inWearableSlots.present
        ? inWearableSlots.value
        : this.inWearableSlots,
    handToHandAtributeIndex: handToHandAtributeIndex.present
        ? handToHandAtributeIndex.value
        : this.handToHandAtributeIndex,
  );
  CharacterBoardTableData copyWithCompanion(CharacterBoardTableCompanion data) {
    return CharacterBoardTableData(
      uuid: data.uuid.present ? data.uuid.value : this.uuid,
      parentuuid: data.parentuuid.present
          ? data.parentuuid.value
          : this.parentuuid,
      boarduuid: data.boarduuid.present ? data.boarduuid.value : this.boarduuid,
      name: data.name.present ? data.name.value : this.name,
      imagePath: data.imagePath.present ? data.imagePath.value : this.imagePath,
      imageAsset: data.imageAsset.present
          ? data.imageAsset.value
          : this.imageAsset,
      displacement: data.displacement.present
          ? data.displacement.value
          : this.displacement,
      senses: data.senses.present ? data.senses.value : this.senses,
      divinityId: data.divinityId.present
          ? data.divinityId.value
          : this.divinityId,
      defense: data.defense.present ? data.defense.value : this.defense,
      life: data.life.present ? data.life.value : this.life,
      mana: data.mana.present ? data.mana.value : this.mana,
      strength: data.strength.present ? data.strength.value : this.strength,
      dexterity: data.dexterity.present ? data.dexterity.value : this.dexterity,
      constitution: data.constitution.present
          ? data.constitution.value
          : this.constitution,
      intelligence: data.intelligence.present
          ? data.intelligence.value
          : this.intelligence,
      wisdom: data.wisdom.present ? data.wisdom.value : this.wisdom,
      charisma: data.charisma.present ? data.charisma.value : this.charisma,
      creatureSizeIndex: data.creatureSizeIndex.present
          ? data.creatureSizeIndex.value
          : this.creatureSizeIndex,
      broodIndex: data.broodIndex.present
          ? data.broodIndex.value
          : this.broodIndex,
      grimoireUuid: data.grimoireUuid.present
          ? data.grimoireUuid.value
          : this.grimoireUuid,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
      isAlive: data.isAlive.present ? data.isAlive.value : this.isAlive,
      aligmentIndex: data.aligmentIndex.present
          ? data.aligmentIndex.value
          : this.aligmentIndex,
      currentLife: data.currentLife.present
          ? data.currentLife.value
          : this.currentLife,
      currentMana: data.currentMana.present
          ? data.currentMana.value
          : this.currentMana,
      inLeftHand: data.inLeftHand.present
          ? data.inLeftHand.value
          : this.inLeftHand,
      inRightHand: data.inRightHand.present
          ? data.inRightHand.value
          : this.inRightHand,
      inTwoHands: data.inTwoHands.present
          ? data.inTwoHands.value
          : this.inTwoHands,
      inWearableSlots: data.inWearableSlots.present
          ? data.inWearableSlots.value
          : this.inWearableSlots,
      handToHandAtributeIndex: data.handToHandAtributeIndex.present
          ? data.handToHandAtributeIndex.value
          : this.handToHandAtributeIndex,
    );
  }

  @override
  String toString() {
    return (StringBuffer('CharacterBoardTableData(')
          ..write('uuid: $uuid, ')
          ..write('parentuuid: $parentuuid, ')
          ..write('boarduuid: $boarduuid, ')
          ..write('name: $name, ')
          ..write('imagePath: $imagePath, ')
          ..write('imageAsset: $imageAsset, ')
          ..write('displacement: $displacement, ')
          ..write('senses: $senses, ')
          ..write('divinityId: $divinityId, ')
          ..write('defense: $defense, ')
          ..write('life: $life, ')
          ..write('mana: $mana, ')
          ..write('strength: $strength, ')
          ..write('dexterity: $dexterity, ')
          ..write('constitution: $constitution, ')
          ..write('intelligence: $intelligence, ')
          ..write('wisdom: $wisdom, ')
          ..write('charisma: $charisma, ')
          ..write('creatureSizeIndex: $creatureSizeIndex, ')
          ..write('broodIndex: $broodIndex, ')
          ..write('grimoireUuid: $grimoireUuid, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('isAlive: $isAlive, ')
          ..write('aligmentIndex: $aligmentIndex, ')
          ..write('currentLife: $currentLife, ')
          ..write('currentMana: $currentMana, ')
          ..write('inLeftHand: $inLeftHand, ')
          ..write('inRightHand: $inRightHand, ')
          ..write('inTwoHands: $inTwoHands, ')
          ..write('inWearableSlots: $inWearableSlots, ')
          ..write('handToHandAtributeIndex: $handToHandAtributeIndex')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hashAll([
    uuid,
    parentuuid,
    boarduuid,
    name,
    imagePath,
    imageAsset,
    displacement,
    senses,
    divinityId,
    defense,
    life,
    mana,
    strength,
    dexterity,
    constitution,
    intelligence,
    wisdom,
    charisma,
    creatureSizeIndex,
    broodIndex,
    grimoireUuid,
    createdAt,
    updatedAt,
    isAlive,
    aligmentIndex,
    currentLife,
    currentMana,
    inLeftHand,
    inRightHand,
    inTwoHands,
    inWearableSlots,
    handToHandAtributeIndex,
  ]);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is CharacterBoardTableData &&
          other.uuid == this.uuid &&
          other.parentuuid == this.parentuuid &&
          other.boarduuid == this.boarduuid &&
          other.name == this.name &&
          other.imagePath == this.imagePath &&
          other.imageAsset == this.imageAsset &&
          other.displacement == this.displacement &&
          other.senses == this.senses &&
          other.divinityId == this.divinityId &&
          other.defense == this.defense &&
          other.life == this.life &&
          other.mana == this.mana &&
          other.strength == this.strength &&
          other.dexterity == this.dexterity &&
          other.constitution == this.constitution &&
          other.intelligence == this.intelligence &&
          other.wisdom == this.wisdom &&
          other.charisma == this.charisma &&
          other.creatureSizeIndex == this.creatureSizeIndex &&
          other.broodIndex == this.broodIndex &&
          other.grimoireUuid == this.grimoireUuid &&
          other.createdAt == this.createdAt &&
          other.updatedAt == this.updatedAt &&
          other.isAlive == this.isAlive &&
          other.aligmentIndex == this.aligmentIndex &&
          other.currentLife == this.currentLife &&
          other.currentMana == this.currentMana &&
          other.inLeftHand == this.inLeftHand &&
          other.inRightHand == this.inRightHand &&
          other.inTwoHands == this.inTwoHands &&
          other.inWearableSlots == this.inWearableSlots &&
          other.handToHandAtributeIndex == this.handToHandAtributeIndex);
}

class CharacterBoardTableCompanion
    extends UpdateCompanion<CharacterBoardTableData> {
  final Value<String> uuid;
  final Value<String> parentuuid;
  final Value<String> boarduuid;
  final Value<String> name;
  final Value<String?> imagePath;
  final Value<String?> imageAsset;
  final Value<String?> displacement;
  final Value<String?> senses;
  final Value<int?> divinityId;
  final Value<int> defense;
  final Value<int> life;
  final Value<int> mana;
  final Value<int> strength;
  final Value<int> dexterity;
  final Value<int> constitution;
  final Value<int> intelligence;
  final Value<int> wisdom;
  final Value<int> charisma;
  final Value<int> creatureSizeIndex;
  final Value<int> broodIndex;
  final Value<String?> grimoireUuid;
  final Value<int> createdAt;
  final Value<int> updatedAt;
  final Value<bool> isAlive;
  final Value<int> aligmentIndex;
  final Value<int> currentLife;
  final Value<int> currentMana;
  final Value<String?> inLeftHand;
  final Value<String?> inRightHand;
  final Value<String?> inTwoHands;
  final Value<String?> inWearableSlots;
  final Value<int?> handToHandAtributeIndex;
  final Value<int> rowid;
  const CharacterBoardTableCompanion({
    this.uuid = const Value.absent(),
    this.parentuuid = const Value.absent(),
    this.boarduuid = const Value.absent(),
    this.name = const Value.absent(),
    this.imagePath = const Value.absent(),
    this.imageAsset = const Value.absent(),
    this.displacement = const Value.absent(),
    this.senses = const Value.absent(),
    this.divinityId = const Value.absent(),
    this.defense = const Value.absent(),
    this.life = const Value.absent(),
    this.mana = const Value.absent(),
    this.strength = const Value.absent(),
    this.dexterity = const Value.absent(),
    this.constitution = const Value.absent(),
    this.intelligence = const Value.absent(),
    this.wisdom = const Value.absent(),
    this.charisma = const Value.absent(),
    this.creatureSizeIndex = const Value.absent(),
    this.broodIndex = const Value.absent(),
    this.grimoireUuid = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.isAlive = const Value.absent(),
    this.aligmentIndex = const Value.absent(),
    this.currentLife = const Value.absent(),
    this.currentMana = const Value.absent(),
    this.inLeftHand = const Value.absent(),
    this.inRightHand = const Value.absent(),
    this.inTwoHands = const Value.absent(),
    this.inWearableSlots = const Value.absent(),
    this.handToHandAtributeIndex = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  CharacterBoardTableCompanion.insert({
    required String uuid,
    required String parentuuid,
    required String boarduuid,
    required String name,
    this.imagePath = const Value.absent(),
    this.imageAsset = const Value.absent(),
    this.displacement = const Value.absent(),
    this.senses = const Value.absent(),
    this.divinityId = const Value.absent(),
    required int defense,
    required int life,
    required int mana,
    required int strength,
    required int dexterity,
    required int constitution,
    required int intelligence,
    required int wisdom,
    required int charisma,
    required int creatureSizeIndex,
    required int broodIndex,
    this.grimoireUuid = const Value.absent(),
    required int createdAt,
    required int updatedAt,
    required bool isAlive,
    required int aligmentIndex,
    required int currentLife,
    required int currentMana,
    this.inLeftHand = const Value.absent(),
    this.inRightHand = const Value.absent(),
    this.inTwoHands = const Value.absent(),
    this.inWearableSlots = const Value.absent(),
    this.handToHandAtributeIndex = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : uuid = Value(uuid),
       parentuuid = Value(parentuuid),
       boarduuid = Value(boarduuid),
       name = Value(name),
       defense = Value(defense),
       life = Value(life),
       mana = Value(mana),
       strength = Value(strength),
       dexterity = Value(dexterity),
       constitution = Value(constitution),
       intelligence = Value(intelligence),
       wisdom = Value(wisdom),
       charisma = Value(charisma),
       creatureSizeIndex = Value(creatureSizeIndex),
       broodIndex = Value(broodIndex),
       createdAt = Value(createdAt),
       updatedAt = Value(updatedAt),
       isAlive = Value(isAlive),
       aligmentIndex = Value(aligmentIndex),
       currentLife = Value(currentLife),
       currentMana = Value(currentMana);
  static Insertable<CharacterBoardTableData> custom({
    Expression<String>? uuid,
    Expression<String>? parentuuid,
    Expression<String>? boarduuid,
    Expression<String>? name,
    Expression<String>? imagePath,
    Expression<String>? imageAsset,
    Expression<String>? displacement,
    Expression<String>? senses,
    Expression<int>? divinityId,
    Expression<int>? defense,
    Expression<int>? life,
    Expression<int>? mana,
    Expression<int>? strength,
    Expression<int>? dexterity,
    Expression<int>? constitution,
    Expression<int>? intelligence,
    Expression<int>? wisdom,
    Expression<int>? charisma,
    Expression<int>? creatureSizeIndex,
    Expression<int>? broodIndex,
    Expression<String>? grimoireUuid,
    Expression<int>? createdAt,
    Expression<int>? updatedAt,
    Expression<bool>? isAlive,
    Expression<int>? aligmentIndex,
    Expression<int>? currentLife,
    Expression<int>? currentMana,
    Expression<String>? inLeftHand,
    Expression<String>? inRightHand,
    Expression<String>? inTwoHands,
    Expression<String>? inWearableSlots,
    Expression<int>? handToHandAtributeIndex,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (uuid != null) 'uuid': uuid,
      if (parentuuid != null) 'parentuuid': parentuuid,
      if (boarduuid != null) 'boarduuid': boarduuid,
      if (name != null) 'name': name,
      if (imagePath != null) 'image_path': imagePath,
      if (imageAsset != null) 'image_asset': imageAsset,
      if (displacement != null) 'displacement': displacement,
      if (senses != null) 'senses': senses,
      if (divinityId != null) 'divinity_id': divinityId,
      if (defense != null) 'defense': defense,
      if (life != null) 'life': life,
      if (mana != null) 'mana': mana,
      if (strength != null) 'strength': strength,
      if (dexterity != null) 'dexterity': dexterity,
      if (constitution != null) 'constitution': constitution,
      if (intelligence != null) 'intelligence': intelligence,
      if (wisdom != null) 'wisdom': wisdom,
      if (charisma != null) 'charisma': charisma,
      if (creatureSizeIndex != null) 'creature_size_index': creatureSizeIndex,
      if (broodIndex != null) 'brood_index': broodIndex,
      if (grimoireUuid != null) 'grimoire_uuid': grimoireUuid,
      if (createdAt != null) 'created_at': createdAt,
      if (updatedAt != null) 'updated_at': updatedAt,
      if (isAlive != null) 'is_alive': isAlive,
      if (aligmentIndex != null) 'aligment_index': aligmentIndex,
      if (currentLife != null) 'current_life': currentLife,
      if (currentMana != null) 'current_mana': currentMana,
      if (inLeftHand != null) 'in_left_hand': inLeftHand,
      if (inRightHand != null) 'in_right_hand': inRightHand,
      if (inTwoHands != null) 'in_two_hands': inTwoHands,
      if (inWearableSlots != null) 'in_wearable_slots': inWearableSlots,
      if (handToHandAtributeIndex != null)
        'hand_to_hand_atribute_index': handToHandAtributeIndex,
      if (rowid != null) 'rowid': rowid,
    });
  }

  CharacterBoardTableCompanion copyWith({
    Value<String>? uuid,
    Value<String>? parentuuid,
    Value<String>? boarduuid,
    Value<String>? name,
    Value<String?>? imagePath,
    Value<String?>? imageAsset,
    Value<String?>? displacement,
    Value<String?>? senses,
    Value<int?>? divinityId,
    Value<int>? defense,
    Value<int>? life,
    Value<int>? mana,
    Value<int>? strength,
    Value<int>? dexterity,
    Value<int>? constitution,
    Value<int>? intelligence,
    Value<int>? wisdom,
    Value<int>? charisma,
    Value<int>? creatureSizeIndex,
    Value<int>? broodIndex,
    Value<String?>? grimoireUuid,
    Value<int>? createdAt,
    Value<int>? updatedAt,
    Value<bool>? isAlive,
    Value<int>? aligmentIndex,
    Value<int>? currentLife,
    Value<int>? currentMana,
    Value<String?>? inLeftHand,
    Value<String?>? inRightHand,
    Value<String?>? inTwoHands,
    Value<String?>? inWearableSlots,
    Value<int?>? handToHandAtributeIndex,
    Value<int>? rowid,
  }) {
    return CharacterBoardTableCompanion(
      uuid: uuid ?? this.uuid,
      parentuuid: parentuuid ?? this.parentuuid,
      boarduuid: boarduuid ?? this.boarduuid,
      name: name ?? this.name,
      imagePath: imagePath ?? this.imagePath,
      imageAsset: imageAsset ?? this.imageAsset,
      displacement: displacement ?? this.displacement,
      senses: senses ?? this.senses,
      divinityId: divinityId ?? this.divinityId,
      defense: defense ?? this.defense,
      life: life ?? this.life,
      mana: mana ?? this.mana,
      strength: strength ?? this.strength,
      dexterity: dexterity ?? this.dexterity,
      constitution: constitution ?? this.constitution,
      intelligence: intelligence ?? this.intelligence,
      wisdom: wisdom ?? this.wisdom,
      charisma: charisma ?? this.charisma,
      creatureSizeIndex: creatureSizeIndex ?? this.creatureSizeIndex,
      broodIndex: broodIndex ?? this.broodIndex,
      grimoireUuid: grimoireUuid ?? this.grimoireUuid,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
      isAlive: isAlive ?? this.isAlive,
      aligmentIndex: aligmentIndex ?? this.aligmentIndex,
      currentLife: currentLife ?? this.currentLife,
      currentMana: currentMana ?? this.currentMana,
      inLeftHand: inLeftHand ?? this.inLeftHand,
      inRightHand: inRightHand ?? this.inRightHand,
      inTwoHands: inTwoHands ?? this.inTwoHands,
      inWearableSlots: inWearableSlots ?? this.inWearableSlots,
      handToHandAtributeIndex:
          handToHandAtributeIndex ?? this.handToHandAtributeIndex,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (uuid.present) {
      map['uuid'] = Variable<String>(uuid.value);
    }
    if (parentuuid.present) {
      map['parentuuid'] = Variable<String>(parentuuid.value);
    }
    if (boarduuid.present) {
      map['boarduuid'] = Variable<String>(boarduuid.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    if (imagePath.present) {
      map['image_path'] = Variable<String>(imagePath.value);
    }
    if (imageAsset.present) {
      map['image_asset'] = Variable<String>(imageAsset.value);
    }
    if (displacement.present) {
      map['displacement'] = Variable<String>(displacement.value);
    }
    if (senses.present) {
      map['senses'] = Variable<String>(senses.value);
    }
    if (divinityId.present) {
      map['divinity_id'] = Variable<int>(divinityId.value);
    }
    if (defense.present) {
      map['defense'] = Variable<int>(defense.value);
    }
    if (life.present) {
      map['life'] = Variable<int>(life.value);
    }
    if (mana.present) {
      map['mana'] = Variable<int>(mana.value);
    }
    if (strength.present) {
      map['strength'] = Variable<int>(strength.value);
    }
    if (dexterity.present) {
      map['dexterity'] = Variable<int>(dexterity.value);
    }
    if (constitution.present) {
      map['constitution'] = Variable<int>(constitution.value);
    }
    if (intelligence.present) {
      map['intelligence'] = Variable<int>(intelligence.value);
    }
    if (wisdom.present) {
      map['wisdom'] = Variable<int>(wisdom.value);
    }
    if (charisma.present) {
      map['charisma'] = Variable<int>(charisma.value);
    }
    if (creatureSizeIndex.present) {
      map['creature_size_index'] = Variable<int>(creatureSizeIndex.value);
    }
    if (broodIndex.present) {
      map['brood_index'] = Variable<int>(broodIndex.value);
    }
    if (grimoireUuid.present) {
      map['grimoire_uuid'] = Variable<String>(grimoireUuid.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<int>(createdAt.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<int>(updatedAt.value);
    }
    if (isAlive.present) {
      map['is_alive'] = Variable<bool>(isAlive.value);
    }
    if (aligmentIndex.present) {
      map['aligment_index'] = Variable<int>(aligmentIndex.value);
    }
    if (currentLife.present) {
      map['current_life'] = Variable<int>(currentLife.value);
    }
    if (currentMana.present) {
      map['current_mana'] = Variable<int>(currentMana.value);
    }
    if (inLeftHand.present) {
      map['in_left_hand'] = Variable<String>(inLeftHand.value);
    }
    if (inRightHand.present) {
      map['in_right_hand'] = Variable<String>(inRightHand.value);
    }
    if (inTwoHands.present) {
      map['in_two_hands'] = Variable<String>(inTwoHands.value);
    }
    if (inWearableSlots.present) {
      map['in_wearable_slots'] = Variable<String>(inWearableSlots.value);
    }
    if (handToHandAtributeIndex.present) {
      map['hand_to_hand_atribute_index'] = Variable<int>(
        handToHandAtributeIndex.value,
      );
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('CharacterBoardTableCompanion(')
          ..write('uuid: $uuid, ')
          ..write('parentuuid: $parentuuid, ')
          ..write('boarduuid: $boarduuid, ')
          ..write('name: $name, ')
          ..write('imagePath: $imagePath, ')
          ..write('imageAsset: $imageAsset, ')
          ..write('displacement: $displacement, ')
          ..write('senses: $senses, ')
          ..write('divinityId: $divinityId, ')
          ..write('defense: $defense, ')
          ..write('life: $life, ')
          ..write('mana: $mana, ')
          ..write('strength: $strength, ')
          ..write('dexterity: $dexterity, ')
          ..write('constitution: $constitution, ')
          ..write('intelligence: $intelligence, ')
          ..write('wisdom: $wisdom, ')
          ..write('charisma: $charisma, ')
          ..write('creatureSizeIndex: $creatureSizeIndex, ')
          ..write('broodIndex: $broodIndex, ')
          ..write('grimoireUuid: $grimoireUuid, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('isAlive: $isAlive, ')
          ..write('aligmentIndex: $aligmentIndex, ')
          ..write('currentLife: $currentLife, ')
          ..write('currentMana: $currentMana, ')
          ..write('inLeftHand: $inLeftHand, ')
          ..write('inRightHand: $inRightHand, ')
          ..write('inTwoHands: $inTwoHands, ')
          ..write('inWearableSlots: $inWearableSlots, ')
          ..write('handToHandAtributeIndex: $handToHandAtributeIndex, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $CharacterConditionTableTable extends CharacterConditionTable
    with TableInfo<$CharacterConditionTableTable, CharacterConditionTableData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $CharacterConditionTableTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _uuidMeta = const VerificationMeta('uuid');
  @override
  late final GeneratedColumn<String> uuid = GeneratedColumn<String>(
    'uuid',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _parentUuidMeta = const VerificationMeta(
    'parentUuid',
  );
  @override
  late final GeneratedColumn<String> parentUuid = GeneratedColumn<String>(
    'parent_uuid',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _conditionIdMeta = const VerificationMeta(
    'conditionId',
  );
  @override
  late final GeneratedColumn<int> conditionId = GeneratedColumn<int>(
    'condition_id',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
    'name',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _descMeta = const VerificationMeta('desc');
  @override
  late final GeneratedColumn<String> desc = GeneratedColumn<String>(
    'desc',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _atributesIndexesMeta = const VerificationMeta(
    'atributesIndexes',
  );
  @override
  late final GeneratedColumn<String> atributesIndexes = GeneratedColumn<String>(
    'atributes_indexes',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _expertisesIndexesMeta = const VerificationMeta(
    'expertisesIndexes',
  );
  @override
  late final GeneratedColumn<String> expertisesIndexes =
      GeneratedColumn<String>(
        'expertises_indexes',
        aliasedName,
        true,
        type: DriftSqlType.string,
        requiredDuringInsert: false,
      );
  static const VerificationMeta _diceMeta = const VerificationMeta('dice');
  @override
  late final GeneratedColumn<String> dice = GeneratedColumn<String>(
    'dice',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<int> createdAt = GeneratedColumn<int>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _updatedAtMeta = const VerificationMeta(
    'updatedAt',
  );
  @override
  late final GeneratedColumn<int> updatedAt = GeneratedColumn<int>(
    'updated_at',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _inAllExpertisesMeta = const VerificationMeta(
    'inAllExpertises',
  );
  @override
  late final GeneratedColumn<bool> inAllExpertises = GeneratedColumn<bool>(
    'in_all_expertises',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("in_all_expertises" IN (0, 1))',
    ),
  );
  static const VerificationMeta _inManaMeta = const VerificationMeta('inMana');
  @override
  late final GeneratedColumn<bool> inMana = GeneratedColumn<bool>(
    'in_mana',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("in_mana" IN (0, 1))',
    ),
  );
  static const VerificationMeta _inAttackMeta = const VerificationMeta(
    'inAttack',
  );
  @override
  late final GeneratedColumn<bool> inAttack = GeneratedColumn<bool>(
    'in_attack',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("in_attack" IN (0, 1))',
    ),
  );
  static const VerificationMeta _inDefenseMeta = const VerificationMeta(
    'inDefense',
  );
  @override
  late final GeneratedColumn<bool> inDefense = GeneratedColumn<bool>(
    'in_defense',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("in_defense" IN (0, 1))',
    ),
  );
  static const VerificationMeta _inDisplacmentMeta = const VerificationMeta(
    'inDisplacment',
  );
  @override
  late final GeneratedColumn<bool> inDisplacment = GeneratedColumn<bool>(
    'in_displacment',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("in_displacment" IN (0, 1))',
    ),
  );
  @override
  List<GeneratedColumn> get $columns => [
    uuid,
    parentUuid,
    conditionId,
    name,
    desc,
    atributesIndexes,
    expertisesIndexes,
    dice,
    createdAt,
    updatedAt,
    inAllExpertises,
    inMana,
    inAttack,
    inDefense,
    inDisplacment,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'character_condition_table';
  @override
  VerificationContext validateIntegrity(
    Insertable<CharacterConditionTableData> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('uuid')) {
      context.handle(
        _uuidMeta,
        uuid.isAcceptableOrUnknown(data['uuid']!, _uuidMeta),
      );
    } else if (isInserting) {
      context.missing(_uuidMeta);
    }
    if (data.containsKey('parent_uuid')) {
      context.handle(
        _parentUuidMeta,
        parentUuid.isAcceptableOrUnknown(data['parent_uuid']!, _parentUuidMeta),
      );
    } else if (isInserting) {
      context.missing(_parentUuidMeta);
    }
    if (data.containsKey('condition_id')) {
      context.handle(
        _conditionIdMeta,
        conditionId.isAcceptableOrUnknown(
          data['condition_id']!,
          _conditionIdMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_conditionIdMeta);
    }
    if (data.containsKey('name')) {
      context.handle(
        _nameMeta,
        name.isAcceptableOrUnknown(data['name']!, _nameMeta),
      );
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    if (data.containsKey('desc')) {
      context.handle(
        _descMeta,
        desc.isAcceptableOrUnknown(data['desc']!, _descMeta),
      );
    } else if (isInserting) {
      context.missing(_descMeta);
    }
    if (data.containsKey('atributes_indexes')) {
      context.handle(
        _atributesIndexesMeta,
        atributesIndexes.isAcceptableOrUnknown(
          data['atributes_indexes']!,
          _atributesIndexesMeta,
        ),
      );
    }
    if (data.containsKey('expertises_indexes')) {
      context.handle(
        _expertisesIndexesMeta,
        expertisesIndexes.isAcceptableOrUnknown(
          data['expertises_indexes']!,
          _expertisesIndexesMeta,
        ),
      );
    }
    if (data.containsKey('dice')) {
      context.handle(
        _diceMeta,
        dice.isAcceptableOrUnknown(data['dice']!, _diceMeta),
      );
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    } else if (isInserting) {
      context.missing(_createdAtMeta);
    }
    if (data.containsKey('updated_at')) {
      context.handle(
        _updatedAtMeta,
        updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta),
      );
    } else if (isInserting) {
      context.missing(_updatedAtMeta);
    }
    if (data.containsKey('in_all_expertises')) {
      context.handle(
        _inAllExpertisesMeta,
        inAllExpertises.isAcceptableOrUnknown(
          data['in_all_expertises']!,
          _inAllExpertisesMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_inAllExpertisesMeta);
    }
    if (data.containsKey('in_mana')) {
      context.handle(
        _inManaMeta,
        inMana.isAcceptableOrUnknown(data['in_mana']!, _inManaMeta),
      );
    } else if (isInserting) {
      context.missing(_inManaMeta);
    }
    if (data.containsKey('in_attack')) {
      context.handle(
        _inAttackMeta,
        inAttack.isAcceptableOrUnknown(data['in_attack']!, _inAttackMeta),
      );
    } else if (isInserting) {
      context.missing(_inAttackMeta);
    }
    if (data.containsKey('in_defense')) {
      context.handle(
        _inDefenseMeta,
        inDefense.isAcceptableOrUnknown(data['in_defense']!, _inDefenseMeta),
      );
    } else if (isInserting) {
      context.missing(_inDefenseMeta);
    }
    if (data.containsKey('in_displacment')) {
      context.handle(
        _inDisplacmentMeta,
        inDisplacment.isAcceptableOrUnknown(
          data['in_displacment']!,
          _inDisplacmentMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_inDisplacmentMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {uuid};
  @override
  CharacterConditionTableData map(
    Map<String, dynamic> data, {
    String? tablePrefix,
  }) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return CharacterConditionTableData(
      uuid: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}uuid'],
      )!,
      parentUuid: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}parent_uuid'],
      )!,
      conditionId: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}condition_id'],
      )!,
      name: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}name'],
      )!,
      desc: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}desc'],
      )!,
      atributesIndexes: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}atributes_indexes'],
      ),
      expertisesIndexes: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}expertises_indexes'],
      ),
      dice: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}dice'],
      ),
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}created_at'],
      )!,
      updatedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}updated_at'],
      )!,
      inAllExpertises: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}in_all_expertises'],
      )!,
      inMana: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}in_mana'],
      )!,
      inAttack: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}in_attack'],
      )!,
      inDefense: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}in_defense'],
      )!,
      inDisplacment: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}in_displacment'],
      )!,
    );
  }

  @override
  $CharacterConditionTableTable createAlias(String alias) {
    return $CharacterConditionTableTable(attachedDatabase, alias);
  }
}

class CharacterConditionTableData extends DataClass
    implements Insertable<CharacterConditionTableData> {
  final String uuid;
  final String parentUuid;
  final int conditionId;
  final String name;
  final String desc;
  final String? atributesIndexes;
  final String? expertisesIndexes;
  final String? dice;
  final int createdAt;
  final int updatedAt;
  final bool inAllExpertises;
  final bool inMana;
  final bool inAttack;
  final bool inDefense;
  final bool inDisplacment;
  const CharacterConditionTableData({
    required this.uuid,
    required this.parentUuid,
    required this.conditionId,
    required this.name,
    required this.desc,
    this.atributesIndexes,
    this.expertisesIndexes,
    this.dice,
    required this.createdAt,
    required this.updatedAt,
    required this.inAllExpertises,
    required this.inMana,
    required this.inAttack,
    required this.inDefense,
    required this.inDisplacment,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['uuid'] = Variable<String>(uuid);
    map['parent_uuid'] = Variable<String>(parentUuid);
    map['condition_id'] = Variable<int>(conditionId);
    map['name'] = Variable<String>(name);
    map['desc'] = Variable<String>(desc);
    if (!nullToAbsent || atributesIndexes != null) {
      map['atributes_indexes'] = Variable<String>(atributesIndexes);
    }
    if (!nullToAbsent || expertisesIndexes != null) {
      map['expertises_indexes'] = Variable<String>(expertisesIndexes);
    }
    if (!nullToAbsent || dice != null) {
      map['dice'] = Variable<String>(dice);
    }
    map['created_at'] = Variable<int>(createdAt);
    map['updated_at'] = Variable<int>(updatedAt);
    map['in_all_expertises'] = Variable<bool>(inAllExpertises);
    map['in_mana'] = Variable<bool>(inMana);
    map['in_attack'] = Variable<bool>(inAttack);
    map['in_defense'] = Variable<bool>(inDefense);
    map['in_displacment'] = Variable<bool>(inDisplacment);
    return map;
  }

  CharacterConditionTableCompanion toCompanion(bool nullToAbsent) {
    return CharacterConditionTableCompanion(
      uuid: Value(uuid),
      parentUuid: Value(parentUuid),
      conditionId: Value(conditionId),
      name: Value(name),
      desc: Value(desc),
      atributesIndexes: atributesIndexes == null && nullToAbsent
          ? const Value.absent()
          : Value(atributesIndexes),
      expertisesIndexes: expertisesIndexes == null && nullToAbsent
          ? const Value.absent()
          : Value(expertisesIndexes),
      dice: dice == null && nullToAbsent ? const Value.absent() : Value(dice),
      createdAt: Value(createdAt),
      updatedAt: Value(updatedAt),
      inAllExpertises: Value(inAllExpertises),
      inMana: Value(inMana),
      inAttack: Value(inAttack),
      inDefense: Value(inDefense),
      inDisplacment: Value(inDisplacment),
    );
  }

  factory CharacterConditionTableData.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return CharacterConditionTableData(
      uuid: serializer.fromJson<String>(json['uuid']),
      parentUuid: serializer.fromJson<String>(json['parentUuid']),
      conditionId: serializer.fromJson<int>(json['conditionId']),
      name: serializer.fromJson<String>(json['name']),
      desc: serializer.fromJson<String>(json['desc']),
      atributesIndexes: serializer.fromJson<String?>(json['atributesIndexes']),
      expertisesIndexes: serializer.fromJson<String?>(
        json['expertisesIndexes'],
      ),
      dice: serializer.fromJson<String?>(json['dice']),
      createdAt: serializer.fromJson<int>(json['createdAt']),
      updatedAt: serializer.fromJson<int>(json['updatedAt']),
      inAllExpertises: serializer.fromJson<bool>(json['inAllExpertises']),
      inMana: serializer.fromJson<bool>(json['inMana']),
      inAttack: serializer.fromJson<bool>(json['inAttack']),
      inDefense: serializer.fromJson<bool>(json['inDefense']),
      inDisplacment: serializer.fromJson<bool>(json['inDisplacment']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'uuid': serializer.toJson<String>(uuid),
      'parentUuid': serializer.toJson<String>(parentUuid),
      'conditionId': serializer.toJson<int>(conditionId),
      'name': serializer.toJson<String>(name),
      'desc': serializer.toJson<String>(desc),
      'atributesIndexes': serializer.toJson<String?>(atributesIndexes),
      'expertisesIndexes': serializer.toJson<String?>(expertisesIndexes),
      'dice': serializer.toJson<String?>(dice),
      'createdAt': serializer.toJson<int>(createdAt),
      'updatedAt': serializer.toJson<int>(updatedAt),
      'inAllExpertises': serializer.toJson<bool>(inAllExpertises),
      'inMana': serializer.toJson<bool>(inMana),
      'inAttack': serializer.toJson<bool>(inAttack),
      'inDefense': serializer.toJson<bool>(inDefense),
      'inDisplacment': serializer.toJson<bool>(inDisplacment),
    };
  }

  CharacterConditionTableData copyWith({
    String? uuid,
    String? parentUuid,
    int? conditionId,
    String? name,
    String? desc,
    Value<String?> atributesIndexes = const Value.absent(),
    Value<String?> expertisesIndexes = const Value.absent(),
    Value<String?> dice = const Value.absent(),
    int? createdAt,
    int? updatedAt,
    bool? inAllExpertises,
    bool? inMana,
    bool? inAttack,
    bool? inDefense,
    bool? inDisplacment,
  }) => CharacterConditionTableData(
    uuid: uuid ?? this.uuid,
    parentUuid: parentUuid ?? this.parentUuid,
    conditionId: conditionId ?? this.conditionId,
    name: name ?? this.name,
    desc: desc ?? this.desc,
    atributesIndexes: atributesIndexes.present
        ? atributesIndexes.value
        : this.atributesIndexes,
    expertisesIndexes: expertisesIndexes.present
        ? expertisesIndexes.value
        : this.expertisesIndexes,
    dice: dice.present ? dice.value : this.dice,
    createdAt: createdAt ?? this.createdAt,
    updatedAt: updatedAt ?? this.updatedAt,
    inAllExpertises: inAllExpertises ?? this.inAllExpertises,
    inMana: inMana ?? this.inMana,
    inAttack: inAttack ?? this.inAttack,
    inDefense: inDefense ?? this.inDefense,
    inDisplacment: inDisplacment ?? this.inDisplacment,
  );
  CharacterConditionTableData copyWithCompanion(
    CharacterConditionTableCompanion data,
  ) {
    return CharacterConditionTableData(
      uuid: data.uuid.present ? data.uuid.value : this.uuid,
      parentUuid: data.parentUuid.present
          ? data.parentUuid.value
          : this.parentUuid,
      conditionId: data.conditionId.present
          ? data.conditionId.value
          : this.conditionId,
      name: data.name.present ? data.name.value : this.name,
      desc: data.desc.present ? data.desc.value : this.desc,
      atributesIndexes: data.atributesIndexes.present
          ? data.atributesIndexes.value
          : this.atributesIndexes,
      expertisesIndexes: data.expertisesIndexes.present
          ? data.expertisesIndexes.value
          : this.expertisesIndexes,
      dice: data.dice.present ? data.dice.value : this.dice,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
      inAllExpertises: data.inAllExpertises.present
          ? data.inAllExpertises.value
          : this.inAllExpertises,
      inMana: data.inMana.present ? data.inMana.value : this.inMana,
      inAttack: data.inAttack.present ? data.inAttack.value : this.inAttack,
      inDefense: data.inDefense.present ? data.inDefense.value : this.inDefense,
      inDisplacment: data.inDisplacment.present
          ? data.inDisplacment.value
          : this.inDisplacment,
    );
  }

  @override
  String toString() {
    return (StringBuffer('CharacterConditionTableData(')
          ..write('uuid: $uuid, ')
          ..write('parentUuid: $parentUuid, ')
          ..write('conditionId: $conditionId, ')
          ..write('name: $name, ')
          ..write('desc: $desc, ')
          ..write('atributesIndexes: $atributesIndexes, ')
          ..write('expertisesIndexes: $expertisesIndexes, ')
          ..write('dice: $dice, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('inAllExpertises: $inAllExpertises, ')
          ..write('inMana: $inMana, ')
          ..write('inAttack: $inAttack, ')
          ..write('inDefense: $inDefense, ')
          ..write('inDisplacment: $inDisplacment')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    uuid,
    parentUuid,
    conditionId,
    name,
    desc,
    atributesIndexes,
    expertisesIndexes,
    dice,
    createdAt,
    updatedAt,
    inAllExpertises,
    inMana,
    inAttack,
    inDefense,
    inDisplacment,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is CharacterConditionTableData &&
          other.uuid == this.uuid &&
          other.parentUuid == this.parentUuid &&
          other.conditionId == this.conditionId &&
          other.name == this.name &&
          other.desc == this.desc &&
          other.atributesIndexes == this.atributesIndexes &&
          other.expertisesIndexes == this.expertisesIndexes &&
          other.dice == this.dice &&
          other.createdAt == this.createdAt &&
          other.updatedAt == this.updatedAt &&
          other.inAllExpertises == this.inAllExpertises &&
          other.inMana == this.inMana &&
          other.inAttack == this.inAttack &&
          other.inDefense == this.inDefense &&
          other.inDisplacment == this.inDisplacment);
}

class CharacterConditionTableCompanion
    extends UpdateCompanion<CharacterConditionTableData> {
  final Value<String> uuid;
  final Value<String> parentUuid;
  final Value<int> conditionId;
  final Value<String> name;
  final Value<String> desc;
  final Value<String?> atributesIndexes;
  final Value<String?> expertisesIndexes;
  final Value<String?> dice;
  final Value<int> createdAt;
  final Value<int> updatedAt;
  final Value<bool> inAllExpertises;
  final Value<bool> inMana;
  final Value<bool> inAttack;
  final Value<bool> inDefense;
  final Value<bool> inDisplacment;
  final Value<int> rowid;
  const CharacterConditionTableCompanion({
    this.uuid = const Value.absent(),
    this.parentUuid = const Value.absent(),
    this.conditionId = const Value.absent(),
    this.name = const Value.absent(),
    this.desc = const Value.absent(),
    this.atributesIndexes = const Value.absent(),
    this.expertisesIndexes = const Value.absent(),
    this.dice = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.inAllExpertises = const Value.absent(),
    this.inMana = const Value.absent(),
    this.inAttack = const Value.absent(),
    this.inDefense = const Value.absent(),
    this.inDisplacment = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  CharacterConditionTableCompanion.insert({
    required String uuid,
    required String parentUuid,
    required int conditionId,
    required String name,
    required String desc,
    this.atributesIndexes = const Value.absent(),
    this.expertisesIndexes = const Value.absent(),
    this.dice = const Value.absent(),
    required int createdAt,
    required int updatedAt,
    required bool inAllExpertises,
    required bool inMana,
    required bool inAttack,
    required bool inDefense,
    required bool inDisplacment,
    this.rowid = const Value.absent(),
  }) : uuid = Value(uuid),
       parentUuid = Value(parentUuid),
       conditionId = Value(conditionId),
       name = Value(name),
       desc = Value(desc),
       createdAt = Value(createdAt),
       updatedAt = Value(updatedAt),
       inAllExpertises = Value(inAllExpertises),
       inMana = Value(inMana),
       inAttack = Value(inAttack),
       inDefense = Value(inDefense),
       inDisplacment = Value(inDisplacment);
  static Insertable<CharacterConditionTableData> custom({
    Expression<String>? uuid,
    Expression<String>? parentUuid,
    Expression<int>? conditionId,
    Expression<String>? name,
    Expression<String>? desc,
    Expression<String>? atributesIndexes,
    Expression<String>? expertisesIndexes,
    Expression<String>? dice,
    Expression<int>? createdAt,
    Expression<int>? updatedAt,
    Expression<bool>? inAllExpertises,
    Expression<bool>? inMana,
    Expression<bool>? inAttack,
    Expression<bool>? inDefense,
    Expression<bool>? inDisplacment,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (uuid != null) 'uuid': uuid,
      if (parentUuid != null) 'parent_uuid': parentUuid,
      if (conditionId != null) 'condition_id': conditionId,
      if (name != null) 'name': name,
      if (desc != null) 'desc': desc,
      if (atributesIndexes != null) 'atributes_indexes': atributesIndexes,
      if (expertisesIndexes != null) 'expertises_indexes': expertisesIndexes,
      if (dice != null) 'dice': dice,
      if (createdAt != null) 'created_at': createdAt,
      if (updatedAt != null) 'updated_at': updatedAt,
      if (inAllExpertises != null) 'in_all_expertises': inAllExpertises,
      if (inMana != null) 'in_mana': inMana,
      if (inAttack != null) 'in_attack': inAttack,
      if (inDefense != null) 'in_defense': inDefense,
      if (inDisplacment != null) 'in_displacment': inDisplacment,
      if (rowid != null) 'rowid': rowid,
    });
  }

  CharacterConditionTableCompanion copyWith({
    Value<String>? uuid,
    Value<String>? parentUuid,
    Value<int>? conditionId,
    Value<String>? name,
    Value<String>? desc,
    Value<String?>? atributesIndexes,
    Value<String?>? expertisesIndexes,
    Value<String?>? dice,
    Value<int>? createdAt,
    Value<int>? updatedAt,
    Value<bool>? inAllExpertises,
    Value<bool>? inMana,
    Value<bool>? inAttack,
    Value<bool>? inDefense,
    Value<bool>? inDisplacment,
    Value<int>? rowid,
  }) {
    return CharacterConditionTableCompanion(
      uuid: uuid ?? this.uuid,
      parentUuid: parentUuid ?? this.parentUuid,
      conditionId: conditionId ?? this.conditionId,
      name: name ?? this.name,
      desc: desc ?? this.desc,
      atributesIndexes: atributesIndexes ?? this.atributesIndexes,
      expertisesIndexes: expertisesIndexes ?? this.expertisesIndexes,
      dice: dice ?? this.dice,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
      inAllExpertises: inAllExpertises ?? this.inAllExpertises,
      inMana: inMana ?? this.inMana,
      inAttack: inAttack ?? this.inAttack,
      inDefense: inDefense ?? this.inDefense,
      inDisplacment: inDisplacment ?? this.inDisplacment,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (uuid.present) {
      map['uuid'] = Variable<String>(uuid.value);
    }
    if (parentUuid.present) {
      map['parent_uuid'] = Variable<String>(parentUuid.value);
    }
    if (conditionId.present) {
      map['condition_id'] = Variable<int>(conditionId.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    if (desc.present) {
      map['desc'] = Variable<String>(desc.value);
    }
    if (atributesIndexes.present) {
      map['atributes_indexes'] = Variable<String>(atributesIndexes.value);
    }
    if (expertisesIndexes.present) {
      map['expertises_indexes'] = Variable<String>(expertisesIndexes.value);
    }
    if (dice.present) {
      map['dice'] = Variable<String>(dice.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<int>(createdAt.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<int>(updatedAt.value);
    }
    if (inAllExpertises.present) {
      map['in_all_expertises'] = Variable<bool>(inAllExpertises.value);
    }
    if (inMana.present) {
      map['in_mana'] = Variable<bool>(inMana.value);
    }
    if (inAttack.present) {
      map['in_attack'] = Variable<bool>(inAttack.value);
    }
    if (inDefense.present) {
      map['in_defense'] = Variable<bool>(inDefense.value);
    }
    if (inDisplacment.present) {
      map['in_displacment'] = Variable<bool>(inDisplacment.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('CharacterConditionTableCompanion(')
          ..write('uuid: $uuid, ')
          ..write('parentUuid: $parentUuid, ')
          ..write('conditionId: $conditionId, ')
          ..write('name: $name, ')
          ..write('desc: $desc, ')
          ..write('atributesIndexes: $atributesIndexes, ')
          ..write('expertisesIndexes: $expertisesIndexes, ')
          ..write('dice: $dice, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('inAllExpertises: $inAllExpertises, ')
          ..write('inMana: $inMana, ')
          ..write('inAttack: $inAttack, ')
          ..write('inDefense: $inDefense, ')
          ..write('inDisplacment: $inDisplacment, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

abstract class _$AppDatabase extends GeneratedDatabase {
  _$AppDatabase(QueryExecutor e) : super(e);
  $AppDatabaseManager get managers => $AppDatabaseManager(this);
  late final $GrimoireTableTable grimoireTable = $GrimoireTableTable(this);
  late final $MagicCharacterTableTable magicCharacterTable =
      $MagicCharacterTableTable(this);
  late final $BoardTableTable boardTable = $BoardTableTable(this);
  late final $BoardMaterialTableTable boardMaterialTable =
      $BoardMaterialTableTable(this);
  late final $BoardSessionTableTable boardSessionTable =
      $BoardSessionTableTable(this);
  late final $BoardLinkTableTable boardLinkTable = $BoardLinkTableTable(this);
  late final $BoardPlayerTableTable boardPlayerTable = $BoardPlayerTableTable(
    this,
  );
  late final $BoardNoteTableTable boardNoteTable = $BoardNoteTableTable(this);
  late final $BoardCombatTableTable boardCombatTable = $BoardCombatTableTable(
    this,
  );
  late final $MenaceTableTable menaceTable = $MenaceTableTable(this);
  late final $AdventureBackpackTableTable adventureBackpackTable =
      $AdventureBackpackTableTable(this);
  late final $EquipmentTableTable equipmentTable = $EquipmentTableTable(this);
  late final $AmmunitionTableTable ammunitionTable = $AmmunitionTableTable(
    this,
  );
  late final $ArmorTableTable armorTable = $ArmorTableTable(this);
  late final $BackpackTableTable backpackTable = $BackpackTableTable(this);
  late final $GeneralItemTableTable generalItemTable = $GeneralItemTableTable(
    this,
  );
  late final $GeneralSkillTableTable generalSkillTable =
      $GeneralSkillTableTable(this);
  late final $MagicMenaceTableTable magicMenaceTable = $MagicMenaceTableTable(
    this,
  );
  late final $SaddlebagTableTable saddlebagTable = $SaddlebagTableTable(this);
  late final $ShieldTableTable shieldTable = $ShieldTableTable(this);
  late final $TibarsTableTable tibarsTable = $TibarsTableTable(this);
  late final $WeaponTableTable weaponTable = $WeaponTableTable(this);
  late final $ActionTableTable actionTable = $ActionTableTable(this);
  late final $ActionHandToHandTableTable actionHandToHandTable =
      $ActionHandToHandTableTable(this);
  late final $ActionDistanceAttackTableTable actionDistanceAttackTable =
      $ActionDistanceAttackTableTable(this);
  late final $ExpertiseTableTable expertiseTable = $ExpertiseTableTable(this);
  late final $MenaceLinkBoardTableTable menaceLinkBoardTable =
      $MenaceLinkBoardTableTable(this);
  late final $ConfigTableTable configTable = $ConfigTableTable(this);
  late final $CharacterTableTable characterTable = $CharacterTableTable(this);
  late final $ClasseCharacterTableTable classeCharacterTable =
      $ClasseCharacterTableTable(this);
  late final $OriginTableTable originTable = $OriginTableTable(this);
  late final $PowerTableTable powerTable = $PowerTableTable(this);
  late final $CharacterBoardTableTable characterBoardTable =
      $CharacterBoardTableTable(this);
  late final $CharacterConditionTableTable characterConditionTable =
      $CharacterConditionTableTable(this);
  late final GrimoireDAO grimoireDAO = GrimoireDAO(this as AppDatabase);
  late final BoardDAO boardDAO = BoardDAO(this as AppDatabase);
  late final MagicCharacterDAO magicCharacterDAO = MagicCharacterDAO(
    this as AppDatabase,
  );
  late final MenaceDAO menaceDAO = MenaceDAO(this as AppDatabase);
  late final ConfigDAO configDAO = ConfigDAO(this as AppDatabase);
  late final CharacterDAO characterDAO = CharacterDAO(this as AppDatabase);
  @override
  Iterable<TableInfo<Table, Object?>> get allTables =>
      allSchemaEntities.whereType<TableInfo<Table, Object?>>();
  @override
  List<DatabaseSchemaEntity> get allSchemaEntities => [
    grimoireTable,
    magicCharacterTable,
    boardTable,
    boardMaterialTable,
    boardSessionTable,
    boardLinkTable,
    boardPlayerTable,
    boardNoteTable,
    boardCombatTable,
    menaceTable,
    adventureBackpackTable,
    equipmentTable,
    ammunitionTable,
    armorTable,
    backpackTable,
    generalItemTable,
    generalSkillTable,
    magicMenaceTable,
    saddlebagTable,
    shieldTable,
    tibarsTable,
    weaponTable,
    actionTable,
    actionHandToHandTable,
    actionDistanceAttackTable,
    expertiseTable,
    menaceLinkBoardTable,
    configTable,
    characterTable,
    classeCharacterTable,
    originTable,
    powerTable,
    characterBoardTable,
    characterConditionTable,
  ];
}

typedef $$GrimoireTableTableCreateCompanionBuilder =
    GrimoireTableCompanion Function({
      required String uuid,
      required String name,
      Value<String?> desc,
      required String iconAsset,
      required int createdAt,
      required int updatedAt,
      Value<int> rowid,
    });
typedef $$GrimoireTableTableUpdateCompanionBuilder =
    GrimoireTableCompanion Function({
      Value<String> uuid,
      Value<String> name,
      Value<String?> desc,
      Value<String> iconAsset,
      Value<int> createdAt,
      Value<int> updatedAt,
      Value<int> rowid,
    });

class $$GrimoireTableTableFilterComposer
    extends Composer<_$AppDatabase, $GrimoireTableTable> {
  $$GrimoireTableTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get uuid => $composableBuilder(
    column: $table.uuid,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get desc => $composableBuilder(
    column: $table.desc,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get iconAsset => $composableBuilder(
    column: $table.iconAsset,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnFilters(column),
  );
}

class $$GrimoireTableTableOrderingComposer
    extends Composer<_$AppDatabase, $GrimoireTableTable> {
  $$GrimoireTableTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get uuid => $composableBuilder(
    column: $table.uuid,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get desc => $composableBuilder(
    column: $table.desc,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get iconAsset => $composableBuilder(
    column: $table.iconAsset,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$GrimoireTableTableAnnotationComposer
    extends Composer<_$AppDatabase, $GrimoireTableTable> {
  $$GrimoireTableTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get uuid =>
      $composableBuilder(column: $table.uuid, builder: (column) => column);

  GeneratedColumn<String> get name =>
      $composableBuilder(column: $table.name, builder: (column) => column);

  GeneratedColumn<String> get desc =>
      $composableBuilder(column: $table.desc, builder: (column) => column);

  GeneratedColumn<String> get iconAsset =>
      $composableBuilder(column: $table.iconAsset, builder: (column) => column);

  GeneratedColumn<int> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<int> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);
}

class $$GrimoireTableTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $GrimoireTableTable,
          GrimoireTableData,
          $$GrimoireTableTableFilterComposer,
          $$GrimoireTableTableOrderingComposer,
          $$GrimoireTableTableAnnotationComposer,
          $$GrimoireTableTableCreateCompanionBuilder,
          $$GrimoireTableTableUpdateCompanionBuilder,
          (
            GrimoireTableData,
            BaseReferences<
              _$AppDatabase,
              $GrimoireTableTable,
              GrimoireTableData
            >,
          ),
          GrimoireTableData,
          PrefetchHooks Function()
        > {
  $$GrimoireTableTableTableManager(_$AppDatabase db, $GrimoireTableTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$GrimoireTableTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$GrimoireTableTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$GrimoireTableTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> uuid = const Value.absent(),
                Value<String> name = const Value.absent(),
                Value<String?> desc = const Value.absent(),
                Value<String> iconAsset = const Value.absent(),
                Value<int> createdAt = const Value.absent(),
                Value<int> updatedAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => GrimoireTableCompanion(
                uuid: uuid,
                name: name,
                desc: desc,
                iconAsset: iconAsset,
                createdAt: createdAt,
                updatedAt: updatedAt,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String uuid,
                required String name,
                Value<String?> desc = const Value.absent(),
                required String iconAsset,
                required int createdAt,
                required int updatedAt,
                Value<int> rowid = const Value.absent(),
              }) => GrimoireTableCompanion.insert(
                uuid: uuid,
                name: name,
                desc: desc,
                iconAsset: iconAsset,
                createdAt: createdAt,
                updatedAt: updatedAt,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ),
      );
}

typedef $$GrimoireTableTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $GrimoireTableTable,
      GrimoireTableData,
      $$GrimoireTableTableFilterComposer,
      $$GrimoireTableTableOrderingComposer,
      $$GrimoireTableTableAnnotationComposer,
      $$GrimoireTableTableCreateCompanionBuilder,
      $$GrimoireTableTableUpdateCompanionBuilder,
      (
        GrimoireTableData,
        BaseReferences<_$AppDatabase, $GrimoireTableTable, GrimoireTableData>,
      ),
      GrimoireTableData,
      PrefetchHooks Function()
    >;
typedef $$MagicCharacterTableTableCreateCompanionBuilder =
    MagicCharacterTableCompanion Function({
      required int magicId,
      required String uuid,
      required String grimoireUUid,
      required String name,
      required String desc,
      required int circleLevel,
      required int typeIndex,
      required int schoolIndex,
      required int executionIndex,
      required int durationIndex,
      required int rangeIndex,
      required String resistence,
      required String targetAreaEfect,
      required String publication,
      Value<int?> pm,
      Value<int?> cd,
      Value<int?> mediumDamageValue,
      Value<String?> damageDices,
      Value<String?> extraDamageDices,
      Value<int> rowid,
    });
typedef $$MagicCharacterTableTableUpdateCompanionBuilder =
    MagicCharacterTableCompanion Function({
      Value<int> magicId,
      Value<String> uuid,
      Value<String> grimoireUUid,
      Value<String> name,
      Value<String> desc,
      Value<int> circleLevel,
      Value<int> typeIndex,
      Value<int> schoolIndex,
      Value<int> executionIndex,
      Value<int> durationIndex,
      Value<int> rangeIndex,
      Value<String> resistence,
      Value<String> targetAreaEfect,
      Value<String> publication,
      Value<int?> pm,
      Value<int?> cd,
      Value<int?> mediumDamageValue,
      Value<String?> damageDices,
      Value<String?> extraDamageDices,
      Value<int> rowid,
    });

class $$MagicCharacterTableTableFilterComposer
    extends Composer<_$AppDatabase, $MagicCharacterTableTable> {
  $$MagicCharacterTableTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get magicId => $composableBuilder(
    column: $table.magicId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get uuid => $composableBuilder(
    column: $table.uuid,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get grimoireUUid => $composableBuilder(
    column: $table.grimoireUUid,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get desc => $composableBuilder(
    column: $table.desc,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get circleLevel => $composableBuilder(
    column: $table.circleLevel,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get typeIndex => $composableBuilder(
    column: $table.typeIndex,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get schoolIndex => $composableBuilder(
    column: $table.schoolIndex,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get executionIndex => $composableBuilder(
    column: $table.executionIndex,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get durationIndex => $composableBuilder(
    column: $table.durationIndex,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get rangeIndex => $composableBuilder(
    column: $table.rangeIndex,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get resistence => $composableBuilder(
    column: $table.resistence,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get targetAreaEfect => $composableBuilder(
    column: $table.targetAreaEfect,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get publication => $composableBuilder(
    column: $table.publication,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get pm => $composableBuilder(
    column: $table.pm,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get cd => $composableBuilder(
    column: $table.cd,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get mediumDamageValue => $composableBuilder(
    column: $table.mediumDamageValue,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get damageDices => $composableBuilder(
    column: $table.damageDices,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get extraDamageDices => $composableBuilder(
    column: $table.extraDamageDices,
    builder: (column) => ColumnFilters(column),
  );
}

class $$MagicCharacterTableTableOrderingComposer
    extends Composer<_$AppDatabase, $MagicCharacterTableTable> {
  $$MagicCharacterTableTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get magicId => $composableBuilder(
    column: $table.magicId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get uuid => $composableBuilder(
    column: $table.uuid,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get grimoireUUid => $composableBuilder(
    column: $table.grimoireUUid,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get desc => $composableBuilder(
    column: $table.desc,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get circleLevel => $composableBuilder(
    column: $table.circleLevel,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get typeIndex => $composableBuilder(
    column: $table.typeIndex,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get schoolIndex => $composableBuilder(
    column: $table.schoolIndex,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get executionIndex => $composableBuilder(
    column: $table.executionIndex,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get durationIndex => $composableBuilder(
    column: $table.durationIndex,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get rangeIndex => $composableBuilder(
    column: $table.rangeIndex,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get resistence => $composableBuilder(
    column: $table.resistence,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get targetAreaEfect => $composableBuilder(
    column: $table.targetAreaEfect,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get publication => $composableBuilder(
    column: $table.publication,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get pm => $composableBuilder(
    column: $table.pm,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get cd => $composableBuilder(
    column: $table.cd,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get mediumDamageValue => $composableBuilder(
    column: $table.mediumDamageValue,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get damageDices => $composableBuilder(
    column: $table.damageDices,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get extraDamageDices => $composableBuilder(
    column: $table.extraDamageDices,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$MagicCharacterTableTableAnnotationComposer
    extends Composer<_$AppDatabase, $MagicCharacterTableTable> {
  $$MagicCharacterTableTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get magicId =>
      $composableBuilder(column: $table.magicId, builder: (column) => column);

  GeneratedColumn<String> get uuid =>
      $composableBuilder(column: $table.uuid, builder: (column) => column);

  GeneratedColumn<String> get grimoireUUid => $composableBuilder(
    column: $table.grimoireUUid,
    builder: (column) => column,
  );

  GeneratedColumn<String> get name =>
      $composableBuilder(column: $table.name, builder: (column) => column);

  GeneratedColumn<String> get desc =>
      $composableBuilder(column: $table.desc, builder: (column) => column);

  GeneratedColumn<int> get circleLevel => $composableBuilder(
    column: $table.circleLevel,
    builder: (column) => column,
  );

  GeneratedColumn<int> get typeIndex =>
      $composableBuilder(column: $table.typeIndex, builder: (column) => column);

  GeneratedColumn<int> get schoolIndex => $composableBuilder(
    column: $table.schoolIndex,
    builder: (column) => column,
  );

  GeneratedColumn<int> get executionIndex => $composableBuilder(
    column: $table.executionIndex,
    builder: (column) => column,
  );

  GeneratedColumn<int> get durationIndex => $composableBuilder(
    column: $table.durationIndex,
    builder: (column) => column,
  );

  GeneratedColumn<int> get rangeIndex => $composableBuilder(
    column: $table.rangeIndex,
    builder: (column) => column,
  );

  GeneratedColumn<String> get resistence => $composableBuilder(
    column: $table.resistence,
    builder: (column) => column,
  );

  GeneratedColumn<String> get targetAreaEfect => $composableBuilder(
    column: $table.targetAreaEfect,
    builder: (column) => column,
  );

  GeneratedColumn<String> get publication => $composableBuilder(
    column: $table.publication,
    builder: (column) => column,
  );

  GeneratedColumn<int> get pm =>
      $composableBuilder(column: $table.pm, builder: (column) => column);

  GeneratedColumn<int> get cd =>
      $composableBuilder(column: $table.cd, builder: (column) => column);

  GeneratedColumn<int> get mediumDamageValue => $composableBuilder(
    column: $table.mediumDamageValue,
    builder: (column) => column,
  );

  GeneratedColumn<String> get damageDices => $composableBuilder(
    column: $table.damageDices,
    builder: (column) => column,
  );

  GeneratedColumn<String> get extraDamageDices => $composableBuilder(
    column: $table.extraDamageDices,
    builder: (column) => column,
  );
}

class $$MagicCharacterTableTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $MagicCharacterTableTable,
          MagicCharacterTableData,
          $$MagicCharacterTableTableFilterComposer,
          $$MagicCharacterTableTableOrderingComposer,
          $$MagicCharacterTableTableAnnotationComposer,
          $$MagicCharacterTableTableCreateCompanionBuilder,
          $$MagicCharacterTableTableUpdateCompanionBuilder,
          (
            MagicCharacterTableData,
            BaseReferences<
              _$AppDatabase,
              $MagicCharacterTableTable,
              MagicCharacterTableData
            >,
          ),
          MagicCharacterTableData,
          PrefetchHooks Function()
        > {
  $$MagicCharacterTableTableTableManager(
    _$AppDatabase db,
    $MagicCharacterTableTable table,
  ) : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$MagicCharacterTableTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$MagicCharacterTableTableOrderingComposer(
                $db: db,
                $table: table,
              ),
          createComputedFieldComposer: () =>
              $$MagicCharacterTableTableAnnotationComposer(
                $db: db,
                $table: table,
              ),
          updateCompanionCallback:
              ({
                Value<int> magicId = const Value.absent(),
                Value<String> uuid = const Value.absent(),
                Value<String> grimoireUUid = const Value.absent(),
                Value<String> name = const Value.absent(),
                Value<String> desc = const Value.absent(),
                Value<int> circleLevel = const Value.absent(),
                Value<int> typeIndex = const Value.absent(),
                Value<int> schoolIndex = const Value.absent(),
                Value<int> executionIndex = const Value.absent(),
                Value<int> durationIndex = const Value.absent(),
                Value<int> rangeIndex = const Value.absent(),
                Value<String> resistence = const Value.absent(),
                Value<String> targetAreaEfect = const Value.absent(),
                Value<String> publication = const Value.absent(),
                Value<int?> pm = const Value.absent(),
                Value<int?> cd = const Value.absent(),
                Value<int?> mediumDamageValue = const Value.absent(),
                Value<String?> damageDices = const Value.absent(),
                Value<String?> extraDamageDices = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => MagicCharacterTableCompanion(
                magicId: magicId,
                uuid: uuid,
                grimoireUUid: grimoireUUid,
                name: name,
                desc: desc,
                circleLevel: circleLevel,
                typeIndex: typeIndex,
                schoolIndex: schoolIndex,
                executionIndex: executionIndex,
                durationIndex: durationIndex,
                rangeIndex: rangeIndex,
                resistence: resistence,
                targetAreaEfect: targetAreaEfect,
                publication: publication,
                pm: pm,
                cd: cd,
                mediumDamageValue: mediumDamageValue,
                damageDices: damageDices,
                extraDamageDices: extraDamageDices,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required int magicId,
                required String uuid,
                required String grimoireUUid,
                required String name,
                required String desc,
                required int circleLevel,
                required int typeIndex,
                required int schoolIndex,
                required int executionIndex,
                required int durationIndex,
                required int rangeIndex,
                required String resistence,
                required String targetAreaEfect,
                required String publication,
                Value<int?> pm = const Value.absent(),
                Value<int?> cd = const Value.absent(),
                Value<int?> mediumDamageValue = const Value.absent(),
                Value<String?> damageDices = const Value.absent(),
                Value<String?> extraDamageDices = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => MagicCharacterTableCompanion.insert(
                magicId: magicId,
                uuid: uuid,
                grimoireUUid: grimoireUUid,
                name: name,
                desc: desc,
                circleLevel: circleLevel,
                typeIndex: typeIndex,
                schoolIndex: schoolIndex,
                executionIndex: executionIndex,
                durationIndex: durationIndex,
                rangeIndex: rangeIndex,
                resistence: resistence,
                targetAreaEfect: targetAreaEfect,
                publication: publication,
                pm: pm,
                cd: cd,
                mediumDamageValue: mediumDamageValue,
                damageDices: damageDices,
                extraDamageDices: extraDamageDices,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ),
      );
}

typedef $$MagicCharacterTableTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $MagicCharacterTableTable,
      MagicCharacterTableData,
      $$MagicCharacterTableTableFilterComposer,
      $$MagicCharacterTableTableOrderingComposer,
      $$MagicCharacterTableTableAnnotationComposer,
      $$MagicCharacterTableTableCreateCompanionBuilder,
      $$MagicCharacterTableTableUpdateCompanionBuilder,
      (
        MagicCharacterTableData,
        BaseReferences<
          _$AppDatabase,
          $MagicCharacterTableTable,
          MagicCharacterTableData
        >,
      ),
      MagicCharacterTableData,
      PrefetchHooks Function()
    >;
typedef $$BoardTableTableCreateCompanionBuilder =
    BoardTableCompanion Function({
      required String uuid,
      required String name,
      required int level,
      required int modeIndex,
      required String adventureName,
      Value<String?> bannerPath,
      Value<String?> desc,
      required int createdAt,
      required int updatedAt,
      Value<String?> whatsGroupLink,
      Value<String?> telegramGroupLink,
      Value<String?> discordServerLink,
      Value<String?> driveFilesLink,
      required bool isFavorited,
      Value<int> rowid,
    });
typedef $$BoardTableTableUpdateCompanionBuilder =
    BoardTableCompanion Function({
      Value<String> uuid,
      Value<String> name,
      Value<int> level,
      Value<int> modeIndex,
      Value<String> adventureName,
      Value<String?> bannerPath,
      Value<String?> desc,
      Value<int> createdAt,
      Value<int> updatedAt,
      Value<String?> whatsGroupLink,
      Value<String?> telegramGroupLink,
      Value<String?> discordServerLink,
      Value<String?> driveFilesLink,
      Value<bool> isFavorited,
      Value<int> rowid,
    });

class $$BoardTableTableFilterComposer
    extends Composer<_$AppDatabase, $BoardTableTable> {
  $$BoardTableTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get uuid => $composableBuilder(
    column: $table.uuid,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get level => $composableBuilder(
    column: $table.level,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get modeIndex => $composableBuilder(
    column: $table.modeIndex,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get adventureName => $composableBuilder(
    column: $table.adventureName,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get bannerPath => $composableBuilder(
    column: $table.bannerPath,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get desc => $composableBuilder(
    column: $table.desc,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get whatsGroupLink => $composableBuilder(
    column: $table.whatsGroupLink,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get telegramGroupLink => $composableBuilder(
    column: $table.telegramGroupLink,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get discordServerLink => $composableBuilder(
    column: $table.discordServerLink,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get driveFilesLink => $composableBuilder(
    column: $table.driveFilesLink,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get isFavorited => $composableBuilder(
    column: $table.isFavorited,
    builder: (column) => ColumnFilters(column),
  );
}

class $$BoardTableTableOrderingComposer
    extends Composer<_$AppDatabase, $BoardTableTable> {
  $$BoardTableTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get uuid => $composableBuilder(
    column: $table.uuid,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get level => $composableBuilder(
    column: $table.level,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get modeIndex => $composableBuilder(
    column: $table.modeIndex,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get adventureName => $composableBuilder(
    column: $table.adventureName,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get bannerPath => $composableBuilder(
    column: $table.bannerPath,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get desc => $composableBuilder(
    column: $table.desc,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get whatsGroupLink => $composableBuilder(
    column: $table.whatsGroupLink,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get telegramGroupLink => $composableBuilder(
    column: $table.telegramGroupLink,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get discordServerLink => $composableBuilder(
    column: $table.discordServerLink,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get driveFilesLink => $composableBuilder(
    column: $table.driveFilesLink,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get isFavorited => $composableBuilder(
    column: $table.isFavorited,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$BoardTableTableAnnotationComposer
    extends Composer<_$AppDatabase, $BoardTableTable> {
  $$BoardTableTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get uuid =>
      $composableBuilder(column: $table.uuid, builder: (column) => column);

  GeneratedColumn<String> get name =>
      $composableBuilder(column: $table.name, builder: (column) => column);

  GeneratedColumn<int> get level =>
      $composableBuilder(column: $table.level, builder: (column) => column);

  GeneratedColumn<int> get modeIndex =>
      $composableBuilder(column: $table.modeIndex, builder: (column) => column);

  GeneratedColumn<String> get adventureName => $composableBuilder(
    column: $table.adventureName,
    builder: (column) => column,
  );

  GeneratedColumn<String> get bannerPath => $composableBuilder(
    column: $table.bannerPath,
    builder: (column) => column,
  );

  GeneratedColumn<String> get desc =>
      $composableBuilder(column: $table.desc, builder: (column) => column);

  GeneratedColumn<int> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<int> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);

  GeneratedColumn<String> get whatsGroupLink => $composableBuilder(
    column: $table.whatsGroupLink,
    builder: (column) => column,
  );

  GeneratedColumn<String> get telegramGroupLink => $composableBuilder(
    column: $table.telegramGroupLink,
    builder: (column) => column,
  );

  GeneratedColumn<String> get discordServerLink => $composableBuilder(
    column: $table.discordServerLink,
    builder: (column) => column,
  );

  GeneratedColumn<String> get driveFilesLink => $composableBuilder(
    column: $table.driveFilesLink,
    builder: (column) => column,
  );

  GeneratedColumn<bool> get isFavorited => $composableBuilder(
    column: $table.isFavorited,
    builder: (column) => column,
  );
}

class $$BoardTableTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $BoardTableTable,
          BoardTableData,
          $$BoardTableTableFilterComposer,
          $$BoardTableTableOrderingComposer,
          $$BoardTableTableAnnotationComposer,
          $$BoardTableTableCreateCompanionBuilder,
          $$BoardTableTableUpdateCompanionBuilder,
          (
            BoardTableData,
            BaseReferences<_$AppDatabase, $BoardTableTable, BoardTableData>,
          ),
          BoardTableData,
          PrefetchHooks Function()
        > {
  $$BoardTableTableTableManager(_$AppDatabase db, $BoardTableTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$BoardTableTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$BoardTableTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$BoardTableTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> uuid = const Value.absent(),
                Value<String> name = const Value.absent(),
                Value<int> level = const Value.absent(),
                Value<int> modeIndex = const Value.absent(),
                Value<String> adventureName = const Value.absent(),
                Value<String?> bannerPath = const Value.absent(),
                Value<String?> desc = const Value.absent(),
                Value<int> createdAt = const Value.absent(),
                Value<int> updatedAt = const Value.absent(),
                Value<String?> whatsGroupLink = const Value.absent(),
                Value<String?> telegramGroupLink = const Value.absent(),
                Value<String?> discordServerLink = const Value.absent(),
                Value<String?> driveFilesLink = const Value.absent(),
                Value<bool> isFavorited = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => BoardTableCompanion(
                uuid: uuid,
                name: name,
                level: level,
                modeIndex: modeIndex,
                adventureName: adventureName,
                bannerPath: bannerPath,
                desc: desc,
                createdAt: createdAt,
                updatedAt: updatedAt,
                whatsGroupLink: whatsGroupLink,
                telegramGroupLink: telegramGroupLink,
                discordServerLink: discordServerLink,
                driveFilesLink: driveFilesLink,
                isFavorited: isFavorited,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String uuid,
                required String name,
                required int level,
                required int modeIndex,
                required String adventureName,
                Value<String?> bannerPath = const Value.absent(),
                Value<String?> desc = const Value.absent(),
                required int createdAt,
                required int updatedAt,
                Value<String?> whatsGroupLink = const Value.absent(),
                Value<String?> telegramGroupLink = const Value.absent(),
                Value<String?> discordServerLink = const Value.absent(),
                Value<String?> driveFilesLink = const Value.absent(),
                required bool isFavorited,
                Value<int> rowid = const Value.absent(),
              }) => BoardTableCompanion.insert(
                uuid: uuid,
                name: name,
                level: level,
                modeIndex: modeIndex,
                adventureName: adventureName,
                bannerPath: bannerPath,
                desc: desc,
                createdAt: createdAt,
                updatedAt: updatedAt,
                whatsGroupLink: whatsGroupLink,
                telegramGroupLink: telegramGroupLink,
                discordServerLink: discordServerLink,
                driveFilesLink: driveFilesLink,
                isFavorited: isFavorited,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ),
      );
}

typedef $$BoardTableTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $BoardTableTable,
      BoardTableData,
      $$BoardTableTableFilterComposer,
      $$BoardTableTableOrderingComposer,
      $$BoardTableTableAnnotationComposer,
      $$BoardTableTableCreateCompanionBuilder,
      $$BoardTableTableUpdateCompanionBuilder,
      (
        BoardTableData,
        BaseReferences<_$AppDatabase, $BoardTableTable, BoardTableData>,
      ),
      BoardTableData,
      PrefetchHooks Function()
    >;
typedef $$BoardMaterialTableTableCreateCompanionBuilder =
    BoardMaterialTableCompanion Function({
      required String uuid,
      required int typeIndex,
      required String path,
      required String boardUuid,
      required int createdAt,
      Value<int> rowid,
    });
typedef $$BoardMaterialTableTableUpdateCompanionBuilder =
    BoardMaterialTableCompanion Function({
      Value<String> uuid,
      Value<int> typeIndex,
      Value<String> path,
      Value<String> boardUuid,
      Value<int> createdAt,
      Value<int> rowid,
    });

class $$BoardMaterialTableTableFilterComposer
    extends Composer<_$AppDatabase, $BoardMaterialTableTable> {
  $$BoardMaterialTableTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get uuid => $composableBuilder(
    column: $table.uuid,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get typeIndex => $composableBuilder(
    column: $table.typeIndex,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get path => $composableBuilder(
    column: $table.path,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get boardUuid => $composableBuilder(
    column: $table.boardUuid,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );
}

class $$BoardMaterialTableTableOrderingComposer
    extends Composer<_$AppDatabase, $BoardMaterialTableTable> {
  $$BoardMaterialTableTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get uuid => $composableBuilder(
    column: $table.uuid,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get typeIndex => $composableBuilder(
    column: $table.typeIndex,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get path => $composableBuilder(
    column: $table.path,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get boardUuid => $composableBuilder(
    column: $table.boardUuid,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$BoardMaterialTableTableAnnotationComposer
    extends Composer<_$AppDatabase, $BoardMaterialTableTable> {
  $$BoardMaterialTableTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get uuid =>
      $composableBuilder(column: $table.uuid, builder: (column) => column);

  GeneratedColumn<int> get typeIndex =>
      $composableBuilder(column: $table.typeIndex, builder: (column) => column);

  GeneratedColumn<String> get path =>
      $composableBuilder(column: $table.path, builder: (column) => column);

  GeneratedColumn<String> get boardUuid =>
      $composableBuilder(column: $table.boardUuid, builder: (column) => column);

  GeneratedColumn<int> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);
}

class $$BoardMaterialTableTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $BoardMaterialTableTable,
          BoardMaterialTableData,
          $$BoardMaterialTableTableFilterComposer,
          $$BoardMaterialTableTableOrderingComposer,
          $$BoardMaterialTableTableAnnotationComposer,
          $$BoardMaterialTableTableCreateCompanionBuilder,
          $$BoardMaterialTableTableUpdateCompanionBuilder,
          (
            BoardMaterialTableData,
            BaseReferences<
              _$AppDatabase,
              $BoardMaterialTableTable,
              BoardMaterialTableData
            >,
          ),
          BoardMaterialTableData,
          PrefetchHooks Function()
        > {
  $$BoardMaterialTableTableTableManager(
    _$AppDatabase db,
    $BoardMaterialTableTable table,
  ) : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$BoardMaterialTableTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$BoardMaterialTableTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$BoardMaterialTableTableAnnotationComposer(
                $db: db,
                $table: table,
              ),
          updateCompanionCallback:
              ({
                Value<String> uuid = const Value.absent(),
                Value<int> typeIndex = const Value.absent(),
                Value<String> path = const Value.absent(),
                Value<String> boardUuid = const Value.absent(),
                Value<int> createdAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => BoardMaterialTableCompanion(
                uuid: uuid,
                typeIndex: typeIndex,
                path: path,
                boardUuid: boardUuid,
                createdAt: createdAt,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String uuid,
                required int typeIndex,
                required String path,
                required String boardUuid,
                required int createdAt,
                Value<int> rowid = const Value.absent(),
              }) => BoardMaterialTableCompanion.insert(
                uuid: uuid,
                typeIndex: typeIndex,
                path: path,
                boardUuid: boardUuid,
                createdAt: createdAt,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ),
      );
}

typedef $$BoardMaterialTableTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $BoardMaterialTableTable,
      BoardMaterialTableData,
      $$BoardMaterialTableTableFilterComposer,
      $$BoardMaterialTableTableOrderingComposer,
      $$BoardMaterialTableTableAnnotationComposer,
      $$BoardMaterialTableTableCreateCompanionBuilder,
      $$BoardMaterialTableTableUpdateCompanionBuilder,
      (
        BoardMaterialTableData,
        BaseReferences<
          _$AppDatabase,
          $BoardMaterialTableTable,
          BoardMaterialTableData
        >,
      ),
      BoardMaterialTableData,
      PrefetchHooks Function()
    >;
typedef $$BoardSessionTableTableCreateCompanionBuilder =
    BoardSessionTableCompanion Function({
      required String uuid,
      required String boardUuid,
      Value<int?> environmentIndex,
      required int startedAt,
      Value<int?> endAt,
      required int updatedAt,
      Value<int> rowid,
    });
typedef $$BoardSessionTableTableUpdateCompanionBuilder =
    BoardSessionTableCompanion Function({
      Value<String> uuid,
      Value<String> boardUuid,
      Value<int?> environmentIndex,
      Value<int> startedAt,
      Value<int?> endAt,
      Value<int> updatedAt,
      Value<int> rowid,
    });

class $$BoardSessionTableTableFilterComposer
    extends Composer<_$AppDatabase, $BoardSessionTableTable> {
  $$BoardSessionTableTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get uuid => $composableBuilder(
    column: $table.uuid,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get boardUuid => $composableBuilder(
    column: $table.boardUuid,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get environmentIndex => $composableBuilder(
    column: $table.environmentIndex,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get startedAt => $composableBuilder(
    column: $table.startedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get endAt => $composableBuilder(
    column: $table.endAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnFilters(column),
  );
}

class $$BoardSessionTableTableOrderingComposer
    extends Composer<_$AppDatabase, $BoardSessionTableTable> {
  $$BoardSessionTableTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get uuid => $composableBuilder(
    column: $table.uuid,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get boardUuid => $composableBuilder(
    column: $table.boardUuid,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get environmentIndex => $composableBuilder(
    column: $table.environmentIndex,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get startedAt => $composableBuilder(
    column: $table.startedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get endAt => $composableBuilder(
    column: $table.endAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$BoardSessionTableTableAnnotationComposer
    extends Composer<_$AppDatabase, $BoardSessionTableTable> {
  $$BoardSessionTableTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get uuid =>
      $composableBuilder(column: $table.uuid, builder: (column) => column);

  GeneratedColumn<String> get boardUuid =>
      $composableBuilder(column: $table.boardUuid, builder: (column) => column);

  GeneratedColumn<int> get environmentIndex => $composableBuilder(
    column: $table.environmentIndex,
    builder: (column) => column,
  );

  GeneratedColumn<int> get startedAt =>
      $composableBuilder(column: $table.startedAt, builder: (column) => column);

  GeneratedColumn<int> get endAt =>
      $composableBuilder(column: $table.endAt, builder: (column) => column);

  GeneratedColumn<int> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);
}

class $$BoardSessionTableTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $BoardSessionTableTable,
          BoardSessionTableData,
          $$BoardSessionTableTableFilterComposer,
          $$BoardSessionTableTableOrderingComposer,
          $$BoardSessionTableTableAnnotationComposer,
          $$BoardSessionTableTableCreateCompanionBuilder,
          $$BoardSessionTableTableUpdateCompanionBuilder,
          (
            BoardSessionTableData,
            BaseReferences<
              _$AppDatabase,
              $BoardSessionTableTable,
              BoardSessionTableData
            >,
          ),
          BoardSessionTableData,
          PrefetchHooks Function()
        > {
  $$BoardSessionTableTableTableManager(
    _$AppDatabase db,
    $BoardSessionTableTable table,
  ) : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$BoardSessionTableTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$BoardSessionTableTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$BoardSessionTableTableAnnotationComposer(
                $db: db,
                $table: table,
              ),
          updateCompanionCallback:
              ({
                Value<String> uuid = const Value.absent(),
                Value<String> boardUuid = const Value.absent(),
                Value<int?> environmentIndex = const Value.absent(),
                Value<int> startedAt = const Value.absent(),
                Value<int?> endAt = const Value.absent(),
                Value<int> updatedAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => BoardSessionTableCompanion(
                uuid: uuid,
                boardUuid: boardUuid,
                environmentIndex: environmentIndex,
                startedAt: startedAt,
                endAt: endAt,
                updatedAt: updatedAt,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String uuid,
                required String boardUuid,
                Value<int?> environmentIndex = const Value.absent(),
                required int startedAt,
                Value<int?> endAt = const Value.absent(),
                required int updatedAt,
                Value<int> rowid = const Value.absent(),
              }) => BoardSessionTableCompanion.insert(
                uuid: uuid,
                boardUuid: boardUuid,
                environmentIndex: environmentIndex,
                startedAt: startedAt,
                endAt: endAt,
                updatedAt: updatedAt,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ),
      );
}

typedef $$BoardSessionTableTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $BoardSessionTableTable,
      BoardSessionTableData,
      $$BoardSessionTableTableFilterComposer,
      $$BoardSessionTableTableOrderingComposer,
      $$BoardSessionTableTableAnnotationComposer,
      $$BoardSessionTableTableCreateCompanionBuilder,
      $$BoardSessionTableTableUpdateCompanionBuilder,
      (
        BoardSessionTableData,
        BaseReferences<
          _$AppDatabase,
          $BoardSessionTableTable,
          BoardSessionTableData
        >,
      ),
      BoardSessionTableData,
      PrefetchHooks Function()
    >;
typedef $$BoardLinkTableTableCreateCompanionBuilder =
    BoardLinkTableCompanion Function({
      required String uuid,
      required String link,
      required String boardUuid,
      required String title,
      required int createdAt,
      required int updatedAt,
      Value<int> rowid,
    });
typedef $$BoardLinkTableTableUpdateCompanionBuilder =
    BoardLinkTableCompanion Function({
      Value<String> uuid,
      Value<String> link,
      Value<String> boardUuid,
      Value<String> title,
      Value<int> createdAt,
      Value<int> updatedAt,
      Value<int> rowid,
    });

class $$BoardLinkTableTableFilterComposer
    extends Composer<_$AppDatabase, $BoardLinkTableTable> {
  $$BoardLinkTableTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get uuid => $composableBuilder(
    column: $table.uuid,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get link => $composableBuilder(
    column: $table.link,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get boardUuid => $composableBuilder(
    column: $table.boardUuid,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get title => $composableBuilder(
    column: $table.title,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnFilters(column),
  );
}

class $$BoardLinkTableTableOrderingComposer
    extends Composer<_$AppDatabase, $BoardLinkTableTable> {
  $$BoardLinkTableTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get uuid => $composableBuilder(
    column: $table.uuid,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get link => $composableBuilder(
    column: $table.link,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get boardUuid => $composableBuilder(
    column: $table.boardUuid,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get title => $composableBuilder(
    column: $table.title,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$BoardLinkTableTableAnnotationComposer
    extends Composer<_$AppDatabase, $BoardLinkTableTable> {
  $$BoardLinkTableTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get uuid =>
      $composableBuilder(column: $table.uuid, builder: (column) => column);

  GeneratedColumn<String> get link =>
      $composableBuilder(column: $table.link, builder: (column) => column);

  GeneratedColumn<String> get boardUuid =>
      $composableBuilder(column: $table.boardUuid, builder: (column) => column);

  GeneratedColumn<String> get title =>
      $composableBuilder(column: $table.title, builder: (column) => column);

  GeneratedColumn<int> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<int> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);
}

class $$BoardLinkTableTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $BoardLinkTableTable,
          BoardLinkTableData,
          $$BoardLinkTableTableFilterComposer,
          $$BoardLinkTableTableOrderingComposer,
          $$BoardLinkTableTableAnnotationComposer,
          $$BoardLinkTableTableCreateCompanionBuilder,
          $$BoardLinkTableTableUpdateCompanionBuilder,
          (
            BoardLinkTableData,
            BaseReferences<
              _$AppDatabase,
              $BoardLinkTableTable,
              BoardLinkTableData
            >,
          ),
          BoardLinkTableData,
          PrefetchHooks Function()
        > {
  $$BoardLinkTableTableTableManager(
    _$AppDatabase db,
    $BoardLinkTableTable table,
  ) : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$BoardLinkTableTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$BoardLinkTableTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$BoardLinkTableTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> uuid = const Value.absent(),
                Value<String> link = const Value.absent(),
                Value<String> boardUuid = const Value.absent(),
                Value<String> title = const Value.absent(),
                Value<int> createdAt = const Value.absent(),
                Value<int> updatedAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => BoardLinkTableCompanion(
                uuid: uuid,
                link: link,
                boardUuid: boardUuid,
                title: title,
                createdAt: createdAt,
                updatedAt: updatedAt,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String uuid,
                required String link,
                required String boardUuid,
                required String title,
                required int createdAt,
                required int updatedAt,
                Value<int> rowid = const Value.absent(),
              }) => BoardLinkTableCompanion.insert(
                uuid: uuid,
                link: link,
                boardUuid: boardUuid,
                title: title,
                createdAt: createdAt,
                updatedAt: updatedAt,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ),
      );
}

typedef $$BoardLinkTableTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $BoardLinkTableTable,
      BoardLinkTableData,
      $$BoardLinkTableTableFilterComposer,
      $$BoardLinkTableTableOrderingComposer,
      $$BoardLinkTableTableAnnotationComposer,
      $$BoardLinkTableTableCreateCompanionBuilder,
      $$BoardLinkTableTableUpdateCompanionBuilder,
      (
        BoardLinkTableData,
        BaseReferences<_$AppDatabase, $BoardLinkTableTable, BoardLinkTableData>,
      ),
      BoardLinkTableData,
      PrefetchHooks Function()
    >;
typedef $$BoardPlayerTableTableCreateCompanionBuilder =
    BoardPlayerTableCompanion Function({
      required String uuid,
      required String boardUuid,
      required String characterName,
      required String playerName,
      Value<String?> imagePath,
      Value<String?> imageAsset,
      required int broodIndex,
      required int createdAt,
      required int updatedAt,
      required int life,
      required int mana,
      required int defense,
      required int initiative,
      required bool isAlive,
      required String classeIndexes,
      Value<int> rowid,
    });
typedef $$BoardPlayerTableTableUpdateCompanionBuilder =
    BoardPlayerTableCompanion Function({
      Value<String> uuid,
      Value<String> boardUuid,
      Value<String> characterName,
      Value<String> playerName,
      Value<String?> imagePath,
      Value<String?> imageAsset,
      Value<int> broodIndex,
      Value<int> createdAt,
      Value<int> updatedAt,
      Value<int> life,
      Value<int> mana,
      Value<int> defense,
      Value<int> initiative,
      Value<bool> isAlive,
      Value<String> classeIndexes,
      Value<int> rowid,
    });

class $$BoardPlayerTableTableFilterComposer
    extends Composer<_$AppDatabase, $BoardPlayerTableTable> {
  $$BoardPlayerTableTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get uuid => $composableBuilder(
    column: $table.uuid,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get boardUuid => $composableBuilder(
    column: $table.boardUuid,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get characterName => $composableBuilder(
    column: $table.characterName,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get playerName => $composableBuilder(
    column: $table.playerName,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get imagePath => $composableBuilder(
    column: $table.imagePath,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get imageAsset => $composableBuilder(
    column: $table.imageAsset,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get broodIndex => $composableBuilder(
    column: $table.broodIndex,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get life => $composableBuilder(
    column: $table.life,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get mana => $composableBuilder(
    column: $table.mana,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get defense => $composableBuilder(
    column: $table.defense,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get initiative => $composableBuilder(
    column: $table.initiative,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get isAlive => $composableBuilder(
    column: $table.isAlive,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get classeIndexes => $composableBuilder(
    column: $table.classeIndexes,
    builder: (column) => ColumnFilters(column),
  );
}

class $$BoardPlayerTableTableOrderingComposer
    extends Composer<_$AppDatabase, $BoardPlayerTableTable> {
  $$BoardPlayerTableTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get uuid => $composableBuilder(
    column: $table.uuid,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get boardUuid => $composableBuilder(
    column: $table.boardUuid,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get characterName => $composableBuilder(
    column: $table.characterName,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get playerName => $composableBuilder(
    column: $table.playerName,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get imagePath => $composableBuilder(
    column: $table.imagePath,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get imageAsset => $composableBuilder(
    column: $table.imageAsset,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get broodIndex => $composableBuilder(
    column: $table.broodIndex,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get life => $composableBuilder(
    column: $table.life,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get mana => $composableBuilder(
    column: $table.mana,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get defense => $composableBuilder(
    column: $table.defense,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get initiative => $composableBuilder(
    column: $table.initiative,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get isAlive => $composableBuilder(
    column: $table.isAlive,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get classeIndexes => $composableBuilder(
    column: $table.classeIndexes,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$BoardPlayerTableTableAnnotationComposer
    extends Composer<_$AppDatabase, $BoardPlayerTableTable> {
  $$BoardPlayerTableTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get uuid =>
      $composableBuilder(column: $table.uuid, builder: (column) => column);

  GeneratedColumn<String> get boardUuid =>
      $composableBuilder(column: $table.boardUuid, builder: (column) => column);

  GeneratedColumn<String> get characterName => $composableBuilder(
    column: $table.characterName,
    builder: (column) => column,
  );

  GeneratedColumn<String> get playerName => $composableBuilder(
    column: $table.playerName,
    builder: (column) => column,
  );

  GeneratedColumn<String> get imagePath =>
      $composableBuilder(column: $table.imagePath, builder: (column) => column);

  GeneratedColumn<String> get imageAsset => $composableBuilder(
    column: $table.imageAsset,
    builder: (column) => column,
  );

  GeneratedColumn<int> get broodIndex => $composableBuilder(
    column: $table.broodIndex,
    builder: (column) => column,
  );

  GeneratedColumn<int> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<int> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);

  GeneratedColumn<int> get life =>
      $composableBuilder(column: $table.life, builder: (column) => column);

  GeneratedColumn<int> get mana =>
      $composableBuilder(column: $table.mana, builder: (column) => column);

  GeneratedColumn<int> get defense =>
      $composableBuilder(column: $table.defense, builder: (column) => column);

  GeneratedColumn<int> get initiative => $composableBuilder(
    column: $table.initiative,
    builder: (column) => column,
  );

  GeneratedColumn<bool> get isAlive =>
      $composableBuilder(column: $table.isAlive, builder: (column) => column);

  GeneratedColumn<String> get classeIndexes => $composableBuilder(
    column: $table.classeIndexes,
    builder: (column) => column,
  );
}

class $$BoardPlayerTableTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $BoardPlayerTableTable,
          BoardPlayerTableData,
          $$BoardPlayerTableTableFilterComposer,
          $$BoardPlayerTableTableOrderingComposer,
          $$BoardPlayerTableTableAnnotationComposer,
          $$BoardPlayerTableTableCreateCompanionBuilder,
          $$BoardPlayerTableTableUpdateCompanionBuilder,
          (
            BoardPlayerTableData,
            BaseReferences<
              _$AppDatabase,
              $BoardPlayerTableTable,
              BoardPlayerTableData
            >,
          ),
          BoardPlayerTableData,
          PrefetchHooks Function()
        > {
  $$BoardPlayerTableTableTableManager(
    _$AppDatabase db,
    $BoardPlayerTableTable table,
  ) : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$BoardPlayerTableTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$BoardPlayerTableTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$BoardPlayerTableTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> uuid = const Value.absent(),
                Value<String> boardUuid = const Value.absent(),
                Value<String> characterName = const Value.absent(),
                Value<String> playerName = const Value.absent(),
                Value<String?> imagePath = const Value.absent(),
                Value<String?> imageAsset = const Value.absent(),
                Value<int> broodIndex = const Value.absent(),
                Value<int> createdAt = const Value.absent(),
                Value<int> updatedAt = const Value.absent(),
                Value<int> life = const Value.absent(),
                Value<int> mana = const Value.absent(),
                Value<int> defense = const Value.absent(),
                Value<int> initiative = const Value.absent(),
                Value<bool> isAlive = const Value.absent(),
                Value<String> classeIndexes = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => BoardPlayerTableCompanion(
                uuid: uuid,
                boardUuid: boardUuid,
                characterName: characterName,
                playerName: playerName,
                imagePath: imagePath,
                imageAsset: imageAsset,
                broodIndex: broodIndex,
                createdAt: createdAt,
                updatedAt: updatedAt,
                life: life,
                mana: mana,
                defense: defense,
                initiative: initiative,
                isAlive: isAlive,
                classeIndexes: classeIndexes,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String uuid,
                required String boardUuid,
                required String characterName,
                required String playerName,
                Value<String?> imagePath = const Value.absent(),
                Value<String?> imageAsset = const Value.absent(),
                required int broodIndex,
                required int createdAt,
                required int updatedAt,
                required int life,
                required int mana,
                required int defense,
                required int initiative,
                required bool isAlive,
                required String classeIndexes,
                Value<int> rowid = const Value.absent(),
              }) => BoardPlayerTableCompanion.insert(
                uuid: uuid,
                boardUuid: boardUuid,
                characterName: characterName,
                playerName: playerName,
                imagePath: imagePath,
                imageAsset: imageAsset,
                broodIndex: broodIndex,
                createdAt: createdAt,
                updatedAt: updatedAt,
                life: life,
                mana: mana,
                defense: defense,
                initiative: initiative,
                isAlive: isAlive,
                classeIndexes: classeIndexes,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ),
      );
}

typedef $$BoardPlayerTableTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $BoardPlayerTableTable,
      BoardPlayerTableData,
      $$BoardPlayerTableTableFilterComposer,
      $$BoardPlayerTableTableOrderingComposer,
      $$BoardPlayerTableTableAnnotationComposer,
      $$BoardPlayerTableTableCreateCompanionBuilder,
      $$BoardPlayerTableTableUpdateCompanionBuilder,
      (
        BoardPlayerTableData,
        BaseReferences<
          _$AppDatabase,
          $BoardPlayerTableTable,
          BoardPlayerTableData
        >,
      ),
      BoardPlayerTableData,
      PrefetchHooks Function()
    >;
typedef $$BoardNoteTableTableCreateCompanionBuilder =
    BoardNoteTableCompanion Function({
      required String uuid,
      required String boardUuid,
      required String note,
      required bool isFavorited,
      required int createdAt,
      required int updatedAt,
      Value<int> rowid,
    });
typedef $$BoardNoteTableTableUpdateCompanionBuilder =
    BoardNoteTableCompanion Function({
      Value<String> uuid,
      Value<String> boardUuid,
      Value<String> note,
      Value<bool> isFavorited,
      Value<int> createdAt,
      Value<int> updatedAt,
      Value<int> rowid,
    });

class $$BoardNoteTableTableFilterComposer
    extends Composer<_$AppDatabase, $BoardNoteTableTable> {
  $$BoardNoteTableTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get uuid => $composableBuilder(
    column: $table.uuid,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get boardUuid => $composableBuilder(
    column: $table.boardUuid,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get note => $composableBuilder(
    column: $table.note,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get isFavorited => $composableBuilder(
    column: $table.isFavorited,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnFilters(column),
  );
}

class $$BoardNoteTableTableOrderingComposer
    extends Composer<_$AppDatabase, $BoardNoteTableTable> {
  $$BoardNoteTableTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get uuid => $composableBuilder(
    column: $table.uuid,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get boardUuid => $composableBuilder(
    column: $table.boardUuid,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get note => $composableBuilder(
    column: $table.note,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get isFavorited => $composableBuilder(
    column: $table.isFavorited,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$BoardNoteTableTableAnnotationComposer
    extends Composer<_$AppDatabase, $BoardNoteTableTable> {
  $$BoardNoteTableTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get uuid =>
      $composableBuilder(column: $table.uuid, builder: (column) => column);

  GeneratedColumn<String> get boardUuid =>
      $composableBuilder(column: $table.boardUuid, builder: (column) => column);

  GeneratedColumn<String> get note =>
      $composableBuilder(column: $table.note, builder: (column) => column);

  GeneratedColumn<bool> get isFavorited => $composableBuilder(
    column: $table.isFavorited,
    builder: (column) => column,
  );

  GeneratedColumn<int> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<int> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);
}

class $$BoardNoteTableTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $BoardNoteTableTable,
          BoardNoteTableData,
          $$BoardNoteTableTableFilterComposer,
          $$BoardNoteTableTableOrderingComposer,
          $$BoardNoteTableTableAnnotationComposer,
          $$BoardNoteTableTableCreateCompanionBuilder,
          $$BoardNoteTableTableUpdateCompanionBuilder,
          (
            BoardNoteTableData,
            BaseReferences<
              _$AppDatabase,
              $BoardNoteTableTable,
              BoardNoteTableData
            >,
          ),
          BoardNoteTableData,
          PrefetchHooks Function()
        > {
  $$BoardNoteTableTableTableManager(
    _$AppDatabase db,
    $BoardNoteTableTable table,
  ) : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$BoardNoteTableTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$BoardNoteTableTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$BoardNoteTableTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> uuid = const Value.absent(),
                Value<String> boardUuid = const Value.absent(),
                Value<String> note = const Value.absent(),
                Value<bool> isFavorited = const Value.absent(),
                Value<int> createdAt = const Value.absent(),
                Value<int> updatedAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => BoardNoteTableCompanion(
                uuid: uuid,
                boardUuid: boardUuid,
                note: note,
                isFavorited: isFavorited,
                createdAt: createdAt,
                updatedAt: updatedAt,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String uuid,
                required String boardUuid,
                required String note,
                required bool isFavorited,
                required int createdAt,
                required int updatedAt,
                Value<int> rowid = const Value.absent(),
              }) => BoardNoteTableCompanion.insert(
                uuid: uuid,
                boardUuid: boardUuid,
                note: note,
                isFavorited: isFavorited,
                createdAt: createdAt,
                updatedAt: updatedAt,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ),
      );
}

typedef $$BoardNoteTableTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $BoardNoteTableTable,
      BoardNoteTableData,
      $$BoardNoteTableTableFilterComposer,
      $$BoardNoteTableTableOrderingComposer,
      $$BoardNoteTableTableAnnotationComposer,
      $$BoardNoteTableTableCreateCompanionBuilder,
      $$BoardNoteTableTableUpdateCompanionBuilder,
      (
        BoardNoteTableData,
        BaseReferences<_$AppDatabase, $BoardNoteTableTable, BoardNoteTableData>,
      ),
      BoardNoteTableData,
      PrefetchHooks Function()
    >;
typedef $$BoardCombatTableTableCreateCompanionBuilder =
    BoardCombatTableCompanion Function({
      required String uuid,
      required String boardUuid,
      required String sessionUuid,
      required int turn,
      required int startedAt,
      Value<int?> endAt,
      Value<int> rowid,
    });
typedef $$BoardCombatTableTableUpdateCompanionBuilder =
    BoardCombatTableCompanion Function({
      Value<String> uuid,
      Value<String> boardUuid,
      Value<String> sessionUuid,
      Value<int> turn,
      Value<int> startedAt,
      Value<int?> endAt,
      Value<int> rowid,
    });

class $$BoardCombatTableTableFilterComposer
    extends Composer<_$AppDatabase, $BoardCombatTableTable> {
  $$BoardCombatTableTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get uuid => $composableBuilder(
    column: $table.uuid,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get boardUuid => $composableBuilder(
    column: $table.boardUuid,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get sessionUuid => $composableBuilder(
    column: $table.sessionUuid,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get turn => $composableBuilder(
    column: $table.turn,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get startedAt => $composableBuilder(
    column: $table.startedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get endAt => $composableBuilder(
    column: $table.endAt,
    builder: (column) => ColumnFilters(column),
  );
}

class $$BoardCombatTableTableOrderingComposer
    extends Composer<_$AppDatabase, $BoardCombatTableTable> {
  $$BoardCombatTableTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get uuid => $composableBuilder(
    column: $table.uuid,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get boardUuid => $composableBuilder(
    column: $table.boardUuid,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get sessionUuid => $composableBuilder(
    column: $table.sessionUuid,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get turn => $composableBuilder(
    column: $table.turn,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get startedAt => $composableBuilder(
    column: $table.startedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get endAt => $composableBuilder(
    column: $table.endAt,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$BoardCombatTableTableAnnotationComposer
    extends Composer<_$AppDatabase, $BoardCombatTableTable> {
  $$BoardCombatTableTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get uuid =>
      $composableBuilder(column: $table.uuid, builder: (column) => column);

  GeneratedColumn<String> get boardUuid =>
      $composableBuilder(column: $table.boardUuid, builder: (column) => column);

  GeneratedColumn<String> get sessionUuid => $composableBuilder(
    column: $table.sessionUuid,
    builder: (column) => column,
  );

  GeneratedColumn<int> get turn =>
      $composableBuilder(column: $table.turn, builder: (column) => column);

  GeneratedColumn<int> get startedAt =>
      $composableBuilder(column: $table.startedAt, builder: (column) => column);

  GeneratedColumn<int> get endAt =>
      $composableBuilder(column: $table.endAt, builder: (column) => column);
}

class $$BoardCombatTableTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $BoardCombatTableTable,
          BoardCombatTableData,
          $$BoardCombatTableTableFilterComposer,
          $$BoardCombatTableTableOrderingComposer,
          $$BoardCombatTableTableAnnotationComposer,
          $$BoardCombatTableTableCreateCompanionBuilder,
          $$BoardCombatTableTableUpdateCompanionBuilder,
          (
            BoardCombatTableData,
            BaseReferences<
              _$AppDatabase,
              $BoardCombatTableTable,
              BoardCombatTableData
            >,
          ),
          BoardCombatTableData,
          PrefetchHooks Function()
        > {
  $$BoardCombatTableTableTableManager(
    _$AppDatabase db,
    $BoardCombatTableTable table,
  ) : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$BoardCombatTableTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$BoardCombatTableTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$BoardCombatTableTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> uuid = const Value.absent(),
                Value<String> boardUuid = const Value.absent(),
                Value<String> sessionUuid = const Value.absent(),
                Value<int> turn = const Value.absent(),
                Value<int> startedAt = const Value.absent(),
                Value<int?> endAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => BoardCombatTableCompanion(
                uuid: uuid,
                boardUuid: boardUuid,
                sessionUuid: sessionUuid,
                turn: turn,
                startedAt: startedAt,
                endAt: endAt,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String uuid,
                required String boardUuid,
                required String sessionUuid,
                required int turn,
                required int startedAt,
                Value<int?> endAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => BoardCombatTableCompanion.insert(
                uuid: uuid,
                boardUuid: boardUuid,
                sessionUuid: sessionUuid,
                turn: turn,
                startedAt: startedAt,
                endAt: endAt,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ),
      );
}

typedef $$BoardCombatTableTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $BoardCombatTableTable,
      BoardCombatTableData,
      $$BoardCombatTableTableFilterComposer,
      $$BoardCombatTableTableOrderingComposer,
      $$BoardCombatTableTableAnnotationComposer,
      $$BoardCombatTableTableCreateCompanionBuilder,
      $$BoardCombatTableTableUpdateCompanionBuilder,
      (
        BoardCombatTableData,
        BaseReferences<
          _$AppDatabase,
          $BoardCombatTableTable,
          BoardCombatTableData
        >,
      ),
      BoardCombatTableData,
      PrefetchHooks Function()
    >;
typedef $$MenaceTableTableCreateCompanionBuilder =
    MenaceTableCompanion Function({
      required String uuid,
      required String name,
      Value<String?> imagePath,
      Value<String?> imageAsset,
      Value<String?> displacement,
      Value<String?> casterInfos,
      Value<String?> desc,
      Value<String?> extraInfos,
      Value<String?> senses,
      required String nd,
      Value<int?> divinityId,
      required int initiative,
      required int perception,
      required int defense,
      required int life,
      required int mana,
      required int fortResistence,
      required int refResistence,
      required int vonResistence,
      required int strength,
      required int dexterity,
      required int constitution,
      required int intelligence,
      required int wisdom,
      required int charisma,
      required int typeIndex,
      required int creatureSizeIndex,
      required int combateRoleIndex,
      Value<int?> treasureTypeIndex,
      required int createdAt,
      required int updatedAt,
      Value<int> rowid,
    });
typedef $$MenaceTableTableUpdateCompanionBuilder =
    MenaceTableCompanion Function({
      Value<String> uuid,
      Value<String> name,
      Value<String?> imagePath,
      Value<String?> imageAsset,
      Value<String?> displacement,
      Value<String?> casterInfos,
      Value<String?> desc,
      Value<String?> extraInfos,
      Value<String?> senses,
      Value<String> nd,
      Value<int?> divinityId,
      Value<int> initiative,
      Value<int> perception,
      Value<int> defense,
      Value<int> life,
      Value<int> mana,
      Value<int> fortResistence,
      Value<int> refResistence,
      Value<int> vonResistence,
      Value<int> strength,
      Value<int> dexterity,
      Value<int> constitution,
      Value<int> intelligence,
      Value<int> wisdom,
      Value<int> charisma,
      Value<int> typeIndex,
      Value<int> creatureSizeIndex,
      Value<int> combateRoleIndex,
      Value<int?> treasureTypeIndex,
      Value<int> createdAt,
      Value<int> updatedAt,
      Value<int> rowid,
    });

class $$MenaceTableTableFilterComposer
    extends Composer<_$AppDatabase, $MenaceTableTable> {
  $$MenaceTableTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get uuid => $composableBuilder(
    column: $table.uuid,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get imagePath => $composableBuilder(
    column: $table.imagePath,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get imageAsset => $composableBuilder(
    column: $table.imageAsset,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get displacement => $composableBuilder(
    column: $table.displacement,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get casterInfos => $composableBuilder(
    column: $table.casterInfos,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get desc => $composableBuilder(
    column: $table.desc,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get extraInfos => $composableBuilder(
    column: $table.extraInfos,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get senses => $composableBuilder(
    column: $table.senses,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get nd => $composableBuilder(
    column: $table.nd,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get divinityId => $composableBuilder(
    column: $table.divinityId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get initiative => $composableBuilder(
    column: $table.initiative,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get perception => $composableBuilder(
    column: $table.perception,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get defense => $composableBuilder(
    column: $table.defense,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get life => $composableBuilder(
    column: $table.life,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get mana => $composableBuilder(
    column: $table.mana,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get fortResistence => $composableBuilder(
    column: $table.fortResistence,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get refResistence => $composableBuilder(
    column: $table.refResistence,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get vonResistence => $composableBuilder(
    column: $table.vonResistence,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get strength => $composableBuilder(
    column: $table.strength,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get dexterity => $composableBuilder(
    column: $table.dexterity,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get constitution => $composableBuilder(
    column: $table.constitution,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get intelligence => $composableBuilder(
    column: $table.intelligence,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get wisdom => $composableBuilder(
    column: $table.wisdom,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get charisma => $composableBuilder(
    column: $table.charisma,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get typeIndex => $composableBuilder(
    column: $table.typeIndex,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get creatureSizeIndex => $composableBuilder(
    column: $table.creatureSizeIndex,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get combateRoleIndex => $composableBuilder(
    column: $table.combateRoleIndex,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get treasureTypeIndex => $composableBuilder(
    column: $table.treasureTypeIndex,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnFilters(column),
  );
}

class $$MenaceTableTableOrderingComposer
    extends Composer<_$AppDatabase, $MenaceTableTable> {
  $$MenaceTableTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get uuid => $composableBuilder(
    column: $table.uuid,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get imagePath => $composableBuilder(
    column: $table.imagePath,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get imageAsset => $composableBuilder(
    column: $table.imageAsset,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get displacement => $composableBuilder(
    column: $table.displacement,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get casterInfos => $composableBuilder(
    column: $table.casterInfos,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get desc => $composableBuilder(
    column: $table.desc,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get extraInfos => $composableBuilder(
    column: $table.extraInfos,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get senses => $composableBuilder(
    column: $table.senses,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get nd => $composableBuilder(
    column: $table.nd,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get divinityId => $composableBuilder(
    column: $table.divinityId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get initiative => $composableBuilder(
    column: $table.initiative,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get perception => $composableBuilder(
    column: $table.perception,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get defense => $composableBuilder(
    column: $table.defense,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get life => $composableBuilder(
    column: $table.life,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get mana => $composableBuilder(
    column: $table.mana,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get fortResistence => $composableBuilder(
    column: $table.fortResistence,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get refResistence => $composableBuilder(
    column: $table.refResistence,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get vonResistence => $composableBuilder(
    column: $table.vonResistence,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get strength => $composableBuilder(
    column: $table.strength,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get dexterity => $composableBuilder(
    column: $table.dexterity,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get constitution => $composableBuilder(
    column: $table.constitution,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get intelligence => $composableBuilder(
    column: $table.intelligence,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get wisdom => $composableBuilder(
    column: $table.wisdom,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get charisma => $composableBuilder(
    column: $table.charisma,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get typeIndex => $composableBuilder(
    column: $table.typeIndex,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get creatureSizeIndex => $composableBuilder(
    column: $table.creatureSizeIndex,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get combateRoleIndex => $composableBuilder(
    column: $table.combateRoleIndex,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get treasureTypeIndex => $composableBuilder(
    column: $table.treasureTypeIndex,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$MenaceTableTableAnnotationComposer
    extends Composer<_$AppDatabase, $MenaceTableTable> {
  $$MenaceTableTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get uuid =>
      $composableBuilder(column: $table.uuid, builder: (column) => column);

  GeneratedColumn<String> get name =>
      $composableBuilder(column: $table.name, builder: (column) => column);

  GeneratedColumn<String> get imagePath =>
      $composableBuilder(column: $table.imagePath, builder: (column) => column);

  GeneratedColumn<String> get imageAsset => $composableBuilder(
    column: $table.imageAsset,
    builder: (column) => column,
  );

  GeneratedColumn<String> get displacement => $composableBuilder(
    column: $table.displacement,
    builder: (column) => column,
  );

  GeneratedColumn<String> get casterInfos => $composableBuilder(
    column: $table.casterInfos,
    builder: (column) => column,
  );

  GeneratedColumn<String> get desc =>
      $composableBuilder(column: $table.desc, builder: (column) => column);

  GeneratedColumn<String> get extraInfos => $composableBuilder(
    column: $table.extraInfos,
    builder: (column) => column,
  );

  GeneratedColumn<String> get senses =>
      $composableBuilder(column: $table.senses, builder: (column) => column);

  GeneratedColumn<String> get nd =>
      $composableBuilder(column: $table.nd, builder: (column) => column);

  GeneratedColumn<int> get divinityId => $composableBuilder(
    column: $table.divinityId,
    builder: (column) => column,
  );

  GeneratedColumn<int> get initiative => $composableBuilder(
    column: $table.initiative,
    builder: (column) => column,
  );

  GeneratedColumn<int> get perception => $composableBuilder(
    column: $table.perception,
    builder: (column) => column,
  );

  GeneratedColumn<int> get defense =>
      $composableBuilder(column: $table.defense, builder: (column) => column);

  GeneratedColumn<int> get life =>
      $composableBuilder(column: $table.life, builder: (column) => column);

  GeneratedColumn<int> get mana =>
      $composableBuilder(column: $table.mana, builder: (column) => column);

  GeneratedColumn<int> get fortResistence => $composableBuilder(
    column: $table.fortResistence,
    builder: (column) => column,
  );

  GeneratedColumn<int> get refResistence => $composableBuilder(
    column: $table.refResistence,
    builder: (column) => column,
  );

  GeneratedColumn<int> get vonResistence => $composableBuilder(
    column: $table.vonResistence,
    builder: (column) => column,
  );

  GeneratedColumn<int> get strength =>
      $composableBuilder(column: $table.strength, builder: (column) => column);

  GeneratedColumn<int> get dexterity =>
      $composableBuilder(column: $table.dexterity, builder: (column) => column);

  GeneratedColumn<int> get constitution => $composableBuilder(
    column: $table.constitution,
    builder: (column) => column,
  );

  GeneratedColumn<int> get intelligence => $composableBuilder(
    column: $table.intelligence,
    builder: (column) => column,
  );

  GeneratedColumn<int> get wisdom =>
      $composableBuilder(column: $table.wisdom, builder: (column) => column);

  GeneratedColumn<int> get charisma =>
      $composableBuilder(column: $table.charisma, builder: (column) => column);

  GeneratedColumn<int> get typeIndex =>
      $composableBuilder(column: $table.typeIndex, builder: (column) => column);

  GeneratedColumn<int> get creatureSizeIndex => $composableBuilder(
    column: $table.creatureSizeIndex,
    builder: (column) => column,
  );

  GeneratedColumn<int> get combateRoleIndex => $composableBuilder(
    column: $table.combateRoleIndex,
    builder: (column) => column,
  );

  GeneratedColumn<int> get treasureTypeIndex => $composableBuilder(
    column: $table.treasureTypeIndex,
    builder: (column) => column,
  );

  GeneratedColumn<int> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<int> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);
}

class $$MenaceTableTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $MenaceTableTable,
          MenaceTableData,
          $$MenaceTableTableFilterComposer,
          $$MenaceTableTableOrderingComposer,
          $$MenaceTableTableAnnotationComposer,
          $$MenaceTableTableCreateCompanionBuilder,
          $$MenaceTableTableUpdateCompanionBuilder,
          (
            MenaceTableData,
            BaseReferences<_$AppDatabase, $MenaceTableTable, MenaceTableData>,
          ),
          MenaceTableData,
          PrefetchHooks Function()
        > {
  $$MenaceTableTableTableManager(_$AppDatabase db, $MenaceTableTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$MenaceTableTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$MenaceTableTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$MenaceTableTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> uuid = const Value.absent(),
                Value<String> name = const Value.absent(),
                Value<String?> imagePath = const Value.absent(),
                Value<String?> imageAsset = const Value.absent(),
                Value<String?> displacement = const Value.absent(),
                Value<String?> casterInfos = const Value.absent(),
                Value<String?> desc = const Value.absent(),
                Value<String?> extraInfos = const Value.absent(),
                Value<String?> senses = const Value.absent(),
                Value<String> nd = const Value.absent(),
                Value<int?> divinityId = const Value.absent(),
                Value<int> initiative = const Value.absent(),
                Value<int> perception = const Value.absent(),
                Value<int> defense = const Value.absent(),
                Value<int> life = const Value.absent(),
                Value<int> mana = const Value.absent(),
                Value<int> fortResistence = const Value.absent(),
                Value<int> refResistence = const Value.absent(),
                Value<int> vonResistence = const Value.absent(),
                Value<int> strength = const Value.absent(),
                Value<int> dexterity = const Value.absent(),
                Value<int> constitution = const Value.absent(),
                Value<int> intelligence = const Value.absent(),
                Value<int> wisdom = const Value.absent(),
                Value<int> charisma = const Value.absent(),
                Value<int> typeIndex = const Value.absent(),
                Value<int> creatureSizeIndex = const Value.absent(),
                Value<int> combateRoleIndex = const Value.absent(),
                Value<int?> treasureTypeIndex = const Value.absent(),
                Value<int> createdAt = const Value.absent(),
                Value<int> updatedAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => MenaceTableCompanion(
                uuid: uuid,
                name: name,
                imagePath: imagePath,
                imageAsset: imageAsset,
                displacement: displacement,
                casterInfos: casterInfos,
                desc: desc,
                extraInfos: extraInfos,
                senses: senses,
                nd: nd,
                divinityId: divinityId,
                initiative: initiative,
                perception: perception,
                defense: defense,
                life: life,
                mana: mana,
                fortResistence: fortResistence,
                refResistence: refResistence,
                vonResistence: vonResistence,
                strength: strength,
                dexterity: dexterity,
                constitution: constitution,
                intelligence: intelligence,
                wisdom: wisdom,
                charisma: charisma,
                typeIndex: typeIndex,
                creatureSizeIndex: creatureSizeIndex,
                combateRoleIndex: combateRoleIndex,
                treasureTypeIndex: treasureTypeIndex,
                createdAt: createdAt,
                updatedAt: updatedAt,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String uuid,
                required String name,
                Value<String?> imagePath = const Value.absent(),
                Value<String?> imageAsset = const Value.absent(),
                Value<String?> displacement = const Value.absent(),
                Value<String?> casterInfos = const Value.absent(),
                Value<String?> desc = const Value.absent(),
                Value<String?> extraInfos = const Value.absent(),
                Value<String?> senses = const Value.absent(),
                required String nd,
                Value<int?> divinityId = const Value.absent(),
                required int initiative,
                required int perception,
                required int defense,
                required int life,
                required int mana,
                required int fortResistence,
                required int refResistence,
                required int vonResistence,
                required int strength,
                required int dexterity,
                required int constitution,
                required int intelligence,
                required int wisdom,
                required int charisma,
                required int typeIndex,
                required int creatureSizeIndex,
                required int combateRoleIndex,
                Value<int?> treasureTypeIndex = const Value.absent(),
                required int createdAt,
                required int updatedAt,
                Value<int> rowid = const Value.absent(),
              }) => MenaceTableCompanion.insert(
                uuid: uuid,
                name: name,
                imagePath: imagePath,
                imageAsset: imageAsset,
                displacement: displacement,
                casterInfos: casterInfos,
                desc: desc,
                extraInfos: extraInfos,
                senses: senses,
                nd: nd,
                divinityId: divinityId,
                initiative: initiative,
                perception: perception,
                defense: defense,
                life: life,
                mana: mana,
                fortResistence: fortResistence,
                refResistence: refResistence,
                vonResistence: vonResistence,
                strength: strength,
                dexterity: dexterity,
                constitution: constitution,
                intelligence: intelligence,
                wisdom: wisdom,
                charisma: charisma,
                typeIndex: typeIndex,
                creatureSizeIndex: creatureSizeIndex,
                combateRoleIndex: combateRoleIndex,
                treasureTypeIndex: treasureTypeIndex,
                createdAt: createdAt,
                updatedAt: updatedAt,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ),
      );
}

typedef $$MenaceTableTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $MenaceTableTable,
      MenaceTableData,
      $$MenaceTableTableFilterComposer,
      $$MenaceTableTableOrderingComposer,
      $$MenaceTableTableAnnotationComposer,
      $$MenaceTableTableCreateCompanionBuilder,
      $$MenaceTableTableUpdateCompanionBuilder,
      (
        MenaceTableData,
        BaseReferences<_$AppDatabase, $MenaceTableTable, MenaceTableData>,
      ),
      MenaceTableData,
      PrefetchHooks Function()
    >;
typedef $$AdventureBackpackTableTableCreateCompanionBuilder =
    AdventureBackpackTableCompanion Function({
      required String uuid,
      required String name,
      required String parentUuid,
      Value<String?> suffix,
      Value<double?> price,
      required int createdAt,
      required int updatedAt,
      Value<int> rowid,
    });
typedef $$AdventureBackpackTableTableUpdateCompanionBuilder =
    AdventureBackpackTableCompanion Function({
      Value<String> uuid,
      Value<String> name,
      Value<String> parentUuid,
      Value<String?> suffix,
      Value<double?> price,
      Value<int> createdAt,
      Value<int> updatedAt,
      Value<int> rowid,
    });

class $$AdventureBackpackTableTableFilterComposer
    extends Composer<_$AppDatabase, $AdventureBackpackTableTable> {
  $$AdventureBackpackTableTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get uuid => $composableBuilder(
    column: $table.uuid,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get parentUuid => $composableBuilder(
    column: $table.parentUuid,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get suffix => $composableBuilder(
    column: $table.suffix,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get price => $composableBuilder(
    column: $table.price,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnFilters(column),
  );
}

class $$AdventureBackpackTableTableOrderingComposer
    extends Composer<_$AppDatabase, $AdventureBackpackTableTable> {
  $$AdventureBackpackTableTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get uuid => $composableBuilder(
    column: $table.uuid,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get parentUuid => $composableBuilder(
    column: $table.parentUuid,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get suffix => $composableBuilder(
    column: $table.suffix,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get price => $composableBuilder(
    column: $table.price,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$AdventureBackpackTableTableAnnotationComposer
    extends Composer<_$AppDatabase, $AdventureBackpackTableTable> {
  $$AdventureBackpackTableTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get uuid =>
      $composableBuilder(column: $table.uuid, builder: (column) => column);

  GeneratedColumn<String> get name =>
      $composableBuilder(column: $table.name, builder: (column) => column);

  GeneratedColumn<String> get parentUuid => $composableBuilder(
    column: $table.parentUuid,
    builder: (column) => column,
  );

  GeneratedColumn<String> get suffix =>
      $composableBuilder(column: $table.suffix, builder: (column) => column);

  GeneratedColumn<double> get price =>
      $composableBuilder(column: $table.price, builder: (column) => column);

  GeneratedColumn<int> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<int> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);
}

class $$AdventureBackpackTableTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $AdventureBackpackTableTable,
          AdventureBackpackTableData,
          $$AdventureBackpackTableTableFilterComposer,
          $$AdventureBackpackTableTableOrderingComposer,
          $$AdventureBackpackTableTableAnnotationComposer,
          $$AdventureBackpackTableTableCreateCompanionBuilder,
          $$AdventureBackpackTableTableUpdateCompanionBuilder,
          (
            AdventureBackpackTableData,
            BaseReferences<
              _$AppDatabase,
              $AdventureBackpackTableTable,
              AdventureBackpackTableData
            >,
          ),
          AdventureBackpackTableData,
          PrefetchHooks Function()
        > {
  $$AdventureBackpackTableTableTableManager(
    _$AppDatabase db,
    $AdventureBackpackTableTable table,
  ) : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$AdventureBackpackTableTableFilterComposer(
                $db: db,
                $table: table,
              ),
          createOrderingComposer: () =>
              $$AdventureBackpackTableTableOrderingComposer(
                $db: db,
                $table: table,
              ),
          createComputedFieldComposer: () =>
              $$AdventureBackpackTableTableAnnotationComposer(
                $db: db,
                $table: table,
              ),
          updateCompanionCallback:
              ({
                Value<String> uuid = const Value.absent(),
                Value<String> name = const Value.absent(),
                Value<String> parentUuid = const Value.absent(),
                Value<String?> suffix = const Value.absent(),
                Value<double?> price = const Value.absent(),
                Value<int> createdAt = const Value.absent(),
                Value<int> updatedAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => AdventureBackpackTableCompanion(
                uuid: uuid,
                name: name,
                parentUuid: parentUuid,
                suffix: suffix,
                price: price,
                createdAt: createdAt,
                updatedAt: updatedAt,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String uuid,
                required String name,
                required String parentUuid,
                Value<String?> suffix = const Value.absent(),
                Value<double?> price = const Value.absent(),
                required int createdAt,
                required int updatedAt,
                Value<int> rowid = const Value.absent(),
              }) => AdventureBackpackTableCompanion.insert(
                uuid: uuid,
                name: name,
                parentUuid: parentUuid,
                suffix: suffix,
                price: price,
                createdAt: createdAt,
                updatedAt: updatedAt,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ),
      );
}

typedef $$AdventureBackpackTableTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $AdventureBackpackTableTable,
      AdventureBackpackTableData,
      $$AdventureBackpackTableTableFilterComposer,
      $$AdventureBackpackTableTableOrderingComposer,
      $$AdventureBackpackTableTableAnnotationComposer,
      $$AdventureBackpackTableTableCreateCompanionBuilder,
      $$AdventureBackpackTableTableUpdateCompanionBuilder,
      (
        AdventureBackpackTableData,
        BaseReferences<
          _$AppDatabase,
          $AdventureBackpackTableTable,
          AdventureBackpackTableData
        >,
      ),
      AdventureBackpackTableData,
      PrefetchHooks Function()
    >;
typedef $$EquipmentTableTableCreateCompanionBuilder =
    EquipmentTableCompanion Function({
      required String uuid,
      required String name,
      required String parentUuid,
      Value<String?> storedIn,
      Value<String?> improvements,
      Value<int?> specialMaterialIndex,
      required int createdAt,
      required int updatedAt,
      Value<int> rowid,
    });
typedef $$EquipmentTableTableUpdateCompanionBuilder =
    EquipmentTableCompanion Function({
      Value<String> uuid,
      Value<String> name,
      Value<String> parentUuid,
      Value<String?> storedIn,
      Value<String?> improvements,
      Value<int?> specialMaterialIndex,
      Value<int> createdAt,
      Value<int> updatedAt,
      Value<int> rowid,
    });

class $$EquipmentTableTableFilterComposer
    extends Composer<_$AppDatabase, $EquipmentTableTable> {
  $$EquipmentTableTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get uuid => $composableBuilder(
    column: $table.uuid,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get parentUuid => $composableBuilder(
    column: $table.parentUuid,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get storedIn => $composableBuilder(
    column: $table.storedIn,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get improvements => $composableBuilder(
    column: $table.improvements,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get specialMaterialIndex => $composableBuilder(
    column: $table.specialMaterialIndex,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnFilters(column),
  );
}

class $$EquipmentTableTableOrderingComposer
    extends Composer<_$AppDatabase, $EquipmentTableTable> {
  $$EquipmentTableTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get uuid => $composableBuilder(
    column: $table.uuid,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get parentUuid => $composableBuilder(
    column: $table.parentUuid,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get storedIn => $composableBuilder(
    column: $table.storedIn,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get improvements => $composableBuilder(
    column: $table.improvements,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get specialMaterialIndex => $composableBuilder(
    column: $table.specialMaterialIndex,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$EquipmentTableTableAnnotationComposer
    extends Composer<_$AppDatabase, $EquipmentTableTable> {
  $$EquipmentTableTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get uuid =>
      $composableBuilder(column: $table.uuid, builder: (column) => column);

  GeneratedColumn<String> get name =>
      $composableBuilder(column: $table.name, builder: (column) => column);

  GeneratedColumn<String> get parentUuid => $composableBuilder(
    column: $table.parentUuid,
    builder: (column) => column,
  );

  GeneratedColumn<String> get storedIn =>
      $composableBuilder(column: $table.storedIn, builder: (column) => column);

  GeneratedColumn<String> get improvements => $composableBuilder(
    column: $table.improvements,
    builder: (column) => column,
  );

  GeneratedColumn<int> get specialMaterialIndex => $composableBuilder(
    column: $table.specialMaterialIndex,
    builder: (column) => column,
  );

  GeneratedColumn<int> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<int> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);
}

class $$EquipmentTableTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $EquipmentTableTable,
          EquipmentTableData,
          $$EquipmentTableTableFilterComposer,
          $$EquipmentTableTableOrderingComposer,
          $$EquipmentTableTableAnnotationComposer,
          $$EquipmentTableTableCreateCompanionBuilder,
          $$EquipmentTableTableUpdateCompanionBuilder,
          (
            EquipmentTableData,
            BaseReferences<
              _$AppDatabase,
              $EquipmentTableTable,
              EquipmentTableData
            >,
          ),
          EquipmentTableData,
          PrefetchHooks Function()
        > {
  $$EquipmentTableTableTableManager(
    _$AppDatabase db,
    $EquipmentTableTable table,
  ) : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$EquipmentTableTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$EquipmentTableTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$EquipmentTableTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> uuid = const Value.absent(),
                Value<String> name = const Value.absent(),
                Value<String> parentUuid = const Value.absent(),
                Value<String?> storedIn = const Value.absent(),
                Value<String?> improvements = const Value.absent(),
                Value<int?> specialMaterialIndex = const Value.absent(),
                Value<int> createdAt = const Value.absent(),
                Value<int> updatedAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => EquipmentTableCompanion(
                uuid: uuid,
                name: name,
                parentUuid: parentUuid,
                storedIn: storedIn,
                improvements: improvements,
                specialMaterialIndex: specialMaterialIndex,
                createdAt: createdAt,
                updatedAt: updatedAt,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String uuid,
                required String name,
                required String parentUuid,
                Value<String?> storedIn = const Value.absent(),
                Value<String?> improvements = const Value.absent(),
                Value<int?> specialMaterialIndex = const Value.absent(),
                required int createdAt,
                required int updatedAt,
                Value<int> rowid = const Value.absent(),
              }) => EquipmentTableCompanion.insert(
                uuid: uuid,
                name: name,
                parentUuid: parentUuid,
                storedIn: storedIn,
                improvements: improvements,
                specialMaterialIndex: specialMaterialIndex,
                createdAt: createdAt,
                updatedAt: updatedAt,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ),
      );
}

typedef $$EquipmentTableTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $EquipmentTableTable,
      EquipmentTableData,
      $$EquipmentTableTableFilterComposer,
      $$EquipmentTableTableOrderingComposer,
      $$EquipmentTableTableAnnotationComposer,
      $$EquipmentTableTableCreateCompanionBuilder,
      $$EquipmentTableTableUpdateCompanionBuilder,
      (
        EquipmentTableData,
        BaseReferences<_$AppDatabase, $EquipmentTableTable, EquipmentTableData>,
      ),
      EquipmentTableData,
      PrefetchHooks Function()
    >;
typedef $$AmmunitionTableTableCreateCompanionBuilder =
    AmmunitionTableCompanion Function({
      required String uuid,
      required String name,
      required String parentUuid,
      required int quantity,
      Value<String?> storedIn,
      Value<double?> price,
      Value<String?> desc,
      Value<String?> improvements,
      Value<int?> specialMaterialIndex,
      required int createdAt,
      required int updatedAt,
      Value<int> rowid,
    });
typedef $$AmmunitionTableTableUpdateCompanionBuilder =
    AmmunitionTableCompanion Function({
      Value<String> uuid,
      Value<String> name,
      Value<String> parentUuid,
      Value<int> quantity,
      Value<String?> storedIn,
      Value<double?> price,
      Value<String?> desc,
      Value<String?> improvements,
      Value<int?> specialMaterialIndex,
      Value<int> createdAt,
      Value<int> updatedAt,
      Value<int> rowid,
    });

class $$AmmunitionTableTableFilterComposer
    extends Composer<_$AppDatabase, $AmmunitionTableTable> {
  $$AmmunitionTableTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get uuid => $composableBuilder(
    column: $table.uuid,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get parentUuid => $composableBuilder(
    column: $table.parentUuid,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get quantity => $composableBuilder(
    column: $table.quantity,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get storedIn => $composableBuilder(
    column: $table.storedIn,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get price => $composableBuilder(
    column: $table.price,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get desc => $composableBuilder(
    column: $table.desc,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get improvements => $composableBuilder(
    column: $table.improvements,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get specialMaterialIndex => $composableBuilder(
    column: $table.specialMaterialIndex,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnFilters(column),
  );
}

class $$AmmunitionTableTableOrderingComposer
    extends Composer<_$AppDatabase, $AmmunitionTableTable> {
  $$AmmunitionTableTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get uuid => $composableBuilder(
    column: $table.uuid,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get parentUuid => $composableBuilder(
    column: $table.parentUuid,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get quantity => $composableBuilder(
    column: $table.quantity,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get storedIn => $composableBuilder(
    column: $table.storedIn,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get price => $composableBuilder(
    column: $table.price,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get desc => $composableBuilder(
    column: $table.desc,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get improvements => $composableBuilder(
    column: $table.improvements,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get specialMaterialIndex => $composableBuilder(
    column: $table.specialMaterialIndex,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$AmmunitionTableTableAnnotationComposer
    extends Composer<_$AppDatabase, $AmmunitionTableTable> {
  $$AmmunitionTableTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get uuid =>
      $composableBuilder(column: $table.uuid, builder: (column) => column);

  GeneratedColumn<String> get name =>
      $composableBuilder(column: $table.name, builder: (column) => column);

  GeneratedColumn<String> get parentUuid => $composableBuilder(
    column: $table.parentUuid,
    builder: (column) => column,
  );

  GeneratedColumn<int> get quantity =>
      $composableBuilder(column: $table.quantity, builder: (column) => column);

  GeneratedColumn<String> get storedIn =>
      $composableBuilder(column: $table.storedIn, builder: (column) => column);

  GeneratedColumn<double> get price =>
      $composableBuilder(column: $table.price, builder: (column) => column);

  GeneratedColumn<String> get desc =>
      $composableBuilder(column: $table.desc, builder: (column) => column);

  GeneratedColumn<String> get improvements => $composableBuilder(
    column: $table.improvements,
    builder: (column) => column,
  );

  GeneratedColumn<int> get specialMaterialIndex => $composableBuilder(
    column: $table.specialMaterialIndex,
    builder: (column) => column,
  );

  GeneratedColumn<int> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<int> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);
}

class $$AmmunitionTableTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $AmmunitionTableTable,
          AmmunitionTableData,
          $$AmmunitionTableTableFilterComposer,
          $$AmmunitionTableTableOrderingComposer,
          $$AmmunitionTableTableAnnotationComposer,
          $$AmmunitionTableTableCreateCompanionBuilder,
          $$AmmunitionTableTableUpdateCompanionBuilder,
          (
            AmmunitionTableData,
            BaseReferences<
              _$AppDatabase,
              $AmmunitionTableTable,
              AmmunitionTableData
            >,
          ),
          AmmunitionTableData,
          PrefetchHooks Function()
        > {
  $$AmmunitionTableTableTableManager(
    _$AppDatabase db,
    $AmmunitionTableTable table,
  ) : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$AmmunitionTableTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$AmmunitionTableTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$AmmunitionTableTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> uuid = const Value.absent(),
                Value<String> name = const Value.absent(),
                Value<String> parentUuid = const Value.absent(),
                Value<int> quantity = const Value.absent(),
                Value<String?> storedIn = const Value.absent(),
                Value<double?> price = const Value.absent(),
                Value<String?> desc = const Value.absent(),
                Value<String?> improvements = const Value.absent(),
                Value<int?> specialMaterialIndex = const Value.absent(),
                Value<int> createdAt = const Value.absent(),
                Value<int> updatedAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => AmmunitionTableCompanion(
                uuid: uuid,
                name: name,
                parentUuid: parentUuid,
                quantity: quantity,
                storedIn: storedIn,
                price: price,
                desc: desc,
                improvements: improvements,
                specialMaterialIndex: specialMaterialIndex,
                createdAt: createdAt,
                updatedAt: updatedAt,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String uuid,
                required String name,
                required String parentUuid,
                required int quantity,
                Value<String?> storedIn = const Value.absent(),
                Value<double?> price = const Value.absent(),
                Value<String?> desc = const Value.absent(),
                Value<String?> improvements = const Value.absent(),
                Value<int?> specialMaterialIndex = const Value.absent(),
                required int createdAt,
                required int updatedAt,
                Value<int> rowid = const Value.absent(),
              }) => AmmunitionTableCompanion.insert(
                uuid: uuid,
                name: name,
                parentUuid: parentUuid,
                quantity: quantity,
                storedIn: storedIn,
                price: price,
                desc: desc,
                improvements: improvements,
                specialMaterialIndex: specialMaterialIndex,
                createdAt: createdAt,
                updatedAt: updatedAt,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ),
      );
}

typedef $$AmmunitionTableTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $AmmunitionTableTable,
      AmmunitionTableData,
      $$AmmunitionTableTableFilterComposer,
      $$AmmunitionTableTableOrderingComposer,
      $$AmmunitionTableTableAnnotationComposer,
      $$AmmunitionTableTableCreateCompanionBuilder,
      $$AmmunitionTableTableUpdateCompanionBuilder,
      (
        AmmunitionTableData,
        BaseReferences<
          _$AppDatabase,
          $AmmunitionTableTable,
          AmmunitionTableData
        >,
      ),
      AmmunitionTableData,
      PrefetchHooks Function()
    >;
typedef $$ArmorTableTableCreateCompanionBuilder =
    ArmorTableCompanion Function({
      required String uuid,
      required String name,
      required String parentUuid,
      Value<String?> storedIn,
      Value<String?> improvements,
      Value<int?> specialMaterialIndex,
      Value<double?> price,
      Value<String?> desc,
      required double ocupedSpace,
      required int typeIndex,
      required int defenseBonus,
      required int penalty,
      Value<bool> inUse,
      required int createdAt,
      required int updatedAt,
      Value<int> rowid,
    });
typedef $$ArmorTableTableUpdateCompanionBuilder =
    ArmorTableCompanion Function({
      Value<String> uuid,
      Value<String> name,
      Value<String> parentUuid,
      Value<String?> storedIn,
      Value<String?> improvements,
      Value<int?> specialMaterialIndex,
      Value<double?> price,
      Value<String?> desc,
      Value<double> ocupedSpace,
      Value<int> typeIndex,
      Value<int> defenseBonus,
      Value<int> penalty,
      Value<bool> inUse,
      Value<int> createdAt,
      Value<int> updatedAt,
      Value<int> rowid,
    });

class $$ArmorTableTableFilterComposer
    extends Composer<_$AppDatabase, $ArmorTableTable> {
  $$ArmorTableTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get uuid => $composableBuilder(
    column: $table.uuid,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get parentUuid => $composableBuilder(
    column: $table.parentUuid,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get storedIn => $composableBuilder(
    column: $table.storedIn,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get improvements => $composableBuilder(
    column: $table.improvements,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get specialMaterialIndex => $composableBuilder(
    column: $table.specialMaterialIndex,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get price => $composableBuilder(
    column: $table.price,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get desc => $composableBuilder(
    column: $table.desc,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get ocupedSpace => $composableBuilder(
    column: $table.ocupedSpace,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get typeIndex => $composableBuilder(
    column: $table.typeIndex,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get defenseBonus => $composableBuilder(
    column: $table.defenseBonus,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get penalty => $composableBuilder(
    column: $table.penalty,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get inUse => $composableBuilder(
    column: $table.inUse,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnFilters(column),
  );
}

class $$ArmorTableTableOrderingComposer
    extends Composer<_$AppDatabase, $ArmorTableTable> {
  $$ArmorTableTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get uuid => $composableBuilder(
    column: $table.uuid,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get parentUuid => $composableBuilder(
    column: $table.parentUuid,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get storedIn => $composableBuilder(
    column: $table.storedIn,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get improvements => $composableBuilder(
    column: $table.improvements,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get specialMaterialIndex => $composableBuilder(
    column: $table.specialMaterialIndex,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get price => $composableBuilder(
    column: $table.price,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get desc => $composableBuilder(
    column: $table.desc,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get ocupedSpace => $composableBuilder(
    column: $table.ocupedSpace,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get typeIndex => $composableBuilder(
    column: $table.typeIndex,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get defenseBonus => $composableBuilder(
    column: $table.defenseBonus,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get penalty => $composableBuilder(
    column: $table.penalty,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get inUse => $composableBuilder(
    column: $table.inUse,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$ArmorTableTableAnnotationComposer
    extends Composer<_$AppDatabase, $ArmorTableTable> {
  $$ArmorTableTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get uuid =>
      $composableBuilder(column: $table.uuid, builder: (column) => column);

  GeneratedColumn<String> get name =>
      $composableBuilder(column: $table.name, builder: (column) => column);

  GeneratedColumn<String> get parentUuid => $composableBuilder(
    column: $table.parentUuid,
    builder: (column) => column,
  );

  GeneratedColumn<String> get storedIn =>
      $composableBuilder(column: $table.storedIn, builder: (column) => column);

  GeneratedColumn<String> get improvements => $composableBuilder(
    column: $table.improvements,
    builder: (column) => column,
  );

  GeneratedColumn<int> get specialMaterialIndex => $composableBuilder(
    column: $table.specialMaterialIndex,
    builder: (column) => column,
  );

  GeneratedColumn<double> get price =>
      $composableBuilder(column: $table.price, builder: (column) => column);

  GeneratedColumn<String> get desc =>
      $composableBuilder(column: $table.desc, builder: (column) => column);

  GeneratedColumn<double> get ocupedSpace => $composableBuilder(
    column: $table.ocupedSpace,
    builder: (column) => column,
  );

  GeneratedColumn<int> get typeIndex =>
      $composableBuilder(column: $table.typeIndex, builder: (column) => column);

  GeneratedColumn<int> get defenseBonus => $composableBuilder(
    column: $table.defenseBonus,
    builder: (column) => column,
  );

  GeneratedColumn<int> get penalty =>
      $composableBuilder(column: $table.penalty, builder: (column) => column);

  GeneratedColumn<bool> get inUse =>
      $composableBuilder(column: $table.inUse, builder: (column) => column);

  GeneratedColumn<int> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<int> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);
}

class $$ArmorTableTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $ArmorTableTable,
          ArmorTableData,
          $$ArmorTableTableFilterComposer,
          $$ArmorTableTableOrderingComposer,
          $$ArmorTableTableAnnotationComposer,
          $$ArmorTableTableCreateCompanionBuilder,
          $$ArmorTableTableUpdateCompanionBuilder,
          (
            ArmorTableData,
            BaseReferences<_$AppDatabase, $ArmorTableTable, ArmorTableData>,
          ),
          ArmorTableData,
          PrefetchHooks Function()
        > {
  $$ArmorTableTableTableManager(_$AppDatabase db, $ArmorTableTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$ArmorTableTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$ArmorTableTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$ArmorTableTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> uuid = const Value.absent(),
                Value<String> name = const Value.absent(),
                Value<String> parentUuid = const Value.absent(),
                Value<String?> storedIn = const Value.absent(),
                Value<String?> improvements = const Value.absent(),
                Value<int?> specialMaterialIndex = const Value.absent(),
                Value<double?> price = const Value.absent(),
                Value<String?> desc = const Value.absent(),
                Value<double> ocupedSpace = const Value.absent(),
                Value<int> typeIndex = const Value.absent(),
                Value<int> defenseBonus = const Value.absent(),
                Value<int> penalty = const Value.absent(),
                Value<bool> inUse = const Value.absent(),
                Value<int> createdAt = const Value.absent(),
                Value<int> updatedAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => ArmorTableCompanion(
                uuid: uuid,
                name: name,
                parentUuid: parentUuid,
                storedIn: storedIn,
                improvements: improvements,
                specialMaterialIndex: specialMaterialIndex,
                price: price,
                desc: desc,
                ocupedSpace: ocupedSpace,
                typeIndex: typeIndex,
                defenseBonus: defenseBonus,
                penalty: penalty,
                inUse: inUse,
                createdAt: createdAt,
                updatedAt: updatedAt,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String uuid,
                required String name,
                required String parentUuid,
                Value<String?> storedIn = const Value.absent(),
                Value<String?> improvements = const Value.absent(),
                Value<int?> specialMaterialIndex = const Value.absent(),
                Value<double?> price = const Value.absent(),
                Value<String?> desc = const Value.absent(),
                required double ocupedSpace,
                required int typeIndex,
                required int defenseBonus,
                required int penalty,
                Value<bool> inUse = const Value.absent(),
                required int createdAt,
                required int updatedAt,
                Value<int> rowid = const Value.absent(),
              }) => ArmorTableCompanion.insert(
                uuid: uuid,
                name: name,
                parentUuid: parentUuid,
                storedIn: storedIn,
                improvements: improvements,
                specialMaterialIndex: specialMaterialIndex,
                price: price,
                desc: desc,
                ocupedSpace: ocupedSpace,
                typeIndex: typeIndex,
                defenseBonus: defenseBonus,
                penalty: penalty,
                inUse: inUse,
                createdAt: createdAt,
                updatedAt: updatedAt,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ),
      );
}

typedef $$ArmorTableTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $ArmorTableTable,
      ArmorTableData,
      $$ArmorTableTableFilterComposer,
      $$ArmorTableTableOrderingComposer,
      $$ArmorTableTableAnnotationComposer,
      $$ArmorTableTableCreateCompanionBuilder,
      $$ArmorTableTableUpdateCompanionBuilder,
      (
        ArmorTableData,
        BaseReferences<_$AppDatabase, $ArmorTableTable, ArmorTableData>,
      ),
      ArmorTableData,
      PrefetchHooks Function()
    >;
typedef $$BackpackTableTableCreateCompanionBuilder =
    BackpackTableCompanion Function({
      required String uuid,
      required String name,
      required String parentUuid,
      Value<String?> suffix,
      Value<double?> price,
      required int createdAt,
      required int updatedAt,
      Value<int> rowid,
    });
typedef $$BackpackTableTableUpdateCompanionBuilder =
    BackpackTableCompanion Function({
      Value<String> uuid,
      Value<String> name,
      Value<String> parentUuid,
      Value<String?> suffix,
      Value<double?> price,
      Value<int> createdAt,
      Value<int> updatedAt,
      Value<int> rowid,
    });

class $$BackpackTableTableFilterComposer
    extends Composer<_$AppDatabase, $BackpackTableTable> {
  $$BackpackTableTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get uuid => $composableBuilder(
    column: $table.uuid,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get parentUuid => $composableBuilder(
    column: $table.parentUuid,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get suffix => $composableBuilder(
    column: $table.suffix,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get price => $composableBuilder(
    column: $table.price,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnFilters(column),
  );
}

class $$BackpackTableTableOrderingComposer
    extends Composer<_$AppDatabase, $BackpackTableTable> {
  $$BackpackTableTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get uuid => $composableBuilder(
    column: $table.uuid,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get parentUuid => $composableBuilder(
    column: $table.parentUuid,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get suffix => $composableBuilder(
    column: $table.suffix,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get price => $composableBuilder(
    column: $table.price,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$BackpackTableTableAnnotationComposer
    extends Composer<_$AppDatabase, $BackpackTableTable> {
  $$BackpackTableTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get uuid =>
      $composableBuilder(column: $table.uuid, builder: (column) => column);

  GeneratedColumn<String> get name =>
      $composableBuilder(column: $table.name, builder: (column) => column);

  GeneratedColumn<String> get parentUuid => $composableBuilder(
    column: $table.parentUuid,
    builder: (column) => column,
  );

  GeneratedColumn<String> get suffix =>
      $composableBuilder(column: $table.suffix, builder: (column) => column);

  GeneratedColumn<double> get price =>
      $composableBuilder(column: $table.price, builder: (column) => column);

  GeneratedColumn<int> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<int> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);
}

class $$BackpackTableTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $BackpackTableTable,
          BackpackTableData,
          $$BackpackTableTableFilterComposer,
          $$BackpackTableTableOrderingComposer,
          $$BackpackTableTableAnnotationComposer,
          $$BackpackTableTableCreateCompanionBuilder,
          $$BackpackTableTableUpdateCompanionBuilder,
          (
            BackpackTableData,
            BaseReferences<
              _$AppDatabase,
              $BackpackTableTable,
              BackpackTableData
            >,
          ),
          BackpackTableData,
          PrefetchHooks Function()
        > {
  $$BackpackTableTableTableManager(_$AppDatabase db, $BackpackTableTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$BackpackTableTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$BackpackTableTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$BackpackTableTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> uuid = const Value.absent(),
                Value<String> name = const Value.absent(),
                Value<String> parentUuid = const Value.absent(),
                Value<String?> suffix = const Value.absent(),
                Value<double?> price = const Value.absent(),
                Value<int> createdAt = const Value.absent(),
                Value<int> updatedAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => BackpackTableCompanion(
                uuid: uuid,
                name: name,
                parentUuid: parentUuid,
                suffix: suffix,
                price: price,
                createdAt: createdAt,
                updatedAt: updatedAt,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String uuid,
                required String name,
                required String parentUuid,
                Value<String?> suffix = const Value.absent(),
                Value<double?> price = const Value.absent(),
                required int createdAt,
                required int updatedAt,
                Value<int> rowid = const Value.absent(),
              }) => BackpackTableCompanion.insert(
                uuid: uuid,
                name: name,
                parentUuid: parentUuid,
                suffix: suffix,
                price: price,
                createdAt: createdAt,
                updatedAt: updatedAt,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ),
      );
}

typedef $$BackpackTableTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $BackpackTableTable,
      BackpackTableData,
      $$BackpackTableTableFilterComposer,
      $$BackpackTableTableOrderingComposer,
      $$BackpackTableTableAnnotationComposer,
      $$BackpackTableTableCreateCompanionBuilder,
      $$BackpackTableTableUpdateCompanionBuilder,
      (
        BackpackTableData,
        BaseReferences<_$AppDatabase, $BackpackTableTable, BackpackTableData>,
      ),
      BackpackTableData,
      PrefetchHooks Function()
    >;
typedef $$GeneralItemTableTableCreateCompanionBuilder =
    GeneralItemTableCompanion Function({
      required String uuid,
      required String name,
      required String parentUuid,
      Value<String?> storedIn,
      Value<String?> improvements,
      Value<int?> specialMaterialIndex,
      Value<double?> price,
      Value<String?> desc,
      required double ocupedSpace,
      required int typeIndex,
      required int createdAt,
      required int updatedAt,
      Value<int> rowid,
    });
typedef $$GeneralItemTableTableUpdateCompanionBuilder =
    GeneralItemTableCompanion Function({
      Value<String> uuid,
      Value<String> name,
      Value<String> parentUuid,
      Value<String?> storedIn,
      Value<String?> improvements,
      Value<int?> specialMaterialIndex,
      Value<double?> price,
      Value<String?> desc,
      Value<double> ocupedSpace,
      Value<int> typeIndex,
      Value<int> createdAt,
      Value<int> updatedAt,
      Value<int> rowid,
    });

class $$GeneralItemTableTableFilterComposer
    extends Composer<_$AppDatabase, $GeneralItemTableTable> {
  $$GeneralItemTableTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get uuid => $composableBuilder(
    column: $table.uuid,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get parentUuid => $composableBuilder(
    column: $table.parentUuid,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get storedIn => $composableBuilder(
    column: $table.storedIn,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get improvements => $composableBuilder(
    column: $table.improvements,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get specialMaterialIndex => $composableBuilder(
    column: $table.specialMaterialIndex,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get price => $composableBuilder(
    column: $table.price,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get desc => $composableBuilder(
    column: $table.desc,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get ocupedSpace => $composableBuilder(
    column: $table.ocupedSpace,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get typeIndex => $composableBuilder(
    column: $table.typeIndex,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnFilters(column),
  );
}

class $$GeneralItemTableTableOrderingComposer
    extends Composer<_$AppDatabase, $GeneralItemTableTable> {
  $$GeneralItemTableTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get uuid => $composableBuilder(
    column: $table.uuid,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get parentUuid => $composableBuilder(
    column: $table.parentUuid,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get storedIn => $composableBuilder(
    column: $table.storedIn,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get improvements => $composableBuilder(
    column: $table.improvements,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get specialMaterialIndex => $composableBuilder(
    column: $table.specialMaterialIndex,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get price => $composableBuilder(
    column: $table.price,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get desc => $composableBuilder(
    column: $table.desc,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get ocupedSpace => $composableBuilder(
    column: $table.ocupedSpace,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get typeIndex => $composableBuilder(
    column: $table.typeIndex,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$GeneralItemTableTableAnnotationComposer
    extends Composer<_$AppDatabase, $GeneralItemTableTable> {
  $$GeneralItemTableTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get uuid =>
      $composableBuilder(column: $table.uuid, builder: (column) => column);

  GeneratedColumn<String> get name =>
      $composableBuilder(column: $table.name, builder: (column) => column);

  GeneratedColumn<String> get parentUuid => $composableBuilder(
    column: $table.parentUuid,
    builder: (column) => column,
  );

  GeneratedColumn<String> get storedIn =>
      $composableBuilder(column: $table.storedIn, builder: (column) => column);

  GeneratedColumn<String> get improvements => $composableBuilder(
    column: $table.improvements,
    builder: (column) => column,
  );

  GeneratedColumn<int> get specialMaterialIndex => $composableBuilder(
    column: $table.specialMaterialIndex,
    builder: (column) => column,
  );

  GeneratedColumn<double> get price =>
      $composableBuilder(column: $table.price, builder: (column) => column);

  GeneratedColumn<String> get desc =>
      $composableBuilder(column: $table.desc, builder: (column) => column);

  GeneratedColumn<double> get ocupedSpace => $composableBuilder(
    column: $table.ocupedSpace,
    builder: (column) => column,
  );

  GeneratedColumn<int> get typeIndex =>
      $composableBuilder(column: $table.typeIndex, builder: (column) => column);

  GeneratedColumn<int> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<int> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);
}

class $$GeneralItemTableTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $GeneralItemTableTable,
          GeneralItemTableData,
          $$GeneralItemTableTableFilterComposer,
          $$GeneralItemTableTableOrderingComposer,
          $$GeneralItemTableTableAnnotationComposer,
          $$GeneralItemTableTableCreateCompanionBuilder,
          $$GeneralItemTableTableUpdateCompanionBuilder,
          (
            GeneralItemTableData,
            BaseReferences<
              _$AppDatabase,
              $GeneralItemTableTable,
              GeneralItemTableData
            >,
          ),
          GeneralItemTableData,
          PrefetchHooks Function()
        > {
  $$GeneralItemTableTableTableManager(
    _$AppDatabase db,
    $GeneralItemTableTable table,
  ) : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$GeneralItemTableTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$GeneralItemTableTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$GeneralItemTableTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> uuid = const Value.absent(),
                Value<String> name = const Value.absent(),
                Value<String> parentUuid = const Value.absent(),
                Value<String?> storedIn = const Value.absent(),
                Value<String?> improvements = const Value.absent(),
                Value<int?> specialMaterialIndex = const Value.absent(),
                Value<double?> price = const Value.absent(),
                Value<String?> desc = const Value.absent(),
                Value<double> ocupedSpace = const Value.absent(),
                Value<int> typeIndex = const Value.absent(),
                Value<int> createdAt = const Value.absent(),
                Value<int> updatedAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => GeneralItemTableCompanion(
                uuid: uuid,
                name: name,
                parentUuid: parentUuid,
                storedIn: storedIn,
                improvements: improvements,
                specialMaterialIndex: specialMaterialIndex,
                price: price,
                desc: desc,
                ocupedSpace: ocupedSpace,
                typeIndex: typeIndex,
                createdAt: createdAt,
                updatedAt: updatedAt,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String uuid,
                required String name,
                required String parentUuid,
                Value<String?> storedIn = const Value.absent(),
                Value<String?> improvements = const Value.absent(),
                Value<int?> specialMaterialIndex = const Value.absent(),
                Value<double?> price = const Value.absent(),
                Value<String?> desc = const Value.absent(),
                required double ocupedSpace,
                required int typeIndex,
                required int createdAt,
                required int updatedAt,
                Value<int> rowid = const Value.absent(),
              }) => GeneralItemTableCompanion.insert(
                uuid: uuid,
                name: name,
                parentUuid: parentUuid,
                storedIn: storedIn,
                improvements: improvements,
                specialMaterialIndex: specialMaterialIndex,
                price: price,
                desc: desc,
                ocupedSpace: ocupedSpace,
                typeIndex: typeIndex,
                createdAt: createdAt,
                updatedAt: updatedAt,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ),
      );
}

typedef $$GeneralItemTableTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $GeneralItemTableTable,
      GeneralItemTableData,
      $$GeneralItemTableTableFilterComposer,
      $$GeneralItemTableTableOrderingComposer,
      $$GeneralItemTableTableAnnotationComposer,
      $$GeneralItemTableTableCreateCompanionBuilder,
      $$GeneralItemTableTableUpdateCompanionBuilder,
      (
        GeneralItemTableData,
        BaseReferences<
          _$AppDatabase,
          $GeneralItemTableTable,
          GeneralItemTableData
        >,
      ),
      GeneralItemTableData,
      PrefetchHooks Function()
    >;
typedef $$GeneralSkillTableTableCreateCompanionBuilder =
    GeneralSkillTableCompanion Function({
      required String uuid,
      required String name,
      required String desc,
      required String parentUuid,
      required int createdAt,
      required int updatedAt,
      Value<int> rowid,
    });
typedef $$GeneralSkillTableTableUpdateCompanionBuilder =
    GeneralSkillTableCompanion Function({
      Value<String> uuid,
      Value<String> name,
      Value<String> desc,
      Value<String> parentUuid,
      Value<int> createdAt,
      Value<int> updatedAt,
      Value<int> rowid,
    });

class $$GeneralSkillTableTableFilterComposer
    extends Composer<_$AppDatabase, $GeneralSkillTableTable> {
  $$GeneralSkillTableTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get uuid => $composableBuilder(
    column: $table.uuid,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get desc => $composableBuilder(
    column: $table.desc,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get parentUuid => $composableBuilder(
    column: $table.parentUuid,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnFilters(column),
  );
}

class $$GeneralSkillTableTableOrderingComposer
    extends Composer<_$AppDatabase, $GeneralSkillTableTable> {
  $$GeneralSkillTableTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get uuid => $composableBuilder(
    column: $table.uuid,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get desc => $composableBuilder(
    column: $table.desc,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get parentUuid => $composableBuilder(
    column: $table.parentUuid,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$GeneralSkillTableTableAnnotationComposer
    extends Composer<_$AppDatabase, $GeneralSkillTableTable> {
  $$GeneralSkillTableTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get uuid =>
      $composableBuilder(column: $table.uuid, builder: (column) => column);

  GeneratedColumn<String> get name =>
      $composableBuilder(column: $table.name, builder: (column) => column);

  GeneratedColumn<String> get desc =>
      $composableBuilder(column: $table.desc, builder: (column) => column);

  GeneratedColumn<String> get parentUuid => $composableBuilder(
    column: $table.parentUuid,
    builder: (column) => column,
  );

  GeneratedColumn<int> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<int> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);
}

class $$GeneralSkillTableTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $GeneralSkillTableTable,
          GeneralSkillTableData,
          $$GeneralSkillTableTableFilterComposer,
          $$GeneralSkillTableTableOrderingComposer,
          $$GeneralSkillTableTableAnnotationComposer,
          $$GeneralSkillTableTableCreateCompanionBuilder,
          $$GeneralSkillTableTableUpdateCompanionBuilder,
          (
            GeneralSkillTableData,
            BaseReferences<
              _$AppDatabase,
              $GeneralSkillTableTable,
              GeneralSkillTableData
            >,
          ),
          GeneralSkillTableData,
          PrefetchHooks Function()
        > {
  $$GeneralSkillTableTableTableManager(
    _$AppDatabase db,
    $GeneralSkillTableTable table,
  ) : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$GeneralSkillTableTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$GeneralSkillTableTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$GeneralSkillTableTableAnnotationComposer(
                $db: db,
                $table: table,
              ),
          updateCompanionCallback:
              ({
                Value<String> uuid = const Value.absent(),
                Value<String> name = const Value.absent(),
                Value<String> desc = const Value.absent(),
                Value<String> parentUuid = const Value.absent(),
                Value<int> createdAt = const Value.absent(),
                Value<int> updatedAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => GeneralSkillTableCompanion(
                uuid: uuid,
                name: name,
                desc: desc,
                parentUuid: parentUuid,
                createdAt: createdAt,
                updatedAt: updatedAt,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String uuid,
                required String name,
                required String desc,
                required String parentUuid,
                required int createdAt,
                required int updatedAt,
                Value<int> rowid = const Value.absent(),
              }) => GeneralSkillTableCompanion.insert(
                uuid: uuid,
                name: name,
                desc: desc,
                parentUuid: parentUuid,
                createdAt: createdAt,
                updatedAt: updatedAt,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ),
      );
}

typedef $$GeneralSkillTableTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $GeneralSkillTableTable,
      GeneralSkillTableData,
      $$GeneralSkillTableTableFilterComposer,
      $$GeneralSkillTableTableOrderingComposer,
      $$GeneralSkillTableTableAnnotationComposer,
      $$GeneralSkillTableTableCreateCompanionBuilder,
      $$GeneralSkillTableTableUpdateCompanionBuilder,
      (
        GeneralSkillTableData,
        BaseReferences<
          _$AppDatabase,
          $GeneralSkillTableTable,
          GeneralSkillTableData
        >,
      ),
      GeneralSkillTableData,
      PrefetchHooks Function()
    >;
typedef $$MagicMenaceTableTableCreateCompanionBuilder =
    MagicMenaceTableCompanion Function({
      required String uuid,
      required String name,
      required String resumedDesc,
      required String menaceUuid,
      required int magicBaseId,
      Value<int?> pm,
      Value<int?> cd,
      Value<int?> mediumDamageValue,
      Value<String?> damageDices,
      Value<String?> extraDamageDices,
      Value<int> rowid,
    });
typedef $$MagicMenaceTableTableUpdateCompanionBuilder =
    MagicMenaceTableCompanion Function({
      Value<String> uuid,
      Value<String> name,
      Value<String> resumedDesc,
      Value<String> menaceUuid,
      Value<int> magicBaseId,
      Value<int?> pm,
      Value<int?> cd,
      Value<int?> mediumDamageValue,
      Value<String?> damageDices,
      Value<String?> extraDamageDices,
      Value<int> rowid,
    });

class $$MagicMenaceTableTableFilterComposer
    extends Composer<_$AppDatabase, $MagicMenaceTableTable> {
  $$MagicMenaceTableTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get uuid => $composableBuilder(
    column: $table.uuid,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get resumedDesc => $composableBuilder(
    column: $table.resumedDesc,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get menaceUuid => $composableBuilder(
    column: $table.menaceUuid,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get magicBaseId => $composableBuilder(
    column: $table.magicBaseId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get pm => $composableBuilder(
    column: $table.pm,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get cd => $composableBuilder(
    column: $table.cd,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get mediumDamageValue => $composableBuilder(
    column: $table.mediumDamageValue,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get damageDices => $composableBuilder(
    column: $table.damageDices,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get extraDamageDices => $composableBuilder(
    column: $table.extraDamageDices,
    builder: (column) => ColumnFilters(column),
  );
}

class $$MagicMenaceTableTableOrderingComposer
    extends Composer<_$AppDatabase, $MagicMenaceTableTable> {
  $$MagicMenaceTableTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get uuid => $composableBuilder(
    column: $table.uuid,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get resumedDesc => $composableBuilder(
    column: $table.resumedDesc,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get menaceUuid => $composableBuilder(
    column: $table.menaceUuid,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get magicBaseId => $composableBuilder(
    column: $table.magicBaseId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get pm => $composableBuilder(
    column: $table.pm,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get cd => $composableBuilder(
    column: $table.cd,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get mediumDamageValue => $composableBuilder(
    column: $table.mediumDamageValue,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get damageDices => $composableBuilder(
    column: $table.damageDices,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get extraDamageDices => $composableBuilder(
    column: $table.extraDamageDices,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$MagicMenaceTableTableAnnotationComposer
    extends Composer<_$AppDatabase, $MagicMenaceTableTable> {
  $$MagicMenaceTableTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get uuid =>
      $composableBuilder(column: $table.uuid, builder: (column) => column);

  GeneratedColumn<String> get name =>
      $composableBuilder(column: $table.name, builder: (column) => column);

  GeneratedColumn<String> get resumedDesc => $composableBuilder(
    column: $table.resumedDesc,
    builder: (column) => column,
  );

  GeneratedColumn<String> get menaceUuid => $composableBuilder(
    column: $table.menaceUuid,
    builder: (column) => column,
  );

  GeneratedColumn<int> get magicBaseId => $composableBuilder(
    column: $table.magicBaseId,
    builder: (column) => column,
  );

  GeneratedColumn<int> get pm =>
      $composableBuilder(column: $table.pm, builder: (column) => column);

  GeneratedColumn<int> get cd =>
      $composableBuilder(column: $table.cd, builder: (column) => column);

  GeneratedColumn<int> get mediumDamageValue => $composableBuilder(
    column: $table.mediumDamageValue,
    builder: (column) => column,
  );

  GeneratedColumn<String> get damageDices => $composableBuilder(
    column: $table.damageDices,
    builder: (column) => column,
  );

  GeneratedColumn<String> get extraDamageDices => $composableBuilder(
    column: $table.extraDamageDices,
    builder: (column) => column,
  );
}

class $$MagicMenaceTableTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $MagicMenaceTableTable,
          MagicMenaceTableData,
          $$MagicMenaceTableTableFilterComposer,
          $$MagicMenaceTableTableOrderingComposer,
          $$MagicMenaceTableTableAnnotationComposer,
          $$MagicMenaceTableTableCreateCompanionBuilder,
          $$MagicMenaceTableTableUpdateCompanionBuilder,
          (
            MagicMenaceTableData,
            BaseReferences<
              _$AppDatabase,
              $MagicMenaceTableTable,
              MagicMenaceTableData
            >,
          ),
          MagicMenaceTableData,
          PrefetchHooks Function()
        > {
  $$MagicMenaceTableTableTableManager(
    _$AppDatabase db,
    $MagicMenaceTableTable table,
  ) : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$MagicMenaceTableTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$MagicMenaceTableTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$MagicMenaceTableTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> uuid = const Value.absent(),
                Value<String> name = const Value.absent(),
                Value<String> resumedDesc = const Value.absent(),
                Value<String> menaceUuid = const Value.absent(),
                Value<int> magicBaseId = const Value.absent(),
                Value<int?> pm = const Value.absent(),
                Value<int?> cd = const Value.absent(),
                Value<int?> mediumDamageValue = const Value.absent(),
                Value<String?> damageDices = const Value.absent(),
                Value<String?> extraDamageDices = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => MagicMenaceTableCompanion(
                uuid: uuid,
                name: name,
                resumedDesc: resumedDesc,
                menaceUuid: menaceUuid,
                magicBaseId: magicBaseId,
                pm: pm,
                cd: cd,
                mediumDamageValue: mediumDamageValue,
                damageDices: damageDices,
                extraDamageDices: extraDamageDices,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String uuid,
                required String name,
                required String resumedDesc,
                required String menaceUuid,
                required int magicBaseId,
                Value<int?> pm = const Value.absent(),
                Value<int?> cd = const Value.absent(),
                Value<int?> mediumDamageValue = const Value.absent(),
                Value<String?> damageDices = const Value.absent(),
                Value<String?> extraDamageDices = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => MagicMenaceTableCompanion.insert(
                uuid: uuid,
                name: name,
                resumedDesc: resumedDesc,
                menaceUuid: menaceUuid,
                magicBaseId: magicBaseId,
                pm: pm,
                cd: cd,
                mediumDamageValue: mediumDamageValue,
                damageDices: damageDices,
                extraDamageDices: extraDamageDices,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ),
      );
}

typedef $$MagicMenaceTableTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $MagicMenaceTableTable,
      MagicMenaceTableData,
      $$MagicMenaceTableTableFilterComposer,
      $$MagicMenaceTableTableOrderingComposer,
      $$MagicMenaceTableTableAnnotationComposer,
      $$MagicMenaceTableTableCreateCompanionBuilder,
      $$MagicMenaceTableTableUpdateCompanionBuilder,
      (
        MagicMenaceTableData,
        BaseReferences<
          _$AppDatabase,
          $MagicMenaceTableTable,
          MagicMenaceTableData
        >,
      ),
      MagicMenaceTableData,
      PrefetchHooks Function()
    >;
typedef $$SaddlebagTableTableCreateCompanionBuilder =
    SaddlebagTableCompanion Function({
      required String uuid,
      required String name,
      required String parentUuid,
      Value<double?> price,
      required int createdAt,
      required int updatedAt,
      Value<int> rowid,
    });
typedef $$SaddlebagTableTableUpdateCompanionBuilder =
    SaddlebagTableCompanion Function({
      Value<String> uuid,
      Value<String> name,
      Value<String> parentUuid,
      Value<double?> price,
      Value<int> createdAt,
      Value<int> updatedAt,
      Value<int> rowid,
    });

class $$SaddlebagTableTableFilterComposer
    extends Composer<_$AppDatabase, $SaddlebagTableTable> {
  $$SaddlebagTableTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get uuid => $composableBuilder(
    column: $table.uuid,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get parentUuid => $composableBuilder(
    column: $table.parentUuid,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get price => $composableBuilder(
    column: $table.price,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnFilters(column),
  );
}

class $$SaddlebagTableTableOrderingComposer
    extends Composer<_$AppDatabase, $SaddlebagTableTable> {
  $$SaddlebagTableTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get uuid => $composableBuilder(
    column: $table.uuid,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get parentUuid => $composableBuilder(
    column: $table.parentUuid,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get price => $composableBuilder(
    column: $table.price,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$SaddlebagTableTableAnnotationComposer
    extends Composer<_$AppDatabase, $SaddlebagTableTable> {
  $$SaddlebagTableTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get uuid =>
      $composableBuilder(column: $table.uuid, builder: (column) => column);

  GeneratedColumn<String> get name =>
      $composableBuilder(column: $table.name, builder: (column) => column);

  GeneratedColumn<String> get parentUuid => $composableBuilder(
    column: $table.parentUuid,
    builder: (column) => column,
  );

  GeneratedColumn<double> get price =>
      $composableBuilder(column: $table.price, builder: (column) => column);

  GeneratedColumn<int> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<int> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);
}

class $$SaddlebagTableTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $SaddlebagTableTable,
          SaddlebagTableData,
          $$SaddlebagTableTableFilterComposer,
          $$SaddlebagTableTableOrderingComposer,
          $$SaddlebagTableTableAnnotationComposer,
          $$SaddlebagTableTableCreateCompanionBuilder,
          $$SaddlebagTableTableUpdateCompanionBuilder,
          (
            SaddlebagTableData,
            BaseReferences<
              _$AppDatabase,
              $SaddlebagTableTable,
              SaddlebagTableData
            >,
          ),
          SaddlebagTableData,
          PrefetchHooks Function()
        > {
  $$SaddlebagTableTableTableManager(
    _$AppDatabase db,
    $SaddlebagTableTable table,
  ) : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$SaddlebagTableTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$SaddlebagTableTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$SaddlebagTableTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> uuid = const Value.absent(),
                Value<String> name = const Value.absent(),
                Value<String> parentUuid = const Value.absent(),
                Value<double?> price = const Value.absent(),
                Value<int> createdAt = const Value.absent(),
                Value<int> updatedAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => SaddlebagTableCompanion(
                uuid: uuid,
                name: name,
                parentUuid: parentUuid,
                price: price,
                createdAt: createdAt,
                updatedAt: updatedAt,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String uuid,
                required String name,
                required String parentUuid,
                Value<double?> price = const Value.absent(),
                required int createdAt,
                required int updatedAt,
                Value<int> rowid = const Value.absent(),
              }) => SaddlebagTableCompanion.insert(
                uuid: uuid,
                name: name,
                parentUuid: parentUuid,
                price: price,
                createdAt: createdAt,
                updatedAt: updatedAt,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ),
      );
}

typedef $$SaddlebagTableTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $SaddlebagTableTable,
      SaddlebagTableData,
      $$SaddlebagTableTableFilterComposer,
      $$SaddlebagTableTableOrderingComposer,
      $$SaddlebagTableTableAnnotationComposer,
      $$SaddlebagTableTableCreateCompanionBuilder,
      $$SaddlebagTableTableUpdateCompanionBuilder,
      (
        SaddlebagTableData,
        BaseReferences<_$AppDatabase, $SaddlebagTableTable, SaddlebagTableData>,
      ),
      SaddlebagTableData,
      PrefetchHooks Function()
    >;
typedef $$ShieldTableTableCreateCompanionBuilder =
    ShieldTableCompanion Function({
      required String uuid,
      required String name,
      required String parentUuid,
      Value<String?> storedIn,
      Value<String?> improvements,
      Value<int?> specialMaterialIndex,
      Value<double?> price,
      Value<String?> desc,
      required double ocupedSpace,
      required int typeIndex,
      required int defenseBonus,
      required int penalty,
      Value<bool> inUse,
      required int createdAt,
      required int updatedAt,
      Value<int> rowid,
    });
typedef $$ShieldTableTableUpdateCompanionBuilder =
    ShieldTableCompanion Function({
      Value<String> uuid,
      Value<String> name,
      Value<String> parentUuid,
      Value<String?> storedIn,
      Value<String?> improvements,
      Value<int?> specialMaterialIndex,
      Value<double?> price,
      Value<String?> desc,
      Value<double> ocupedSpace,
      Value<int> typeIndex,
      Value<int> defenseBonus,
      Value<int> penalty,
      Value<bool> inUse,
      Value<int> createdAt,
      Value<int> updatedAt,
      Value<int> rowid,
    });

class $$ShieldTableTableFilterComposer
    extends Composer<_$AppDatabase, $ShieldTableTable> {
  $$ShieldTableTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get uuid => $composableBuilder(
    column: $table.uuid,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get parentUuid => $composableBuilder(
    column: $table.parentUuid,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get storedIn => $composableBuilder(
    column: $table.storedIn,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get improvements => $composableBuilder(
    column: $table.improvements,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get specialMaterialIndex => $composableBuilder(
    column: $table.specialMaterialIndex,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get price => $composableBuilder(
    column: $table.price,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get desc => $composableBuilder(
    column: $table.desc,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get ocupedSpace => $composableBuilder(
    column: $table.ocupedSpace,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get typeIndex => $composableBuilder(
    column: $table.typeIndex,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get defenseBonus => $composableBuilder(
    column: $table.defenseBonus,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get penalty => $composableBuilder(
    column: $table.penalty,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get inUse => $composableBuilder(
    column: $table.inUse,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnFilters(column),
  );
}

class $$ShieldTableTableOrderingComposer
    extends Composer<_$AppDatabase, $ShieldTableTable> {
  $$ShieldTableTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get uuid => $composableBuilder(
    column: $table.uuid,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get parentUuid => $composableBuilder(
    column: $table.parentUuid,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get storedIn => $composableBuilder(
    column: $table.storedIn,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get improvements => $composableBuilder(
    column: $table.improvements,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get specialMaterialIndex => $composableBuilder(
    column: $table.specialMaterialIndex,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get price => $composableBuilder(
    column: $table.price,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get desc => $composableBuilder(
    column: $table.desc,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get ocupedSpace => $composableBuilder(
    column: $table.ocupedSpace,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get typeIndex => $composableBuilder(
    column: $table.typeIndex,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get defenseBonus => $composableBuilder(
    column: $table.defenseBonus,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get penalty => $composableBuilder(
    column: $table.penalty,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get inUse => $composableBuilder(
    column: $table.inUse,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$ShieldTableTableAnnotationComposer
    extends Composer<_$AppDatabase, $ShieldTableTable> {
  $$ShieldTableTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get uuid =>
      $composableBuilder(column: $table.uuid, builder: (column) => column);

  GeneratedColumn<String> get name =>
      $composableBuilder(column: $table.name, builder: (column) => column);

  GeneratedColumn<String> get parentUuid => $composableBuilder(
    column: $table.parentUuid,
    builder: (column) => column,
  );

  GeneratedColumn<String> get storedIn =>
      $composableBuilder(column: $table.storedIn, builder: (column) => column);

  GeneratedColumn<String> get improvements => $composableBuilder(
    column: $table.improvements,
    builder: (column) => column,
  );

  GeneratedColumn<int> get specialMaterialIndex => $composableBuilder(
    column: $table.specialMaterialIndex,
    builder: (column) => column,
  );

  GeneratedColumn<double> get price =>
      $composableBuilder(column: $table.price, builder: (column) => column);

  GeneratedColumn<String> get desc =>
      $composableBuilder(column: $table.desc, builder: (column) => column);

  GeneratedColumn<double> get ocupedSpace => $composableBuilder(
    column: $table.ocupedSpace,
    builder: (column) => column,
  );

  GeneratedColumn<int> get typeIndex =>
      $composableBuilder(column: $table.typeIndex, builder: (column) => column);

  GeneratedColumn<int> get defenseBonus => $composableBuilder(
    column: $table.defenseBonus,
    builder: (column) => column,
  );

  GeneratedColumn<int> get penalty =>
      $composableBuilder(column: $table.penalty, builder: (column) => column);

  GeneratedColumn<bool> get inUse =>
      $composableBuilder(column: $table.inUse, builder: (column) => column);

  GeneratedColumn<int> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<int> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);
}

class $$ShieldTableTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $ShieldTableTable,
          ShieldTableData,
          $$ShieldTableTableFilterComposer,
          $$ShieldTableTableOrderingComposer,
          $$ShieldTableTableAnnotationComposer,
          $$ShieldTableTableCreateCompanionBuilder,
          $$ShieldTableTableUpdateCompanionBuilder,
          (
            ShieldTableData,
            BaseReferences<_$AppDatabase, $ShieldTableTable, ShieldTableData>,
          ),
          ShieldTableData,
          PrefetchHooks Function()
        > {
  $$ShieldTableTableTableManager(_$AppDatabase db, $ShieldTableTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$ShieldTableTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$ShieldTableTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$ShieldTableTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> uuid = const Value.absent(),
                Value<String> name = const Value.absent(),
                Value<String> parentUuid = const Value.absent(),
                Value<String?> storedIn = const Value.absent(),
                Value<String?> improvements = const Value.absent(),
                Value<int?> specialMaterialIndex = const Value.absent(),
                Value<double?> price = const Value.absent(),
                Value<String?> desc = const Value.absent(),
                Value<double> ocupedSpace = const Value.absent(),
                Value<int> typeIndex = const Value.absent(),
                Value<int> defenseBonus = const Value.absent(),
                Value<int> penalty = const Value.absent(),
                Value<bool> inUse = const Value.absent(),
                Value<int> createdAt = const Value.absent(),
                Value<int> updatedAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => ShieldTableCompanion(
                uuid: uuid,
                name: name,
                parentUuid: parentUuid,
                storedIn: storedIn,
                improvements: improvements,
                specialMaterialIndex: specialMaterialIndex,
                price: price,
                desc: desc,
                ocupedSpace: ocupedSpace,
                typeIndex: typeIndex,
                defenseBonus: defenseBonus,
                penalty: penalty,
                inUse: inUse,
                createdAt: createdAt,
                updatedAt: updatedAt,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String uuid,
                required String name,
                required String parentUuid,
                Value<String?> storedIn = const Value.absent(),
                Value<String?> improvements = const Value.absent(),
                Value<int?> specialMaterialIndex = const Value.absent(),
                Value<double?> price = const Value.absent(),
                Value<String?> desc = const Value.absent(),
                required double ocupedSpace,
                required int typeIndex,
                required int defenseBonus,
                required int penalty,
                Value<bool> inUse = const Value.absent(),
                required int createdAt,
                required int updatedAt,
                Value<int> rowid = const Value.absent(),
              }) => ShieldTableCompanion.insert(
                uuid: uuid,
                name: name,
                parentUuid: parentUuid,
                storedIn: storedIn,
                improvements: improvements,
                specialMaterialIndex: specialMaterialIndex,
                price: price,
                desc: desc,
                ocupedSpace: ocupedSpace,
                typeIndex: typeIndex,
                defenseBonus: defenseBonus,
                penalty: penalty,
                inUse: inUse,
                createdAt: createdAt,
                updatedAt: updatedAt,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ),
      );
}

typedef $$ShieldTableTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $ShieldTableTable,
      ShieldTableData,
      $$ShieldTableTableFilterComposer,
      $$ShieldTableTableOrderingComposer,
      $$ShieldTableTableAnnotationComposer,
      $$ShieldTableTableCreateCompanionBuilder,
      $$ShieldTableTableUpdateCompanionBuilder,
      (
        ShieldTableData,
        BaseReferences<_$AppDatabase, $ShieldTableTable, ShieldTableData>,
      ),
      ShieldTableData,
      PrefetchHooks Function()
    >;
typedef $$TibarsTableTableCreateCompanionBuilder =
    TibarsTableCompanion Function({
      required String uuid,
      required String parentUuid,
      Value<String?> storedIn,
      required int gold,
      required int silver,
      required int bronze,
      required bool hasInitialRoll,
      required int createdAt,
      required int updatedAt,
      Value<int> rowid,
    });
typedef $$TibarsTableTableUpdateCompanionBuilder =
    TibarsTableCompanion Function({
      Value<String> uuid,
      Value<String> parentUuid,
      Value<String?> storedIn,
      Value<int> gold,
      Value<int> silver,
      Value<int> bronze,
      Value<bool> hasInitialRoll,
      Value<int> createdAt,
      Value<int> updatedAt,
      Value<int> rowid,
    });

class $$TibarsTableTableFilterComposer
    extends Composer<_$AppDatabase, $TibarsTableTable> {
  $$TibarsTableTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get uuid => $composableBuilder(
    column: $table.uuid,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get parentUuid => $composableBuilder(
    column: $table.parentUuid,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get storedIn => $composableBuilder(
    column: $table.storedIn,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get gold => $composableBuilder(
    column: $table.gold,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get silver => $composableBuilder(
    column: $table.silver,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get bronze => $composableBuilder(
    column: $table.bronze,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get hasInitialRoll => $composableBuilder(
    column: $table.hasInitialRoll,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnFilters(column),
  );
}

class $$TibarsTableTableOrderingComposer
    extends Composer<_$AppDatabase, $TibarsTableTable> {
  $$TibarsTableTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get uuid => $composableBuilder(
    column: $table.uuid,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get parentUuid => $composableBuilder(
    column: $table.parentUuid,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get storedIn => $composableBuilder(
    column: $table.storedIn,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get gold => $composableBuilder(
    column: $table.gold,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get silver => $composableBuilder(
    column: $table.silver,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get bronze => $composableBuilder(
    column: $table.bronze,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get hasInitialRoll => $composableBuilder(
    column: $table.hasInitialRoll,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$TibarsTableTableAnnotationComposer
    extends Composer<_$AppDatabase, $TibarsTableTable> {
  $$TibarsTableTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get uuid =>
      $composableBuilder(column: $table.uuid, builder: (column) => column);

  GeneratedColumn<String> get parentUuid => $composableBuilder(
    column: $table.parentUuid,
    builder: (column) => column,
  );

  GeneratedColumn<String> get storedIn =>
      $composableBuilder(column: $table.storedIn, builder: (column) => column);

  GeneratedColumn<int> get gold =>
      $composableBuilder(column: $table.gold, builder: (column) => column);

  GeneratedColumn<int> get silver =>
      $composableBuilder(column: $table.silver, builder: (column) => column);

  GeneratedColumn<int> get bronze =>
      $composableBuilder(column: $table.bronze, builder: (column) => column);

  GeneratedColumn<bool> get hasInitialRoll => $composableBuilder(
    column: $table.hasInitialRoll,
    builder: (column) => column,
  );

  GeneratedColumn<int> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<int> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);
}

class $$TibarsTableTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $TibarsTableTable,
          TibarsTableData,
          $$TibarsTableTableFilterComposer,
          $$TibarsTableTableOrderingComposer,
          $$TibarsTableTableAnnotationComposer,
          $$TibarsTableTableCreateCompanionBuilder,
          $$TibarsTableTableUpdateCompanionBuilder,
          (
            TibarsTableData,
            BaseReferences<_$AppDatabase, $TibarsTableTable, TibarsTableData>,
          ),
          TibarsTableData,
          PrefetchHooks Function()
        > {
  $$TibarsTableTableTableManager(_$AppDatabase db, $TibarsTableTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$TibarsTableTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$TibarsTableTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$TibarsTableTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> uuid = const Value.absent(),
                Value<String> parentUuid = const Value.absent(),
                Value<String?> storedIn = const Value.absent(),
                Value<int> gold = const Value.absent(),
                Value<int> silver = const Value.absent(),
                Value<int> bronze = const Value.absent(),
                Value<bool> hasInitialRoll = const Value.absent(),
                Value<int> createdAt = const Value.absent(),
                Value<int> updatedAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => TibarsTableCompanion(
                uuid: uuid,
                parentUuid: parentUuid,
                storedIn: storedIn,
                gold: gold,
                silver: silver,
                bronze: bronze,
                hasInitialRoll: hasInitialRoll,
                createdAt: createdAt,
                updatedAt: updatedAt,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String uuid,
                required String parentUuid,
                Value<String?> storedIn = const Value.absent(),
                required int gold,
                required int silver,
                required int bronze,
                required bool hasInitialRoll,
                required int createdAt,
                required int updatedAt,
                Value<int> rowid = const Value.absent(),
              }) => TibarsTableCompanion.insert(
                uuid: uuid,
                parentUuid: parentUuid,
                storedIn: storedIn,
                gold: gold,
                silver: silver,
                bronze: bronze,
                hasInitialRoll: hasInitialRoll,
                createdAt: createdAt,
                updatedAt: updatedAt,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ),
      );
}

typedef $$TibarsTableTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $TibarsTableTable,
      TibarsTableData,
      $$TibarsTableTableFilterComposer,
      $$TibarsTableTableOrderingComposer,
      $$TibarsTableTableAnnotationComposer,
      $$TibarsTableTableCreateCompanionBuilder,
      $$TibarsTableTableUpdateCompanionBuilder,
      (
        TibarsTableData,
        BaseReferences<_$AppDatabase, $TibarsTableTable, TibarsTableData>,
      ),
      TibarsTableData,
      PrefetchHooks Function()
    >;
typedef $$WeaponTableTableCreateCompanionBuilder =
    WeaponTableCompanion Function({
      required String uuid,
      required String name,
      required String parentUuid,
      Value<String?> storedIn,
      Value<String?> improvements,
      Value<int?> specialMaterialIndex,
      Value<double?> price,
      Value<String?> desc,
      required double ocupedSpace,
      required int wieldableIndex,
      required int purposeIndex,
      required int proficiencyIndex,
      required int typeIndex,
      required int rangeIndex,
      required int critical,
      required int criticalMultiplier,
      Value<int?> steps,
      required String dices,
      Value<String?> skillIndexes,
      required bool isNatural,
      required bool isUnarmed,
      required int createdAt,
      required int updatedAt,
      Value<int> rowid,
    });
typedef $$WeaponTableTableUpdateCompanionBuilder =
    WeaponTableCompanion Function({
      Value<String> uuid,
      Value<String> name,
      Value<String> parentUuid,
      Value<String?> storedIn,
      Value<String?> improvements,
      Value<int?> specialMaterialIndex,
      Value<double?> price,
      Value<String?> desc,
      Value<double> ocupedSpace,
      Value<int> wieldableIndex,
      Value<int> purposeIndex,
      Value<int> proficiencyIndex,
      Value<int> typeIndex,
      Value<int> rangeIndex,
      Value<int> critical,
      Value<int> criticalMultiplier,
      Value<int?> steps,
      Value<String> dices,
      Value<String?> skillIndexes,
      Value<bool> isNatural,
      Value<bool> isUnarmed,
      Value<int> createdAt,
      Value<int> updatedAt,
      Value<int> rowid,
    });

class $$WeaponTableTableFilterComposer
    extends Composer<_$AppDatabase, $WeaponTableTable> {
  $$WeaponTableTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get uuid => $composableBuilder(
    column: $table.uuid,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get parentUuid => $composableBuilder(
    column: $table.parentUuid,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get storedIn => $composableBuilder(
    column: $table.storedIn,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get improvements => $composableBuilder(
    column: $table.improvements,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get specialMaterialIndex => $composableBuilder(
    column: $table.specialMaterialIndex,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get price => $composableBuilder(
    column: $table.price,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get desc => $composableBuilder(
    column: $table.desc,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get ocupedSpace => $composableBuilder(
    column: $table.ocupedSpace,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get wieldableIndex => $composableBuilder(
    column: $table.wieldableIndex,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get purposeIndex => $composableBuilder(
    column: $table.purposeIndex,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get proficiencyIndex => $composableBuilder(
    column: $table.proficiencyIndex,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get typeIndex => $composableBuilder(
    column: $table.typeIndex,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get rangeIndex => $composableBuilder(
    column: $table.rangeIndex,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get critical => $composableBuilder(
    column: $table.critical,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get criticalMultiplier => $composableBuilder(
    column: $table.criticalMultiplier,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get steps => $composableBuilder(
    column: $table.steps,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get dices => $composableBuilder(
    column: $table.dices,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get skillIndexes => $composableBuilder(
    column: $table.skillIndexes,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get isNatural => $composableBuilder(
    column: $table.isNatural,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get isUnarmed => $composableBuilder(
    column: $table.isUnarmed,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnFilters(column),
  );
}

class $$WeaponTableTableOrderingComposer
    extends Composer<_$AppDatabase, $WeaponTableTable> {
  $$WeaponTableTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get uuid => $composableBuilder(
    column: $table.uuid,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get parentUuid => $composableBuilder(
    column: $table.parentUuid,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get storedIn => $composableBuilder(
    column: $table.storedIn,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get improvements => $composableBuilder(
    column: $table.improvements,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get specialMaterialIndex => $composableBuilder(
    column: $table.specialMaterialIndex,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get price => $composableBuilder(
    column: $table.price,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get desc => $composableBuilder(
    column: $table.desc,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get ocupedSpace => $composableBuilder(
    column: $table.ocupedSpace,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get wieldableIndex => $composableBuilder(
    column: $table.wieldableIndex,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get purposeIndex => $composableBuilder(
    column: $table.purposeIndex,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get proficiencyIndex => $composableBuilder(
    column: $table.proficiencyIndex,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get typeIndex => $composableBuilder(
    column: $table.typeIndex,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get rangeIndex => $composableBuilder(
    column: $table.rangeIndex,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get critical => $composableBuilder(
    column: $table.critical,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get criticalMultiplier => $composableBuilder(
    column: $table.criticalMultiplier,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get steps => $composableBuilder(
    column: $table.steps,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get dices => $composableBuilder(
    column: $table.dices,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get skillIndexes => $composableBuilder(
    column: $table.skillIndexes,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get isNatural => $composableBuilder(
    column: $table.isNatural,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get isUnarmed => $composableBuilder(
    column: $table.isUnarmed,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$WeaponTableTableAnnotationComposer
    extends Composer<_$AppDatabase, $WeaponTableTable> {
  $$WeaponTableTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get uuid =>
      $composableBuilder(column: $table.uuid, builder: (column) => column);

  GeneratedColumn<String> get name =>
      $composableBuilder(column: $table.name, builder: (column) => column);

  GeneratedColumn<String> get parentUuid => $composableBuilder(
    column: $table.parentUuid,
    builder: (column) => column,
  );

  GeneratedColumn<String> get storedIn =>
      $composableBuilder(column: $table.storedIn, builder: (column) => column);

  GeneratedColumn<String> get improvements => $composableBuilder(
    column: $table.improvements,
    builder: (column) => column,
  );

  GeneratedColumn<int> get specialMaterialIndex => $composableBuilder(
    column: $table.specialMaterialIndex,
    builder: (column) => column,
  );

  GeneratedColumn<double> get price =>
      $composableBuilder(column: $table.price, builder: (column) => column);

  GeneratedColumn<String> get desc =>
      $composableBuilder(column: $table.desc, builder: (column) => column);

  GeneratedColumn<double> get ocupedSpace => $composableBuilder(
    column: $table.ocupedSpace,
    builder: (column) => column,
  );

  GeneratedColumn<int> get wieldableIndex => $composableBuilder(
    column: $table.wieldableIndex,
    builder: (column) => column,
  );

  GeneratedColumn<int> get purposeIndex => $composableBuilder(
    column: $table.purposeIndex,
    builder: (column) => column,
  );

  GeneratedColumn<int> get proficiencyIndex => $composableBuilder(
    column: $table.proficiencyIndex,
    builder: (column) => column,
  );

  GeneratedColumn<int> get typeIndex =>
      $composableBuilder(column: $table.typeIndex, builder: (column) => column);

  GeneratedColumn<int> get rangeIndex => $composableBuilder(
    column: $table.rangeIndex,
    builder: (column) => column,
  );

  GeneratedColumn<int> get critical =>
      $composableBuilder(column: $table.critical, builder: (column) => column);

  GeneratedColumn<int> get criticalMultiplier => $composableBuilder(
    column: $table.criticalMultiplier,
    builder: (column) => column,
  );

  GeneratedColumn<int> get steps =>
      $composableBuilder(column: $table.steps, builder: (column) => column);

  GeneratedColumn<String> get dices =>
      $composableBuilder(column: $table.dices, builder: (column) => column);

  GeneratedColumn<String> get skillIndexes => $composableBuilder(
    column: $table.skillIndexes,
    builder: (column) => column,
  );

  GeneratedColumn<bool> get isNatural =>
      $composableBuilder(column: $table.isNatural, builder: (column) => column);

  GeneratedColumn<bool> get isUnarmed =>
      $composableBuilder(column: $table.isUnarmed, builder: (column) => column);

  GeneratedColumn<int> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<int> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);
}

class $$WeaponTableTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $WeaponTableTable,
          WeaponTableData,
          $$WeaponTableTableFilterComposer,
          $$WeaponTableTableOrderingComposer,
          $$WeaponTableTableAnnotationComposer,
          $$WeaponTableTableCreateCompanionBuilder,
          $$WeaponTableTableUpdateCompanionBuilder,
          (
            WeaponTableData,
            BaseReferences<_$AppDatabase, $WeaponTableTable, WeaponTableData>,
          ),
          WeaponTableData,
          PrefetchHooks Function()
        > {
  $$WeaponTableTableTableManager(_$AppDatabase db, $WeaponTableTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$WeaponTableTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$WeaponTableTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$WeaponTableTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> uuid = const Value.absent(),
                Value<String> name = const Value.absent(),
                Value<String> parentUuid = const Value.absent(),
                Value<String?> storedIn = const Value.absent(),
                Value<String?> improvements = const Value.absent(),
                Value<int?> specialMaterialIndex = const Value.absent(),
                Value<double?> price = const Value.absent(),
                Value<String?> desc = const Value.absent(),
                Value<double> ocupedSpace = const Value.absent(),
                Value<int> wieldableIndex = const Value.absent(),
                Value<int> purposeIndex = const Value.absent(),
                Value<int> proficiencyIndex = const Value.absent(),
                Value<int> typeIndex = const Value.absent(),
                Value<int> rangeIndex = const Value.absent(),
                Value<int> critical = const Value.absent(),
                Value<int> criticalMultiplier = const Value.absent(),
                Value<int?> steps = const Value.absent(),
                Value<String> dices = const Value.absent(),
                Value<String?> skillIndexes = const Value.absent(),
                Value<bool> isNatural = const Value.absent(),
                Value<bool> isUnarmed = const Value.absent(),
                Value<int> createdAt = const Value.absent(),
                Value<int> updatedAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => WeaponTableCompanion(
                uuid: uuid,
                name: name,
                parentUuid: parentUuid,
                storedIn: storedIn,
                improvements: improvements,
                specialMaterialIndex: specialMaterialIndex,
                price: price,
                desc: desc,
                ocupedSpace: ocupedSpace,
                wieldableIndex: wieldableIndex,
                purposeIndex: purposeIndex,
                proficiencyIndex: proficiencyIndex,
                typeIndex: typeIndex,
                rangeIndex: rangeIndex,
                critical: critical,
                criticalMultiplier: criticalMultiplier,
                steps: steps,
                dices: dices,
                skillIndexes: skillIndexes,
                isNatural: isNatural,
                isUnarmed: isUnarmed,
                createdAt: createdAt,
                updatedAt: updatedAt,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String uuid,
                required String name,
                required String parentUuid,
                Value<String?> storedIn = const Value.absent(),
                Value<String?> improvements = const Value.absent(),
                Value<int?> specialMaterialIndex = const Value.absent(),
                Value<double?> price = const Value.absent(),
                Value<String?> desc = const Value.absent(),
                required double ocupedSpace,
                required int wieldableIndex,
                required int purposeIndex,
                required int proficiencyIndex,
                required int typeIndex,
                required int rangeIndex,
                required int critical,
                required int criticalMultiplier,
                Value<int?> steps = const Value.absent(),
                required String dices,
                Value<String?> skillIndexes = const Value.absent(),
                required bool isNatural,
                required bool isUnarmed,
                required int createdAt,
                required int updatedAt,
                Value<int> rowid = const Value.absent(),
              }) => WeaponTableCompanion.insert(
                uuid: uuid,
                name: name,
                parentUuid: parentUuid,
                storedIn: storedIn,
                improvements: improvements,
                specialMaterialIndex: specialMaterialIndex,
                price: price,
                desc: desc,
                ocupedSpace: ocupedSpace,
                wieldableIndex: wieldableIndex,
                purposeIndex: purposeIndex,
                proficiencyIndex: proficiencyIndex,
                typeIndex: typeIndex,
                rangeIndex: rangeIndex,
                critical: critical,
                criticalMultiplier: criticalMultiplier,
                steps: steps,
                dices: dices,
                skillIndexes: skillIndexes,
                isNatural: isNatural,
                isUnarmed: isUnarmed,
                createdAt: createdAt,
                updatedAt: updatedAt,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ),
      );
}

typedef $$WeaponTableTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $WeaponTableTable,
      WeaponTableData,
      $$WeaponTableTableFilterComposer,
      $$WeaponTableTableOrderingComposer,
      $$WeaponTableTableAnnotationComposer,
      $$WeaponTableTableCreateCompanionBuilder,
      $$WeaponTableTableUpdateCompanionBuilder,
      (
        WeaponTableData,
        BaseReferences<_$AppDatabase, $WeaponTableTable, WeaponTableData>,
      ),
      WeaponTableData,
      PrefetchHooks Function()
    >;
typedef $$ActionTableTableCreateCompanionBuilder =
    ActionTableCompanion Function({
      required String uuid,
      required String name,
      required String parentUuid,
      required String desc,
      Value<String?> damageDices,
      Value<String?> extraDamageDices,
      Value<int?> pm,
      Value<int?> cd,
      Value<String?> equipamentUuid,
      Value<int?> mediumDamageValue,
      Value<int?> critical,
      Value<int?> criticalMultiplier,
      required int typeIndex,
      required int createdAt,
      required int updatedAt,
      Value<int> rowid,
    });
typedef $$ActionTableTableUpdateCompanionBuilder =
    ActionTableCompanion Function({
      Value<String> uuid,
      Value<String> name,
      Value<String> parentUuid,
      Value<String> desc,
      Value<String?> damageDices,
      Value<String?> extraDamageDices,
      Value<int?> pm,
      Value<int?> cd,
      Value<String?> equipamentUuid,
      Value<int?> mediumDamageValue,
      Value<int?> critical,
      Value<int?> criticalMultiplier,
      Value<int> typeIndex,
      Value<int> createdAt,
      Value<int> updatedAt,
      Value<int> rowid,
    });

class $$ActionTableTableFilterComposer
    extends Composer<_$AppDatabase, $ActionTableTable> {
  $$ActionTableTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get uuid => $composableBuilder(
    column: $table.uuid,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get parentUuid => $composableBuilder(
    column: $table.parentUuid,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get desc => $composableBuilder(
    column: $table.desc,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get damageDices => $composableBuilder(
    column: $table.damageDices,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get extraDamageDices => $composableBuilder(
    column: $table.extraDamageDices,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get pm => $composableBuilder(
    column: $table.pm,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get cd => $composableBuilder(
    column: $table.cd,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get equipamentUuid => $composableBuilder(
    column: $table.equipamentUuid,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get mediumDamageValue => $composableBuilder(
    column: $table.mediumDamageValue,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get critical => $composableBuilder(
    column: $table.critical,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get criticalMultiplier => $composableBuilder(
    column: $table.criticalMultiplier,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get typeIndex => $composableBuilder(
    column: $table.typeIndex,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnFilters(column),
  );
}

class $$ActionTableTableOrderingComposer
    extends Composer<_$AppDatabase, $ActionTableTable> {
  $$ActionTableTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get uuid => $composableBuilder(
    column: $table.uuid,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get parentUuid => $composableBuilder(
    column: $table.parentUuid,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get desc => $composableBuilder(
    column: $table.desc,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get damageDices => $composableBuilder(
    column: $table.damageDices,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get extraDamageDices => $composableBuilder(
    column: $table.extraDamageDices,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get pm => $composableBuilder(
    column: $table.pm,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get cd => $composableBuilder(
    column: $table.cd,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get equipamentUuid => $composableBuilder(
    column: $table.equipamentUuid,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get mediumDamageValue => $composableBuilder(
    column: $table.mediumDamageValue,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get critical => $composableBuilder(
    column: $table.critical,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get criticalMultiplier => $composableBuilder(
    column: $table.criticalMultiplier,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get typeIndex => $composableBuilder(
    column: $table.typeIndex,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$ActionTableTableAnnotationComposer
    extends Composer<_$AppDatabase, $ActionTableTable> {
  $$ActionTableTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get uuid =>
      $composableBuilder(column: $table.uuid, builder: (column) => column);

  GeneratedColumn<String> get name =>
      $composableBuilder(column: $table.name, builder: (column) => column);

  GeneratedColumn<String> get parentUuid => $composableBuilder(
    column: $table.parentUuid,
    builder: (column) => column,
  );

  GeneratedColumn<String> get desc =>
      $composableBuilder(column: $table.desc, builder: (column) => column);

  GeneratedColumn<String> get damageDices => $composableBuilder(
    column: $table.damageDices,
    builder: (column) => column,
  );

  GeneratedColumn<String> get extraDamageDices => $composableBuilder(
    column: $table.extraDamageDices,
    builder: (column) => column,
  );

  GeneratedColumn<int> get pm =>
      $composableBuilder(column: $table.pm, builder: (column) => column);

  GeneratedColumn<int> get cd =>
      $composableBuilder(column: $table.cd, builder: (column) => column);

  GeneratedColumn<String> get equipamentUuid => $composableBuilder(
    column: $table.equipamentUuid,
    builder: (column) => column,
  );

  GeneratedColumn<int> get mediumDamageValue => $composableBuilder(
    column: $table.mediumDamageValue,
    builder: (column) => column,
  );

  GeneratedColumn<int> get critical =>
      $composableBuilder(column: $table.critical, builder: (column) => column);

  GeneratedColumn<int> get criticalMultiplier => $composableBuilder(
    column: $table.criticalMultiplier,
    builder: (column) => column,
  );

  GeneratedColumn<int> get typeIndex =>
      $composableBuilder(column: $table.typeIndex, builder: (column) => column);

  GeneratedColumn<int> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<int> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);
}

class $$ActionTableTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $ActionTableTable,
          ActionTableData,
          $$ActionTableTableFilterComposer,
          $$ActionTableTableOrderingComposer,
          $$ActionTableTableAnnotationComposer,
          $$ActionTableTableCreateCompanionBuilder,
          $$ActionTableTableUpdateCompanionBuilder,
          (
            ActionTableData,
            BaseReferences<_$AppDatabase, $ActionTableTable, ActionTableData>,
          ),
          ActionTableData,
          PrefetchHooks Function()
        > {
  $$ActionTableTableTableManager(_$AppDatabase db, $ActionTableTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$ActionTableTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$ActionTableTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$ActionTableTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> uuid = const Value.absent(),
                Value<String> name = const Value.absent(),
                Value<String> parentUuid = const Value.absent(),
                Value<String> desc = const Value.absent(),
                Value<String?> damageDices = const Value.absent(),
                Value<String?> extraDamageDices = const Value.absent(),
                Value<int?> pm = const Value.absent(),
                Value<int?> cd = const Value.absent(),
                Value<String?> equipamentUuid = const Value.absent(),
                Value<int?> mediumDamageValue = const Value.absent(),
                Value<int?> critical = const Value.absent(),
                Value<int?> criticalMultiplier = const Value.absent(),
                Value<int> typeIndex = const Value.absent(),
                Value<int> createdAt = const Value.absent(),
                Value<int> updatedAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => ActionTableCompanion(
                uuid: uuid,
                name: name,
                parentUuid: parentUuid,
                desc: desc,
                damageDices: damageDices,
                extraDamageDices: extraDamageDices,
                pm: pm,
                cd: cd,
                equipamentUuid: equipamentUuid,
                mediumDamageValue: mediumDamageValue,
                critical: critical,
                criticalMultiplier: criticalMultiplier,
                typeIndex: typeIndex,
                createdAt: createdAt,
                updatedAt: updatedAt,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String uuid,
                required String name,
                required String parentUuid,
                required String desc,
                Value<String?> damageDices = const Value.absent(),
                Value<String?> extraDamageDices = const Value.absent(),
                Value<int?> pm = const Value.absent(),
                Value<int?> cd = const Value.absent(),
                Value<String?> equipamentUuid = const Value.absent(),
                Value<int?> mediumDamageValue = const Value.absent(),
                Value<int?> critical = const Value.absent(),
                Value<int?> criticalMultiplier = const Value.absent(),
                required int typeIndex,
                required int createdAt,
                required int updatedAt,
                Value<int> rowid = const Value.absent(),
              }) => ActionTableCompanion.insert(
                uuid: uuid,
                name: name,
                parentUuid: parentUuid,
                desc: desc,
                damageDices: damageDices,
                extraDamageDices: extraDamageDices,
                pm: pm,
                cd: cd,
                equipamentUuid: equipamentUuid,
                mediumDamageValue: mediumDamageValue,
                critical: critical,
                criticalMultiplier: criticalMultiplier,
                typeIndex: typeIndex,
                createdAt: createdAt,
                updatedAt: updatedAt,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ),
      );
}

typedef $$ActionTableTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $ActionTableTable,
      ActionTableData,
      $$ActionTableTableFilterComposer,
      $$ActionTableTableOrderingComposer,
      $$ActionTableTableAnnotationComposer,
      $$ActionTableTableCreateCompanionBuilder,
      $$ActionTableTableUpdateCompanionBuilder,
      (
        ActionTableData,
        BaseReferences<_$AppDatabase, $ActionTableTable, ActionTableData>,
      ),
      ActionTableData,
      PrefetchHooks Function()
    >;
typedef $$ActionHandToHandTableTableCreateCompanionBuilder =
    ActionHandToHandTableCompanion Function({
      required String uuid,
      required String name,
      required String parentUuid,
      required String desc,
      Value<String?> damageDices,
      Value<String?> extraDamageDices,
      Value<int?> pm,
      Value<int?> cd,
      Value<String?> equipamentUuid,
      Value<int?> mediumDamageValue,
      Value<int?> critical,
      Value<int?> criticalMultiplier,
      required int typeIndex,
      required int createdAt,
      required int updatedAt,
      Value<int> rowid,
    });
typedef $$ActionHandToHandTableTableUpdateCompanionBuilder =
    ActionHandToHandTableCompanion Function({
      Value<String> uuid,
      Value<String> name,
      Value<String> parentUuid,
      Value<String> desc,
      Value<String?> damageDices,
      Value<String?> extraDamageDices,
      Value<int?> pm,
      Value<int?> cd,
      Value<String?> equipamentUuid,
      Value<int?> mediumDamageValue,
      Value<int?> critical,
      Value<int?> criticalMultiplier,
      Value<int> typeIndex,
      Value<int> createdAt,
      Value<int> updatedAt,
      Value<int> rowid,
    });

class $$ActionHandToHandTableTableFilterComposer
    extends Composer<_$AppDatabase, $ActionHandToHandTableTable> {
  $$ActionHandToHandTableTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get uuid => $composableBuilder(
    column: $table.uuid,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get parentUuid => $composableBuilder(
    column: $table.parentUuid,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get desc => $composableBuilder(
    column: $table.desc,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get damageDices => $composableBuilder(
    column: $table.damageDices,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get extraDamageDices => $composableBuilder(
    column: $table.extraDamageDices,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get pm => $composableBuilder(
    column: $table.pm,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get cd => $composableBuilder(
    column: $table.cd,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get equipamentUuid => $composableBuilder(
    column: $table.equipamentUuid,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get mediumDamageValue => $composableBuilder(
    column: $table.mediumDamageValue,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get critical => $composableBuilder(
    column: $table.critical,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get criticalMultiplier => $composableBuilder(
    column: $table.criticalMultiplier,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get typeIndex => $composableBuilder(
    column: $table.typeIndex,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnFilters(column),
  );
}

class $$ActionHandToHandTableTableOrderingComposer
    extends Composer<_$AppDatabase, $ActionHandToHandTableTable> {
  $$ActionHandToHandTableTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get uuid => $composableBuilder(
    column: $table.uuid,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get parentUuid => $composableBuilder(
    column: $table.parentUuid,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get desc => $composableBuilder(
    column: $table.desc,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get damageDices => $composableBuilder(
    column: $table.damageDices,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get extraDamageDices => $composableBuilder(
    column: $table.extraDamageDices,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get pm => $composableBuilder(
    column: $table.pm,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get cd => $composableBuilder(
    column: $table.cd,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get equipamentUuid => $composableBuilder(
    column: $table.equipamentUuid,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get mediumDamageValue => $composableBuilder(
    column: $table.mediumDamageValue,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get critical => $composableBuilder(
    column: $table.critical,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get criticalMultiplier => $composableBuilder(
    column: $table.criticalMultiplier,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get typeIndex => $composableBuilder(
    column: $table.typeIndex,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$ActionHandToHandTableTableAnnotationComposer
    extends Composer<_$AppDatabase, $ActionHandToHandTableTable> {
  $$ActionHandToHandTableTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get uuid =>
      $composableBuilder(column: $table.uuid, builder: (column) => column);

  GeneratedColumn<String> get name =>
      $composableBuilder(column: $table.name, builder: (column) => column);

  GeneratedColumn<String> get parentUuid => $composableBuilder(
    column: $table.parentUuid,
    builder: (column) => column,
  );

  GeneratedColumn<String> get desc =>
      $composableBuilder(column: $table.desc, builder: (column) => column);

  GeneratedColumn<String> get damageDices => $composableBuilder(
    column: $table.damageDices,
    builder: (column) => column,
  );

  GeneratedColumn<String> get extraDamageDices => $composableBuilder(
    column: $table.extraDamageDices,
    builder: (column) => column,
  );

  GeneratedColumn<int> get pm =>
      $composableBuilder(column: $table.pm, builder: (column) => column);

  GeneratedColumn<int> get cd =>
      $composableBuilder(column: $table.cd, builder: (column) => column);

  GeneratedColumn<String> get equipamentUuid => $composableBuilder(
    column: $table.equipamentUuid,
    builder: (column) => column,
  );

  GeneratedColumn<int> get mediumDamageValue => $composableBuilder(
    column: $table.mediumDamageValue,
    builder: (column) => column,
  );

  GeneratedColumn<int> get critical =>
      $composableBuilder(column: $table.critical, builder: (column) => column);

  GeneratedColumn<int> get criticalMultiplier => $composableBuilder(
    column: $table.criticalMultiplier,
    builder: (column) => column,
  );

  GeneratedColumn<int> get typeIndex =>
      $composableBuilder(column: $table.typeIndex, builder: (column) => column);

  GeneratedColumn<int> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<int> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);
}

class $$ActionHandToHandTableTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $ActionHandToHandTableTable,
          ActionHandToHandTableData,
          $$ActionHandToHandTableTableFilterComposer,
          $$ActionHandToHandTableTableOrderingComposer,
          $$ActionHandToHandTableTableAnnotationComposer,
          $$ActionHandToHandTableTableCreateCompanionBuilder,
          $$ActionHandToHandTableTableUpdateCompanionBuilder,
          (
            ActionHandToHandTableData,
            BaseReferences<
              _$AppDatabase,
              $ActionHandToHandTableTable,
              ActionHandToHandTableData
            >,
          ),
          ActionHandToHandTableData,
          PrefetchHooks Function()
        > {
  $$ActionHandToHandTableTableTableManager(
    _$AppDatabase db,
    $ActionHandToHandTableTable table,
  ) : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$ActionHandToHandTableTableFilterComposer(
                $db: db,
                $table: table,
              ),
          createOrderingComposer: () =>
              $$ActionHandToHandTableTableOrderingComposer(
                $db: db,
                $table: table,
              ),
          createComputedFieldComposer: () =>
              $$ActionHandToHandTableTableAnnotationComposer(
                $db: db,
                $table: table,
              ),
          updateCompanionCallback:
              ({
                Value<String> uuid = const Value.absent(),
                Value<String> name = const Value.absent(),
                Value<String> parentUuid = const Value.absent(),
                Value<String> desc = const Value.absent(),
                Value<String?> damageDices = const Value.absent(),
                Value<String?> extraDamageDices = const Value.absent(),
                Value<int?> pm = const Value.absent(),
                Value<int?> cd = const Value.absent(),
                Value<String?> equipamentUuid = const Value.absent(),
                Value<int?> mediumDamageValue = const Value.absent(),
                Value<int?> critical = const Value.absent(),
                Value<int?> criticalMultiplier = const Value.absent(),
                Value<int> typeIndex = const Value.absent(),
                Value<int> createdAt = const Value.absent(),
                Value<int> updatedAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => ActionHandToHandTableCompanion(
                uuid: uuid,
                name: name,
                parentUuid: parentUuid,
                desc: desc,
                damageDices: damageDices,
                extraDamageDices: extraDamageDices,
                pm: pm,
                cd: cd,
                equipamentUuid: equipamentUuid,
                mediumDamageValue: mediumDamageValue,
                critical: critical,
                criticalMultiplier: criticalMultiplier,
                typeIndex: typeIndex,
                createdAt: createdAt,
                updatedAt: updatedAt,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String uuid,
                required String name,
                required String parentUuid,
                required String desc,
                Value<String?> damageDices = const Value.absent(),
                Value<String?> extraDamageDices = const Value.absent(),
                Value<int?> pm = const Value.absent(),
                Value<int?> cd = const Value.absent(),
                Value<String?> equipamentUuid = const Value.absent(),
                Value<int?> mediumDamageValue = const Value.absent(),
                Value<int?> critical = const Value.absent(),
                Value<int?> criticalMultiplier = const Value.absent(),
                required int typeIndex,
                required int createdAt,
                required int updatedAt,
                Value<int> rowid = const Value.absent(),
              }) => ActionHandToHandTableCompanion.insert(
                uuid: uuid,
                name: name,
                parentUuid: parentUuid,
                desc: desc,
                damageDices: damageDices,
                extraDamageDices: extraDamageDices,
                pm: pm,
                cd: cd,
                equipamentUuid: equipamentUuid,
                mediumDamageValue: mediumDamageValue,
                critical: critical,
                criticalMultiplier: criticalMultiplier,
                typeIndex: typeIndex,
                createdAt: createdAt,
                updatedAt: updatedAt,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ),
      );
}

typedef $$ActionHandToHandTableTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $ActionHandToHandTableTable,
      ActionHandToHandTableData,
      $$ActionHandToHandTableTableFilterComposer,
      $$ActionHandToHandTableTableOrderingComposer,
      $$ActionHandToHandTableTableAnnotationComposer,
      $$ActionHandToHandTableTableCreateCompanionBuilder,
      $$ActionHandToHandTableTableUpdateCompanionBuilder,
      (
        ActionHandToHandTableData,
        BaseReferences<
          _$AppDatabase,
          $ActionHandToHandTableTable,
          ActionHandToHandTableData
        >,
      ),
      ActionHandToHandTableData,
      PrefetchHooks Function()
    >;
typedef $$ActionDistanceAttackTableTableCreateCompanionBuilder =
    ActionDistanceAttackTableCompanion Function({
      required String uuid,
      required String name,
      required String parentUuid,
      required String desc,
      Value<String?> damageDices,
      Value<String?> extraDamageDices,
      Value<int?> pm,
      Value<int?> cd,
      Value<String?> equipamentUuid,
      Value<int?> mediumDamageValue,
      Value<int?> critical,
      Value<int?> criticalMultiplier,
      required int typeIndex,
      required int createdAt,
      required int updatedAt,
      Value<int> rowid,
    });
typedef $$ActionDistanceAttackTableTableUpdateCompanionBuilder =
    ActionDistanceAttackTableCompanion Function({
      Value<String> uuid,
      Value<String> name,
      Value<String> parentUuid,
      Value<String> desc,
      Value<String?> damageDices,
      Value<String?> extraDamageDices,
      Value<int?> pm,
      Value<int?> cd,
      Value<String?> equipamentUuid,
      Value<int?> mediumDamageValue,
      Value<int?> critical,
      Value<int?> criticalMultiplier,
      Value<int> typeIndex,
      Value<int> createdAt,
      Value<int> updatedAt,
      Value<int> rowid,
    });

class $$ActionDistanceAttackTableTableFilterComposer
    extends Composer<_$AppDatabase, $ActionDistanceAttackTableTable> {
  $$ActionDistanceAttackTableTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get uuid => $composableBuilder(
    column: $table.uuid,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get parentUuid => $composableBuilder(
    column: $table.parentUuid,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get desc => $composableBuilder(
    column: $table.desc,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get damageDices => $composableBuilder(
    column: $table.damageDices,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get extraDamageDices => $composableBuilder(
    column: $table.extraDamageDices,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get pm => $composableBuilder(
    column: $table.pm,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get cd => $composableBuilder(
    column: $table.cd,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get equipamentUuid => $composableBuilder(
    column: $table.equipamentUuid,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get mediumDamageValue => $composableBuilder(
    column: $table.mediumDamageValue,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get critical => $composableBuilder(
    column: $table.critical,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get criticalMultiplier => $composableBuilder(
    column: $table.criticalMultiplier,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get typeIndex => $composableBuilder(
    column: $table.typeIndex,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnFilters(column),
  );
}

class $$ActionDistanceAttackTableTableOrderingComposer
    extends Composer<_$AppDatabase, $ActionDistanceAttackTableTable> {
  $$ActionDistanceAttackTableTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get uuid => $composableBuilder(
    column: $table.uuid,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get parentUuid => $composableBuilder(
    column: $table.parentUuid,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get desc => $composableBuilder(
    column: $table.desc,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get damageDices => $composableBuilder(
    column: $table.damageDices,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get extraDamageDices => $composableBuilder(
    column: $table.extraDamageDices,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get pm => $composableBuilder(
    column: $table.pm,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get cd => $composableBuilder(
    column: $table.cd,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get equipamentUuid => $composableBuilder(
    column: $table.equipamentUuid,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get mediumDamageValue => $composableBuilder(
    column: $table.mediumDamageValue,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get critical => $composableBuilder(
    column: $table.critical,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get criticalMultiplier => $composableBuilder(
    column: $table.criticalMultiplier,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get typeIndex => $composableBuilder(
    column: $table.typeIndex,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$ActionDistanceAttackTableTableAnnotationComposer
    extends Composer<_$AppDatabase, $ActionDistanceAttackTableTable> {
  $$ActionDistanceAttackTableTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get uuid =>
      $composableBuilder(column: $table.uuid, builder: (column) => column);

  GeneratedColumn<String> get name =>
      $composableBuilder(column: $table.name, builder: (column) => column);

  GeneratedColumn<String> get parentUuid => $composableBuilder(
    column: $table.parentUuid,
    builder: (column) => column,
  );

  GeneratedColumn<String> get desc =>
      $composableBuilder(column: $table.desc, builder: (column) => column);

  GeneratedColumn<String> get damageDices => $composableBuilder(
    column: $table.damageDices,
    builder: (column) => column,
  );

  GeneratedColumn<String> get extraDamageDices => $composableBuilder(
    column: $table.extraDamageDices,
    builder: (column) => column,
  );

  GeneratedColumn<int> get pm =>
      $composableBuilder(column: $table.pm, builder: (column) => column);

  GeneratedColumn<int> get cd =>
      $composableBuilder(column: $table.cd, builder: (column) => column);

  GeneratedColumn<String> get equipamentUuid => $composableBuilder(
    column: $table.equipamentUuid,
    builder: (column) => column,
  );

  GeneratedColumn<int> get mediumDamageValue => $composableBuilder(
    column: $table.mediumDamageValue,
    builder: (column) => column,
  );

  GeneratedColumn<int> get critical =>
      $composableBuilder(column: $table.critical, builder: (column) => column);

  GeneratedColumn<int> get criticalMultiplier => $composableBuilder(
    column: $table.criticalMultiplier,
    builder: (column) => column,
  );

  GeneratedColumn<int> get typeIndex =>
      $composableBuilder(column: $table.typeIndex, builder: (column) => column);

  GeneratedColumn<int> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<int> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);
}

class $$ActionDistanceAttackTableTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $ActionDistanceAttackTableTable,
          ActionDistanceAttackTableData,
          $$ActionDistanceAttackTableTableFilterComposer,
          $$ActionDistanceAttackTableTableOrderingComposer,
          $$ActionDistanceAttackTableTableAnnotationComposer,
          $$ActionDistanceAttackTableTableCreateCompanionBuilder,
          $$ActionDistanceAttackTableTableUpdateCompanionBuilder,
          (
            ActionDistanceAttackTableData,
            BaseReferences<
              _$AppDatabase,
              $ActionDistanceAttackTableTable,
              ActionDistanceAttackTableData
            >,
          ),
          ActionDistanceAttackTableData,
          PrefetchHooks Function()
        > {
  $$ActionDistanceAttackTableTableTableManager(
    _$AppDatabase db,
    $ActionDistanceAttackTableTable table,
  ) : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$ActionDistanceAttackTableTableFilterComposer(
                $db: db,
                $table: table,
              ),
          createOrderingComposer: () =>
              $$ActionDistanceAttackTableTableOrderingComposer(
                $db: db,
                $table: table,
              ),
          createComputedFieldComposer: () =>
              $$ActionDistanceAttackTableTableAnnotationComposer(
                $db: db,
                $table: table,
              ),
          updateCompanionCallback:
              ({
                Value<String> uuid = const Value.absent(),
                Value<String> name = const Value.absent(),
                Value<String> parentUuid = const Value.absent(),
                Value<String> desc = const Value.absent(),
                Value<String?> damageDices = const Value.absent(),
                Value<String?> extraDamageDices = const Value.absent(),
                Value<int?> pm = const Value.absent(),
                Value<int?> cd = const Value.absent(),
                Value<String?> equipamentUuid = const Value.absent(),
                Value<int?> mediumDamageValue = const Value.absent(),
                Value<int?> critical = const Value.absent(),
                Value<int?> criticalMultiplier = const Value.absent(),
                Value<int> typeIndex = const Value.absent(),
                Value<int> createdAt = const Value.absent(),
                Value<int> updatedAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => ActionDistanceAttackTableCompanion(
                uuid: uuid,
                name: name,
                parentUuid: parentUuid,
                desc: desc,
                damageDices: damageDices,
                extraDamageDices: extraDamageDices,
                pm: pm,
                cd: cd,
                equipamentUuid: equipamentUuid,
                mediumDamageValue: mediumDamageValue,
                critical: critical,
                criticalMultiplier: criticalMultiplier,
                typeIndex: typeIndex,
                createdAt: createdAt,
                updatedAt: updatedAt,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String uuid,
                required String name,
                required String parentUuid,
                required String desc,
                Value<String?> damageDices = const Value.absent(),
                Value<String?> extraDamageDices = const Value.absent(),
                Value<int?> pm = const Value.absent(),
                Value<int?> cd = const Value.absent(),
                Value<String?> equipamentUuid = const Value.absent(),
                Value<int?> mediumDamageValue = const Value.absent(),
                Value<int?> critical = const Value.absent(),
                Value<int?> criticalMultiplier = const Value.absent(),
                required int typeIndex,
                required int createdAt,
                required int updatedAt,
                Value<int> rowid = const Value.absent(),
              }) => ActionDistanceAttackTableCompanion.insert(
                uuid: uuid,
                name: name,
                parentUuid: parentUuid,
                desc: desc,
                damageDices: damageDices,
                extraDamageDices: extraDamageDices,
                pm: pm,
                cd: cd,
                equipamentUuid: equipamentUuid,
                mediumDamageValue: mediumDamageValue,
                critical: critical,
                criticalMultiplier: criticalMultiplier,
                typeIndex: typeIndex,
                createdAt: createdAt,
                updatedAt: updatedAt,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ),
      );
}

typedef $$ActionDistanceAttackTableTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $ActionDistanceAttackTableTable,
      ActionDistanceAttackTableData,
      $$ActionDistanceAttackTableTableFilterComposer,
      $$ActionDistanceAttackTableTableOrderingComposer,
      $$ActionDistanceAttackTableTableAnnotationComposer,
      $$ActionDistanceAttackTableTableCreateCompanionBuilder,
      $$ActionDistanceAttackTableTableUpdateCompanionBuilder,
      (
        ActionDistanceAttackTableData,
        BaseReferences<
          _$AppDatabase,
          $ActionDistanceAttackTableTable,
          ActionDistanceAttackTableData
        >,
      ),
      ActionDistanceAttackTableData,
      PrefetchHooks Function()
    >;
typedef $$ExpertiseTableTableCreateCompanionBuilder =
    ExpertiseTableCompanion Function({
      required String uuid,
      required String name,
      required String parentUuid,
      required int id,
      required int atributeIndex,
      Value<int?> bonus,
      Value<int?> valueFinal,
      required bool isTrained,
      required int createdAt,
      required int updatedAt,
      Value<int> rowid,
    });
typedef $$ExpertiseTableTableUpdateCompanionBuilder =
    ExpertiseTableCompanion Function({
      Value<String> uuid,
      Value<String> name,
      Value<String> parentUuid,
      Value<int> id,
      Value<int> atributeIndex,
      Value<int?> bonus,
      Value<int?> valueFinal,
      Value<bool> isTrained,
      Value<int> createdAt,
      Value<int> updatedAt,
      Value<int> rowid,
    });

class $$ExpertiseTableTableFilterComposer
    extends Composer<_$AppDatabase, $ExpertiseTableTable> {
  $$ExpertiseTableTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get uuid => $composableBuilder(
    column: $table.uuid,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get parentUuid => $composableBuilder(
    column: $table.parentUuid,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get atributeIndex => $composableBuilder(
    column: $table.atributeIndex,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get bonus => $composableBuilder(
    column: $table.bonus,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get valueFinal => $composableBuilder(
    column: $table.valueFinal,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get isTrained => $composableBuilder(
    column: $table.isTrained,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnFilters(column),
  );
}

class $$ExpertiseTableTableOrderingComposer
    extends Composer<_$AppDatabase, $ExpertiseTableTable> {
  $$ExpertiseTableTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get uuid => $composableBuilder(
    column: $table.uuid,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get parentUuid => $composableBuilder(
    column: $table.parentUuid,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get atributeIndex => $composableBuilder(
    column: $table.atributeIndex,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get bonus => $composableBuilder(
    column: $table.bonus,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get valueFinal => $composableBuilder(
    column: $table.valueFinal,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get isTrained => $composableBuilder(
    column: $table.isTrained,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$ExpertiseTableTableAnnotationComposer
    extends Composer<_$AppDatabase, $ExpertiseTableTable> {
  $$ExpertiseTableTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get uuid =>
      $composableBuilder(column: $table.uuid, builder: (column) => column);

  GeneratedColumn<String> get name =>
      $composableBuilder(column: $table.name, builder: (column) => column);

  GeneratedColumn<String> get parentUuid => $composableBuilder(
    column: $table.parentUuid,
    builder: (column) => column,
  );

  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<int> get atributeIndex => $composableBuilder(
    column: $table.atributeIndex,
    builder: (column) => column,
  );

  GeneratedColumn<int> get bonus =>
      $composableBuilder(column: $table.bonus, builder: (column) => column);

  GeneratedColumn<int> get valueFinal => $composableBuilder(
    column: $table.valueFinal,
    builder: (column) => column,
  );

  GeneratedColumn<bool> get isTrained =>
      $composableBuilder(column: $table.isTrained, builder: (column) => column);

  GeneratedColumn<int> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<int> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);
}

class $$ExpertiseTableTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $ExpertiseTableTable,
          ExpertiseTableData,
          $$ExpertiseTableTableFilterComposer,
          $$ExpertiseTableTableOrderingComposer,
          $$ExpertiseTableTableAnnotationComposer,
          $$ExpertiseTableTableCreateCompanionBuilder,
          $$ExpertiseTableTableUpdateCompanionBuilder,
          (
            ExpertiseTableData,
            BaseReferences<
              _$AppDatabase,
              $ExpertiseTableTable,
              ExpertiseTableData
            >,
          ),
          ExpertiseTableData,
          PrefetchHooks Function()
        > {
  $$ExpertiseTableTableTableManager(
    _$AppDatabase db,
    $ExpertiseTableTable table,
  ) : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$ExpertiseTableTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$ExpertiseTableTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$ExpertiseTableTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> uuid = const Value.absent(),
                Value<String> name = const Value.absent(),
                Value<String> parentUuid = const Value.absent(),
                Value<int> id = const Value.absent(),
                Value<int> atributeIndex = const Value.absent(),
                Value<int?> bonus = const Value.absent(),
                Value<int?> valueFinal = const Value.absent(),
                Value<bool> isTrained = const Value.absent(),
                Value<int> createdAt = const Value.absent(),
                Value<int> updatedAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => ExpertiseTableCompanion(
                uuid: uuid,
                name: name,
                parentUuid: parentUuid,
                id: id,
                atributeIndex: atributeIndex,
                bonus: bonus,
                valueFinal: valueFinal,
                isTrained: isTrained,
                createdAt: createdAt,
                updatedAt: updatedAt,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String uuid,
                required String name,
                required String parentUuid,
                required int id,
                required int atributeIndex,
                Value<int?> bonus = const Value.absent(),
                Value<int?> valueFinal = const Value.absent(),
                required bool isTrained,
                required int createdAt,
                required int updatedAt,
                Value<int> rowid = const Value.absent(),
              }) => ExpertiseTableCompanion.insert(
                uuid: uuid,
                name: name,
                parentUuid: parentUuid,
                id: id,
                atributeIndex: atributeIndex,
                bonus: bonus,
                valueFinal: valueFinal,
                isTrained: isTrained,
                createdAt: createdAt,
                updatedAt: updatedAt,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ),
      );
}

typedef $$ExpertiseTableTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $ExpertiseTableTable,
      ExpertiseTableData,
      $$ExpertiseTableTableFilterComposer,
      $$ExpertiseTableTableOrderingComposer,
      $$ExpertiseTableTableAnnotationComposer,
      $$ExpertiseTableTableCreateCompanionBuilder,
      $$ExpertiseTableTableUpdateCompanionBuilder,
      (
        ExpertiseTableData,
        BaseReferences<_$AppDatabase, $ExpertiseTableTable, ExpertiseTableData>,
      ),
      ExpertiseTableData,
      PrefetchHooks Function()
    >;
typedef $$MenaceLinkBoardTableTableCreateCompanionBuilder =
    MenaceLinkBoardTableCompanion Function({
      required String uuid,
      required String menaceUuid,
      required String boardUuid,
      Value<int> rowid,
    });
typedef $$MenaceLinkBoardTableTableUpdateCompanionBuilder =
    MenaceLinkBoardTableCompanion Function({
      Value<String> uuid,
      Value<String> menaceUuid,
      Value<String> boardUuid,
      Value<int> rowid,
    });

class $$MenaceLinkBoardTableTableFilterComposer
    extends Composer<_$AppDatabase, $MenaceLinkBoardTableTable> {
  $$MenaceLinkBoardTableTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get uuid => $composableBuilder(
    column: $table.uuid,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get menaceUuid => $composableBuilder(
    column: $table.menaceUuid,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get boardUuid => $composableBuilder(
    column: $table.boardUuid,
    builder: (column) => ColumnFilters(column),
  );
}

class $$MenaceLinkBoardTableTableOrderingComposer
    extends Composer<_$AppDatabase, $MenaceLinkBoardTableTable> {
  $$MenaceLinkBoardTableTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get uuid => $composableBuilder(
    column: $table.uuid,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get menaceUuid => $composableBuilder(
    column: $table.menaceUuid,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get boardUuid => $composableBuilder(
    column: $table.boardUuid,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$MenaceLinkBoardTableTableAnnotationComposer
    extends Composer<_$AppDatabase, $MenaceLinkBoardTableTable> {
  $$MenaceLinkBoardTableTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get uuid =>
      $composableBuilder(column: $table.uuid, builder: (column) => column);

  GeneratedColumn<String> get menaceUuid => $composableBuilder(
    column: $table.menaceUuid,
    builder: (column) => column,
  );

  GeneratedColumn<String> get boardUuid =>
      $composableBuilder(column: $table.boardUuid, builder: (column) => column);
}

class $$MenaceLinkBoardTableTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $MenaceLinkBoardTableTable,
          MenaceLinkBoardTableData,
          $$MenaceLinkBoardTableTableFilterComposer,
          $$MenaceLinkBoardTableTableOrderingComposer,
          $$MenaceLinkBoardTableTableAnnotationComposer,
          $$MenaceLinkBoardTableTableCreateCompanionBuilder,
          $$MenaceLinkBoardTableTableUpdateCompanionBuilder,
          (
            MenaceLinkBoardTableData,
            BaseReferences<
              _$AppDatabase,
              $MenaceLinkBoardTableTable,
              MenaceLinkBoardTableData
            >,
          ),
          MenaceLinkBoardTableData,
          PrefetchHooks Function()
        > {
  $$MenaceLinkBoardTableTableTableManager(
    _$AppDatabase db,
    $MenaceLinkBoardTableTable table,
  ) : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$MenaceLinkBoardTableTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$MenaceLinkBoardTableTableOrderingComposer(
                $db: db,
                $table: table,
              ),
          createComputedFieldComposer: () =>
              $$MenaceLinkBoardTableTableAnnotationComposer(
                $db: db,
                $table: table,
              ),
          updateCompanionCallback:
              ({
                Value<String> uuid = const Value.absent(),
                Value<String> menaceUuid = const Value.absent(),
                Value<String> boardUuid = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => MenaceLinkBoardTableCompanion(
                uuid: uuid,
                menaceUuid: menaceUuid,
                boardUuid: boardUuid,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String uuid,
                required String menaceUuid,
                required String boardUuid,
                Value<int> rowid = const Value.absent(),
              }) => MenaceLinkBoardTableCompanion.insert(
                uuid: uuid,
                menaceUuid: menaceUuid,
                boardUuid: boardUuid,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ),
      );
}

typedef $$MenaceLinkBoardTableTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $MenaceLinkBoardTableTable,
      MenaceLinkBoardTableData,
      $$MenaceLinkBoardTableTableFilterComposer,
      $$MenaceLinkBoardTableTableOrderingComposer,
      $$MenaceLinkBoardTableTableAnnotationComposer,
      $$MenaceLinkBoardTableTableCreateCompanionBuilder,
      $$MenaceLinkBoardTableTableUpdateCompanionBuilder,
      (
        MenaceLinkBoardTableData,
        BaseReferences<
          _$AppDatabase,
          $MenaceLinkBoardTableTable,
          MenaceLinkBoardTableData
        >,
      ),
      MenaceLinkBoardTableData,
      PrefetchHooks Function()
    >;
typedef $$ConfigTableTableCreateCompanionBuilder =
    ConfigTableCompanion Function({
      Value<int> id,
      Value<int> modeIndex,
      Value<bool> showApresetation,
      Value<bool> enableBottomBackButton,
      Value<bool> enableHomeTipes,
    });
typedef $$ConfigTableTableUpdateCompanionBuilder =
    ConfigTableCompanion Function({
      Value<int> id,
      Value<int> modeIndex,
      Value<bool> showApresetation,
      Value<bool> enableBottomBackButton,
      Value<bool> enableHomeTipes,
    });

class $$ConfigTableTableFilterComposer
    extends Composer<_$AppDatabase, $ConfigTableTable> {
  $$ConfigTableTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get modeIndex => $composableBuilder(
    column: $table.modeIndex,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get showApresetation => $composableBuilder(
    column: $table.showApresetation,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get enableBottomBackButton => $composableBuilder(
    column: $table.enableBottomBackButton,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get enableHomeTipes => $composableBuilder(
    column: $table.enableHomeTipes,
    builder: (column) => ColumnFilters(column),
  );
}

class $$ConfigTableTableOrderingComposer
    extends Composer<_$AppDatabase, $ConfigTableTable> {
  $$ConfigTableTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get modeIndex => $composableBuilder(
    column: $table.modeIndex,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get showApresetation => $composableBuilder(
    column: $table.showApresetation,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get enableBottomBackButton => $composableBuilder(
    column: $table.enableBottomBackButton,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get enableHomeTipes => $composableBuilder(
    column: $table.enableHomeTipes,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$ConfigTableTableAnnotationComposer
    extends Composer<_$AppDatabase, $ConfigTableTable> {
  $$ConfigTableTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<int> get modeIndex =>
      $composableBuilder(column: $table.modeIndex, builder: (column) => column);

  GeneratedColumn<bool> get showApresetation => $composableBuilder(
    column: $table.showApresetation,
    builder: (column) => column,
  );

  GeneratedColumn<bool> get enableBottomBackButton => $composableBuilder(
    column: $table.enableBottomBackButton,
    builder: (column) => column,
  );

  GeneratedColumn<bool> get enableHomeTipes => $composableBuilder(
    column: $table.enableHomeTipes,
    builder: (column) => column,
  );
}

class $$ConfigTableTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $ConfigTableTable,
          ConfigTableData,
          $$ConfigTableTableFilterComposer,
          $$ConfigTableTableOrderingComposer,
          $$ConfigTableTableAnnotationComposer,
          $$ConfigTableTableCreateCompanionBuilder,
          $$ConfigTableTableUpdateCompanionBuilder,
          (
            ConfigTableData,
            BaseReferences<_$AppDatabase, $ConfigTableTable, ConfigTableData>,
          ),
          ConfigTableData,
          PrefetchHooks Function()
        > {
  $$ConfigTableTableTableManager(_$AppDatabase db, $ConfigTableTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$ConfigTableTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$ConfigTableTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$ConfigTableTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<int> id = const Value.absent(),
                Value<int> modeIndex = const Value.absent(),
                Value<bool> showApresetation = const Value.absent(),
                Value<bool> enableBottomBackButton = const Value.absent(),
                Value<bool> enableHomeTipes = const Value.absent(),
              }) => ConfigTableCompanion(
                id: id,
                modeIndex: modeIndex,
                showApresetation: showApresetation,
                enableBottomBackButton: enableBottomBackButton,
                enableHomeTipes: enableHomeTipes,
              ),
          createCompanionCallback:
              ({
                Value<int> id = const Value.absent(),
                Value<int> modeIndex = const Value.absent(),
                Value<bool> showApresetation = const Value.absent(),
                Value<bool> enableBottomBackButton = const Value.absent(),
                Value<bool> enableHomeTipes = const Value.absent(),
              }) => ConfigTableCompanion.insert(
                id: id,
                modeIndex: modeIndex,
                showApresetation: showApresetation,
                enableBottomBackButton: enableBottomBackButton,
                enableHomeTipes: enableHomeTipes,
              ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ),
      );
}

typedef $$ConfigTableTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $ConfigTableTable,
      ConfigTableData,
      $$ConfigTableTableFilterComposer,
      $$ConfigTableTableOrderingComposer,
      $$ConfigTableTableAnnotationComposer,
      $$ConfigTableTableCreateCompanionBuilder,
      $$ConfigTableTableUpdateCompanionBuilder,
      (
        ConfigTableData,
        BaseReferences<_$AppDatabase, $ConfigTableTable, ConfigTableData>,
      ),
      ConfigTableData,
      PrefetchHooks Function()
    >;
typedef $$CharacterTableTableCreateCompanionBuilder =
    CharacterTableCompanion Function({
      required String uuid,
      required String name,
      Value<String?> imagePath,
      Value<String?> imageAsset,
      Value<String?> displacement,
      Value<String?> senses,
      Value<int?> divinityId,
      required int defense,
      required int life,
      required int mana,
      required int strength,
      required int dexterity,
      required int constitution,
      required int intelligence,
      required int wisdom,
      required int charisma,
      required int creatureSizeIndex,
      required int broodIndex,
      Value<String?> grimoireUuid,
      required int createdAt,
      required int updatedAt,
      Value<String?> trainedExpertisesIndexes,
      required int aligmentIndex,
      Value<int> rowid,
    });
typedef $$CharacterTableTableUpdateCompanionBuilder =
    CharacterTableCompanion Function({
      Value<String> uuid,
      Value<String> name,
      Value<String?> imagePath,
      Value<String?> imageAsset,
      Value<String?> displacement,
      Value<String?> senses,
      Value<int?> divinityId,
      Value<int> defense,
      Value<int> life,
      Value<int> mana,
      Value<int> strength,
      Value<int> dexterity,
      Value<int> constitution,
      Value<int> intelligence,
      Value<int> wisdom,
      Value<int> charisma,
      Value<int> creatureSizeIndex,
      Value<int> broodIndex,
      Value<String?> grimoireUuid,
      Value<int> createdAt,
      Value<int> updatedAt,
      Value<String?> trainedExpertisesIndexes,
      Value<int> aligmentIndex,
      Value<int> rowid,
    });

class $$CharacterTableTableFilterComposer
    extends Composer<_$AppDatabase, $CharacterTableTable> {
  $$CharacterTableTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get uuid => $composableBuilder(
    column: $table.uuid,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get imagePath => $composableBuilder(
    column: $table.imagePath,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get imageAsset => $composableBuilder(
    column: $table.imageAsset,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get displacement => $composableBuilder(
    column: $table.displacement,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get senses => $composableBuilder(
    column: $table.senses,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get divinityId => $composableBuilder(
    column: $table.divinityId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get defense => $composableBuilder(
    column: $table.defense,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get life => $composableBuilder(
    column: $table.life,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get mana => $composableBuilder(
    column: $table.mana,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get strength => $composableBuilder(
    column: $table.strength,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get dexterity => $composableBuilder(
    column: $table.dexterity,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get constitution => $composableBuilder(
    column: $table.constitution,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get intelligence => $composableBuilder(
    column: $table.intelligence,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get wisdom => $composableBuilder(
    column: $table.wisdom,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get charisma => $composableBuilder(
    column: $table.charisma,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get creatureSizeIndex => $composableBuilder(
    column: $table.creatureSizeIndex,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get broodIndex => $composableBuilder(
    column: $table.broodIndex,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get grimoireUuid => $composableBuilder(
    column: $table.grimoireUuid,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get trainedExpertisesIndexes => $composableBuilder(
    column: $table.trainedExpertisesIndexes,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get aligmentIndex => $composableBuilder(
    column: $table.aligmentIndex,
    builder: (column) => ColumnFilters(column),
  );
}

class $$CharacterTableTableOrderingComposer
    extends Composer<_$AppDatabase, $CharacterTableTable> {
  $$CharacterTableTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get uuid => $composableBuilder(
    column: $table.uuid,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get imagePath => $composableBuilder(
    column: $table.imagePath,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get imageAsset => $composableBuilder(
    column: $table.imageAsset,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get displacement => $composableBuilder(
    column: $table.displacement,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get senses => $composableBuilder(
    column: $table.senses,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get divinityId => $composableBuilder(
    column: $table.divinityId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get defense => $composableBuilder(
    column: $table.defense,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get life => $composableBuilder(
    column: $table.life,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get mana => $composableBuilder(
    column: $table.mana,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get strength => $composableBuilder(
    column: $table.strength,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get dexterity => $composableBuilder(
    column: $table.dexterity,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get constitution => $composableBuilder(
    column: $table.constitution,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get intelligence => $composableBuilder(
    column: $table.intelligence,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get wisdom => $composableBuilder(
    column: $table.wisdom,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get charisma => $composableBuilder(
    column: $table.charisma,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get creatureSizeIndex => $composableBuilder(
    column: $table.creatureSizeIndex,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get broodIndex => $composableBuilder(
    column: $table.broodIndex,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get grimoireUuid => $composableBuilder(
    column: $table.grimoireUuid,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get trainedExpertisesIndexes => $composableBuilder(
    column: $table.trainedExpertisesIndexes,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get aligmentIndex => $composableBuilder(
    column: $table.aligmentIndex,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$CharacterTableTableAnnotationComposer
    extends Composer<_$AppDatabase, $CharacterTableTable> {
  $$CharacterTableTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get uuid =>
      $composableBuilder(column: $table.uuid, builder: (column) => column);

  GeneratedColumn<String> get name =>
      $composableBuilder(column: $table.name, builder: (column) => column);

  GeneratedColumn<String> get imagePath =>
      $composableBuilder(column: $table.imagePath, builder: (column) => column);

  GeneratedColumn<String> get imageAsset => $composableBuilder(
    column: $table.imageAsset,
    builder: (column) => column,
  );

  GeneratedColumn<String> get displacement => $composableBuilder(
    column: $table.displacement,
    builder: (column) => column,
  );

  GeneratedColumn<String> get senses =>
      $composableBuilder(column: $table.senses, builder: (column) => column);

  GeneratedColumn<int> get divinityId => $composableBuilder(
    column: $table.divinityId,
    builder: (column) => column,
  );

  GeneratedColumn<int> get defense =>
      $composableBuilder(column: $table.defense, builder: (column) => column);

  GeneratedColumn<int> get life =>
      $composableBuilder(column: $table.life, builder: (column) => column);

  GeneratedColumn<int> get mana =>
      $composableBuilder(column: $table.mana, builder: (column) => column);

  GeneratedColumn<int> get strength =>
      $composableBuilder(column: $table.strength, builder: (column) => column);

  GeneratedColumn<int> get dexterity =>
      $composableBuilder(column: $table.dexterity, builder: (column) => column);

  GeneratedColumn<int> get constitution => $composableBuilder(
    column: $table.constitution,
    builder: (column) => column,
  );

  GeneratedColumn<int> get intelligence => $composableBuilder(
    column: $table.intelligence,
    builder: (column) => column,
  );

  GeneratedColumn<int> get wisdom =>
      $composableBuilder(column: $table.wisdom, builder: (column) => column);

  GeneratedColumn<int> get charisma =>
      $composableBuilder(column: $table.charisma, builder: (column) => column);

  GeneratedColumn<int> get creatureSizeIndex => $composableBuilder(
    column: $table.creatureSizeIndex,
    builder: (column) => column,
  );

  GeneratedColumn<int> get broodIndex => $composableBuilder(
    column: $table.broodIndex,
    builder: (column) => column,
  );

  GeneratedColumn<String> get grimoireUuid => $composableBuilder(
    column: $table.grimoireUuid,
    builder: (column) => column,
  );

  GeneratedColumn<int> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<int> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);

  GeneratedColumn<String> get trainedExpertisesIndexes => $composableBuilder(
    column: $table.trainedExpertisesIndexes,
    builder: (column) => column,
  );

  GeneratedColumn<int> get aligmentIndex => $composableBuilder(
    column: $table.aligmentIndex,
    builder: (column) => column,
  );
}

class $$CharacterTableTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $CharacterTableTable,
          CharacterTableData,
          $$CharacterTableTableFilterComposer,
          $$CharacterTableTableOrderingComposer,
          $$CharacterTableTableAnnotationComposer,
          $$CharacterTableTableCreateCompanionBuilder,
          $$CharacterTableTableUpdateCompanionBuilder,
          (
            CharacterTableData,
            BaseReferences<
              _$AppDatabase,
              $CharacterTableTable,
              CharacterTableData
            >,
          ),
          CharacterTableData,
          PrefetchHooks Function()
        > {
  $$CharacterTableTableTableManager(
    _$AppDatabase db,
    $CharacterTableTable table,
  ) : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$CharacterTableTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$CharacterTableTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$CharacterTableTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> uuid = const Value.absent(),
                Value<String> name = const Value.absent(),
                Value<String?> imagePath = const Value.absent(),
                Value<String?> imageAsset = const Value.absent(),
                Value<String?> displacement = const Value.absent(),
                Value<String?> senses = const Value.absent(),
                Value<int?> divinityId = const Value.absent(),
                Value<int> defense = const Value.absent(),
                Value<int> life = const Value.absent(),
                Value<int> mana = const Value.absent(),
                Value<int> strength = const Value.absent(),
                Value<int> dexterity = const Value.absent(),
                Value<int> constitution = const Value.absent(),
                Value<int> intelligence = const Value.absent(),
                Value<int> wisdom = const Value.absent(),
                Value<int> charisma = const Value.absent(),
                Value<int> creatureSizeIndex = const Value.absent(),
                Value<int> broodIndex = const Value.absent(),
                Value<String?> grimoireUuid = const Value.absent(),
                Value<int> createdAt = const Value.absent(),
                Value<int> updatedAt = const Value.absent(),
                Value<String?> trainedExpertisesIndexes = const Value.absent(),
                Value<int> aligmentIndex = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => CharacterTableCompanion(
                uuid: uuid,
                name: name,
                imagePath: imagePath,
                imageAsset: imageAsset,
                displacement: displacement,
                senses: senses,
                divinityId: divinityId,
                defense: defense,
                life: life,
                mana: mana,
                strength: strength,
                dexterity: dexterity,
                constitution: constitution,
                intelligence: intelligence,
                wisdom: wisdom,
                charisma: charisma,
                creatureSizeIndex: creatureSizeIndex,
                broodIndex: broodIndex,
                grimoireUuid: grimoireUuid,
                createdAt: createdAt,
                updatedAt: updatedAt,
                trainedExpertisesIndexes: trainedExpertisesIndexes,
                aligmentIndex: aligmentIndex,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String uuid,
                required String name,
                Value<String?> imagePath = const Value.absent(),
                Value<String?> imageAsset = const Value.absent(),
                Value<String?> displacement = const Value.absent(),
                Value<String?> senses = const Value.absent(),
                Value<int?> divinityId = const Value.absent(),
                required int defense,
                required int life,
                required int mana,
                required int strength,
                required int dexterity,
                required int constitution,
                required int intelligence,
                required int wisdom,
                required int charisma,
                required int creatureSizeIndex,
                required int broodIndex,
                Value<String?> grimoireUuid = const Value.absent(),
                required int createdAt,
                required int updatedAt,
                Value<String?> trainedExpertisesIndexes = const Value.absent(),
                required int aligmentIndex,
                Value<int> rowid = const Value.absent(),
              }) => CharacterTableCompanion.insert(
                uuid: uuid,
                name: name,
                imagePath: imagePath,
                imageAsset: imageAsset,
                displacement: displacement,
                senses: senses,
                divinityId: divinityId,
                defense: defense,
                life: life,
                mana: mana,
                strength: strength,
                dexterity: dexterity,
                constitution: constitution,
                intelligence: intelligence,
                wisdom: wisdom,
                charisma: charisma,
                creatureSizeIndex: creatureSizeIndex,
                broodIndex: broodIndex,
                grimoireUuid: grimoireUuid,
                createdAt: createdAt,
                updatedAt: updatedAt,
                trainedExpertisesIndexes: trainedExpertisesIndexes,
                aligmentIndex: aligmentIndex,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ),
      );
}

typedef $$CharacterTableTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $CharacterTableTable,
      CharacterTableData,
      $$CharacterTableTableFilterComposer,
      $$CharacterTableTableOrderingComposer,
      $$CharacterTableTableAnnotationComposer,
      $$CharacterTableTableCreateCompanionBuilder,
      $$CharacterTableTableUpdateCompanionBuilder,
      (
        CharacterTableData,
        BaseReferences<_$AppDatabase, $CharacterTableTable, CharacterTableData>,
      ),
      CharacterTableData,
      PrefetchHooks Function()
    >;
typedef $$ClasseCharacterTableTableCreateCompanionBuilder =
    ClasseCharacterTableCompanion Function({
      required String uuid,
      required String characterUuid,
      required int typeIndex,
      required int level,
      Value<int> rowid,
    });
typedef $$ClasseCharacterTableTableUpdateCompanionBuilder =
    ClasseCharacterTableCompanion Function({
      Value<String> uuid,
      Value<String> characterUuid,
      Value<int> typeIndex,
      Value<int> level,
      Value<int> rowid,
    });

class $$ClasseCharacterTableTableFilterComposer
    extends Composer<_$AppDatabase, $ClasseCharacterTableTable> {
  $$ClasseCharacterTableTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get uuid => $composableBuilder(
    column: $table.uuid,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get characterUuid => $composableBuilder(
    column: $table.characterUuid,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get typeIndex => $composableBuilder(
    column: $table.typeIndex,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get level => $composableBuilder(
    column: $table.level,
    builder: (column) => ColumnFilters(column),
  );
}

class $$ClasseCharacterTableTableOrderingComposer
    extends Composer<_$AppDatabase, $ClasseCharacterTableTable> {
  $$ClasseCharacterTableTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get uuid => $composableBuilder(
    column: $table.uuid,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get characterUuid => $composableBuilder(
    column: $table.characterUuid,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get typeIndex => $composableBuilder(
    column: $table.typeIndex,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get level => $composableBuilder(
    column: $table.level,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$ClasseCharacterTableTableAnnotationComposer
    extends Composer<_$AppDatabase, $ClasseCharacterTableTable> {
  $$ClasseCharacterTableTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get uuid =>
      $composableBuilder(column: $table.uuid, builder: (column) => column);

  GeneratedColumn<String> get characterUuid => $composableBuilder(
    column: $table.characterUuid,
    builder: (column) => column,
  );

  GeneratedColumn<int> get typeIndex =>
      $composableBuilder(column: $table.typeIndex, builder: (column) => column);

  GeneratedColumn<int> get level =>
      $composableBuilder(column: $table.level, builder: (column) => column);
}

class $$ClasseCharacterTableTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $ClasseCharacterTableTable,
          ClasseCharacterTableData,
          $$ClasseCharacterTableTableFilterComposer,
          $$ClasseCharacterTableTableOrderingComposer,
          $$ClasseCharacterTableTableAnnotationComposer,
          $$ClasseCharacterTableTableCreateCompanionBuilder,
          $$ClasseCharacterTableTableUpdateCompanionBuilder,
          (
            ClasseCharacterTableData,
            BaseReferences<
              _$AppDatabase,
              $ClasseCharacterTableTable,
              ClasseCharacterTableData
            >,
          ),
          ClasseCharacterTableData,
          PrefetchHooks Function()
        > {
  $$ClasseCharacterTableTableTableManager(
    _$AppDatabase db,
    $ClasseCharacterTableTable table,
  ) : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$ClasseCharacterTableTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$ClasseCharacterTableTableOrderingComposer(
                $db: db,
                $table: table,
              ),
          createComputedFieldComposer: () =>
              $$ClasseCharacterTableTableAnnotationComposer(
                $db: db,
                $table: table,
              ),
          updateCompanionCallback:
              ({
                Value<String> uuid = const Value.absent(),
                Value<String> characterUuid = const Value.absent(),
                Value<int> typeIndex = const Value.absent(),
                Value<int> level = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => ClasseCharacterTableCompanion(
                uuid: uuid,
                characterUuid: characterUuid,
                typeIndex: typeIndex,
                level: level,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String uuid,
                required String characterUuid,
                required int typeIndex,
                required int level,
                Value<int> rowid = const Value.absent(),
              }) => ClasseCharacterTableCompanion.insert(
                uuid: uuid,
                characterUuid: characterUuid,
                typeIndex: typeIndex,
                level: level,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ),
      );
}

typedef $$ClasseCharacterTableTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $ClasseCharacterTableTable,
      ClasseCharacterTableData,
      $$ClasseCharacterTableTableFilterComposer,
      $$ClasseCharacterTableTableOrderingComposer,
      $$ClasseCharacterTableTableAnnotationComposer,
      $$ClasseCharacterTableTableCreateCompanionBuilder,
      $$ClasseCharacterTableTableUpdateCompanionBuilder,
      (
        ClasseCharacterTableData,
        BaseReferences<
          _$AppDatabase,
          $ClasseCharacterTableTable,
          ClasseCharacterTableData
        >,
      ),
      ClasseCharacterTableData,
      PrefetchHooks Function()
    >;
typedef $$OriginTableTableCreateCompanionBuilder =
    OriginTableCompanion Function({
      required String uuid,
      required String characterUuid,
      required String name,
      required String desc,
      required int createdAt,
      required int updatedAt,
      Value<int> rowid,
    });
typedef $$OriginTableTableUpdateCompanionBuilder =
    OriginTableCompanion Function({
      Value<String> uuid,
      Value<String> characterUuid,
      Value<String> name,
      Value<String> desc,
      Value<int> createdAt,
      Value<int> updatedAt,
      Value<int> rowid,
    });

class $$OriginTableTableFilterComposer
    extends Composer<_$AppDatabase, $OriginTableTable> {
  $$OriginTableTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get uuid => $composableBuilder(
    column: $table.uuid,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get characterUuid => $composableBuilder(
    column: $table.characterUuid,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get desc => $composableBuilder(
    column: $table.desc,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnFilters(column),
  );
}

class $$OriginTableTableOrderingComposer
    extends Composer<_$AppDatabase, $OriginTableTable> {
  $$OriginTableTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get uuid => $composableBuilder(
    column: $table.uuid,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get characterUuid => $composableBuilder(
    column: $table.characterUuid,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get desc => $composableBuilder(
    column: $table.desc,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$OriginTableTableAnnotationComposer
    extends Composer<_$AppDatabase, $OriginTableTable> {
  $$OriginTableTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get uuid =>
      $composableBuilder(column: $table.uuid, builder: (column) => column);

  GeneratedColumn<String> get characterUuid => $composableBuilder(
    column: $table.characterUuid,
    builder: (column) => column,
  );

  GeneratedColumn<String> get name =>
      $composableBuilder(column: $table.name, builder: (column) => column);

  GeneratedColumn<String> get desc =>
      $composableBuilder(column: $table.desc, builder: (column) => column);

  GeneratedColumn<int> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<int> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);
}

class $$OriginTableTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $OriginTableTable,
          OriginTableData,
          $$OriginTableTableFilterComposer,
          $$OriginTableTableOrderingComposer,
          $$OriginTableTableAnnotationComposer,
          $$OriginTableTableCreateCompanionBuilder,
          $$OriginTableTableUpdateCompanionBuilder,
          (
            OriginTableData,
            BaseReferences<_$AppDatabase, $OriginTableTable, OriginTableData>,
          ),
          OriginTableData,
          PrefetchHooks Function()
        > {
  $$OriginTableTableTableManager(_$AppDatabase db, $OriginTableTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$OriginTableTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$OriginTableTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$OriginTableTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> uuid = const Value.absent(),
                Value<String> characterUuid = const Value.absent(),
                Value<String> name = const Value.absent(),
                Value<String> desc = const Value.absent(),
                Value<int> createdAt = const Value.absent(),
                Value<int> updatedAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => OriginTableCompanion(
                uuid: uuid,
                characterUuid: characterUuid,
                name: name,
                desc: desc,
                createdAt: createdAt,
                updatedAt: updatedAt,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String uuid,
                required String characterUuid,
                required String name,
                required String desc,
                required int createdAt,
                required int updatedAt,
                Value<int> rowid = const Value.absent(),
              }) => OriginTableCompanion.insert(
                uuid: uuid,
                characterUuid: characterUuid,
                name: name,
                desc: desc,
                createdAt: createdAt,
                updatedAt: updatedAt,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ),
      );
}

typedef $$OriginTableTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $OriginTableTable,
      OriginTableData,
      $$OriginTableTableFilterComposer,
      $$OriginTableTableOrderingComposer,
      $$OriginTableTableAnnotationComposer,
      $$OriginTableTableCreateCompanionBuilder,
      $$OriginTableTableUpdateCompanionBuilder,
      (
        OriginTableData,
        BaseReferences<_$AppDatabase, $OriginTableTable, OriginTableData>,
      ),
      OriginTableData,
      PrefetchHooks Function()
    >;
typedef $$PowerTableTableCreateCompanionBuilder =
    PowerTableCompanion Function({
      required String uuid,
      required String name,
      required String desc,
      required String characterUuid,
      required int typeIndex,
      required int createdAt,
      required int updatedAt,
      Value<int> rowid,
    });
typedef $$PowerTableTableUpdateCompanionBuilder =
    PowerTableCompanion Function({
      Value<String> uuid,
      Value<String> name,
      Value<String> desc,
      Value<String> characterUuid,
      Value<int> typeIndex,
      Value<int> createdAt,
      Value<int> updatedAt,
      Value<int> rowid,
    });

class $$PowerTableTableFilterComposer
    extends Composer<_$AppDatabase, $PowerTableTable> {
  $$PowerTableTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get uuid => $composableBuilder(
    column: $table.uuid,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get desc => $composableBuilder(
    column: $table.desc,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get characterUuid => $composableBuilder(
    column: $table.characterUuid,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get typeIndex => $composableBuilder(
    column: $table.typeIndex,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnFilters(column),
  );
}

class $$PowerTableTableOrderingComposer
    extends Composer<_$AppDatabase, $PowerTableTable> {
  $$PowerTableTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get uuid => $composableBuilder(
    column: $table.uuid,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get desc => $composableBuilder(
    column: $table.desc,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get characterUuid => $composableBuilder(
    column: $table.characterUuid,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get typeIndex => $composableBuilder(
    column: $table.typeIndex,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$PowerTableTableAnnotationComposer
    extends Composer<_$AppDatabase, $PowerTableTable> {
  $$PowerTableTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get uuid =>
      $composableBuilder(column: $table.uuid, builder: (column) => column);

  GeneratedColumn<String> get name =>
      $composableBuilder(column: $table.name, builder: (column) => column);

  GeneratedColumn<String> get desc =>
      $composableBuilder(column: $table.desc, builder: (column) => column);

  GeneratedColumn<String> get characterUuid => $composableBuilder(
    column: $table.characterUuid,
    builder: (column) => column,
  );

  GeneratedColumn<int> get typeIndex =>
      $composableBuilder(column: $table.typeIndex, builder: (column) => column);

  GeneratedColumn<int> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<int> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);
}

class $$PowerTableTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $PowerTableTable,
          PowerTableData,
          $$PowerTableTableFilterComposer,
          $$PowerTableTableOrderingComposer,
          $$PowerTableTableAnnotationComposer,
          $$PowerTableTableCreateCompanionBuilder,
          $$PowerTableTableUpdateCompanionBuilder,
          (
            PowerTableData,
            BaseReferences<_$AppDatabase, $PowerTableTable, PowerTableData>,
          ),
          PowerTableData,
          PrefetchHooks Function()
        > {
  $$PowerTableTableTableManager(_$AppDatabase db, $PowerTableTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$PowerTableTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$PowerTableTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$PowerTableTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> uuid = const Value.absent(),
                Value<String> name = const Value.absent(),
                Value<String> desc = const Value.absent(),
                Value<String> characterUuid = const Value.absent(),
                Value<int> typeIndex = const Value.absent(),
                Value<int> createdAt = const Value.absent(),
                Value<int> updatedAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => PowerTableCompanion(
                uuid: uuid,
                name: name,
                desc: desc,
                characterUuid: characterUuid,
                typeIndex: typeIndex,
                createdAt: createdAt,
                updatedAt: updatedAt,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String uuid,
                required String name,
                required String desc,
                required String characterUuid,
                required int typeIndex,
                required int createdAt,
                required int updatedAt,
                Value<int> rowid = const Value.absent(),
              }) => PowerTableCompanion.insert(
                uuid: uuid,
                name: name,
                desc: desc,
                characterUuid: characterUuid,
                typeIndex: typeIndex,
                createdAt: createdAt,
                updatedAt: updatedAt,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ),
      );
}

typedef $$PowerTableTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $PowerTableTable,
      PowerTableData,
      $$PowerTableTableFilterComposer,
      $$PowerTableTableOrderingComposer,
      $$PowerTableTableAnnotationComposer,
      $$PowerTableTableCreateCompanionBuilder,
      $$PowerTableTableUpdateCompanionBuilder,
      (
        PowerTableData,
        BaseReferences<_$AppDatabase, $PowerTableTable, PowerTableData>,
      ),
      PowerTableData,
      PrefetchHooks Function()
    >;
typedef $$CharacterBoardTableTableCreateCompanionBuilder =
    CharacterBoardTableCompanion Function({
      required String uuid,
      required String parentuuid,
      required String boarduuid,
      required String name,
      Value<String?> imagePath,
      Value<String?> imageAsset,
      Value<String?> displacement,
      Value<String?> senses,
      Value<int?> divinityId,
      required int defense,
      required int life,
      required int mana,
      required int strength,
      required int dexterity,
      required int constitution,
      required int intelligence,
      required int wisdom,
      required int charisma,
      required int creatureSizeIndex,
      required int broodIndex,
      Value<String?> grimoireUuid,
      required int createdAt,
      required int updatedAt,
      required bool isAlive,
      required int aligmentIndex,
      required int currentLife,
      required int currentMana,
      Value<String?> inLeftHand,
      Value<String?> inRightHand,
      Value<String?> inTwoHands,
      Value<String?> inWearableSlots,
      Value<int?> handToHandAtributeIndex,
      Value<int> rowid,
    });
typedef $$CharacterBoardTableTableUpdateCompanionBuilder =
    CharacterBoardTableCompanion Function({
      Value<String> uuid,
      Value<String> parentuuid,
      Value<String> boarduuid,
      Value<String> name,
      Value<String?> imagePath,
      Value<String?> imageAsset,
      Value<String?> displacement,
      Value<String?> senses,
      Value<int?> divinityId,
      Value<int> defense,
      Value<int> life,
      Value<int> mana,
      Value<int> strength,
      Value<int> dexterity,
      Value<int> constitution,
      Value<int> intelligence,
      Value<int> wisdom,
      Value<int> charisma,
      Value<int> creatureSizeIndex,
      Value<int> broodIndex,
      Value<String?> grimoireUuid,
      Value<int> createdAt,
      Value<int> updatedAt,
      Value<bool> isAlive,
      Value<int> aligmentIndex,
      Value<int> currentLife,
      Value<int> currentMana,
      Value<String?> inLeftHand,
      Value<String?> inRightHand,
      Value<String?> inTwoHands,
      Value<String?> inWearableSlots,
      Value<int?> handToHandAtributeIndex,
      Value<int> rowid,
    });

class $$CharacterBoardTableTableFilterComposer
    extends Composer<_$AppDatabase, $CharacterBoardTableTable> {
  $$CharacterBoardTableTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get uuid => $composableBuilder(
    column: $table.uuid,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get parentuuid => $composableBuilder(
    column: $table.parentuuid,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get boarduuid => $composableBuilder(
    column: $table.boarduuid,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get imagePath => $composableBuilder(
    column: $table.imagePath,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get imageAsset => $composableBuilder(
    column: $table.imageAsset,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get displacement => $composableBuilder(
    column: $table.displacement,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get senses => $composableBuilder(
    column: $table.senses,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get divinityId => $composableBuilder(
    column: $table.divinityId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get defense => $composableBuilder(
    column: $table.defense,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get life => $composableBuilder(
    column: $table.life,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get mana => $composableBuilder(
    column: $table.mana,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get strength => $composableBuilder(
    column: $table.strength,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get dexterity => $composableBuilder(
    column: $table.dexterity,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get constitution => $composableBuilder(
    column: $table.constitution,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get intelligence => $composableBuilder(
    column: $table.intelligence,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get wisdom => $composableBuilder(
    column: $table.wisdom,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get charisma => $composableBuilder(
    column: $table.charisma,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get creatureSizeIndex => $composableBuilder(
    column: $table.creatureSizeIndex,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get broodIndex => $composableBuilder(
    column: $table.broodIndex,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get grimoireUuid => $composableBuilder(
    column: $table.grimoireUuid,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get isAlive => $composableBuilder(
    column: $table.isAlive,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get aligmentIndex => $composableBuilder(
    column: $table.aligmentIndex,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get currentLife => $composableBuilder(
    column: $table.currentLife,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get currentMana => $composableBuilder(
    column: $table.currentMana,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get inLeftHand => $composableBuilder(
    column: $table.inLeftHand,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get inRightHand => $composableBuilder(
    column: $table.inRightHand,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get inTwoHands => $composableBuilder(
    column: $table.inTwoHands,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get inWearableSlots => $composableBuilder(
    column: $table.inWearableSlots,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get handToHandAtributeIndex => $composableBuilder(
    column: $table.handToHandAtributeIndex,
    builder: (column) => ColumnFilters(column),
  );
}

class $$CharacterBoardTableTableOrderingComposer
    extends Composer<_$AppDatabase, $CharacterBoardTableTable> {
  $$CharacterBoardTableTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get uuid => $composableBuilder(
    column: $table.uuid,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get parentuuid => $composableBuilder(
    column: $table.parentuuid,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get boarduuid => $composableBuilder(
    column: $table.boarduuid,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get imagePath => $composableBuilder(
    column: $table.imagePath,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get imageAsset => $composableBuilder(
    column: $table.imageAsset,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get displacement => $composableBuilder(
    column: $table.displacement,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get senses => $composableBuilder(
    column: $table.senses,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get divinityId => $composableBuilder(
    column: $table.divinityId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get defense => $composableBuilder(
    column: $table.defense,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get life => $composableBuilder(
    column: $table.life,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get mana => $composableBuilder(
    column: $table.mana,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get strength => $composableBuilder(
    column: $table.strength,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get dexterity => $composableBuilder(
    column: $table.dexterity,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get constitution => $composableBuilder(
    column: $table.constitution,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get intelligence => $composableBuilder(
    column: $table.intelligence,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get wisdom => $composableBuilder(
    column: $table.wisdom,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get charisma => $composableBuilder(
    column: $table.charisma,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get creatureSizeIndex => $composableBuilder(
    column: $table.creatureSizeIndex,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get broodIndex => $composableBuilder(
    column: $table.broodIndex,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get grimoireUuid => $composableBuilder(
    column: $table.grimoireUuid,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get isAlive => $composableBuilder(
    column: $table.isAlive,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get aligmentIndex => $composableBuilder(
    column: $table.aligmentIndex,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get currentLife => $composableBuilder(
    column: $table.currentLife,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get currentMana => $composableBuilder(
    column: $table.currentMana,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get inLeftHand => $composableBuilder(
    column: $table.inLeftHand,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get inRightHand => $composableBuilder(
    column: $table.inRightHand,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get inTwoHands => $composableBuilder(
    column: $table.inTwoHands,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get inWearableSlots => $composableBuilder(
    column: $table.inWearableSlots,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get handToHandAtributeIndex => $composableBuilder(
    column: $table.handToHandAtributeIndex,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$CharacterBoardTableTableAnnotationComposer
    extends Composer<_$AppDatabase, $CharacterBoardTableTable> {
  $$CharacterBoardTableTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get uuid =>
      $composableBuilder(column: $table.uuid, builder: (column) => column);

  GeneratedColumn<String> get parentuuid => $composableBuilder(
    column: $table.parentuuid,
    builder: (column) => column,
  );

  GeneratedColumn<String> get boarduuid =>
      $composableBuilder(column: $table.boarduuid, builder: (column) => column);

  GeneratedColumn<String> get name =>
      $composableBuilder(column: $table.name, builder: (column) => column);

  GeneratedColumn<String> get imagePath =>
      $composableBuilder(column: $table.imagePath, builder: (column) => column);

  GeneratedColumn<String> get imageAsset => $composableBuilder(
    column: $table.imageAsset,
    builder: (column) => column,
  );

  GeneratedColumn<String> get displacement => $composableBuilder(
    column: $table.displacement,
    builder: (column) => column,
  );

  GeneratedColumn<String> get senses =>
      $composableBuilder(column: $table.senses, builder: (column) => column);

  GeneratedColumn<int> get divinityId => $composableBuilder(
    column: $table.divinityId,
    builder: (column) => column,
  );

  GeneratedColumn<int> get defense =>
      $composableBuilder(column: $table.defense, builder: (column) => column);

  GeneratedColumn<int> get life =>
      $composableBuilder(column: $table.life, builder: (column) => column);

  GeneratedColumn<int> get mana =>
      $composableBuilder(column: $table.mana, builder: (column) => column);

  GeneratedColumn<int> get strength =>
      $composableBuilder(column: $table.strength, builder: (column) => column);

  GeneratedColumn<int> get dexterity =>
      $composableBuilder(column: $table.dexterity, builder: (column) => column);

  GeneratedColumn<int> get constitution => $composableBuilder(
    column: $table.constitution,
    builder: (column) => column,
  );

  GeneratedColumn<int> get intelligence => $composableBuilder(
    column: $table.intelligence,
    builder: (column) => column,
  );

  GeneratedColumn<int> get wisdom =>
      $composableBuilder(column: $table.wisdom, builder: (column) => column);

  GeneratedColumn<int> get charisma =>
      $composableBuilder(column: $table.charisma, builder: (column) => column);

  GeneratedColumn<int> get creatureSizeIndex => $composableBuilder(
    column: $table.creatureSizeIndex,
    builder: (column) => column,
  );

  GeneratedColumn<int> get broodIndex => $composableBuilder(
    column: $table.broodIndex,
    builder: (column) => column,
  );

  GeneratedColumn<String> get grimoireUuid => $composableBuilder(
    column: $table.grimoireUuid,
    builder: (column) => column,
  );

  GeneratedColumn<int> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<int> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);

  GeneratedColumn<bool> get isAlive =>
      $composableBuilder(column: $table.isAlive, builder: (column) => column);

  GeneratedColumn<int> get aligmentIndex => $composableBuilder(
    column: $table.aligmentIndex,
    builder: (column) => column,
  );

  GeneratedColumn<int> get currentLife => $composableBuilder(
    column: $table.currentLife,
    builder: (column) => column,
  );

  GeneratedColumn<int> get currentMana => $composableBuilder(
    column: $table.currentMana,
    builder: (column) => column,
  );

  GeneratedColumn<String> get inLeftHand => $composableBuilder(
    column: $table.inLeftHand,
    builder: (column) => column,
  );

  GeneratedColumn<String> get inRightHand => $composableBuilder(
    column: $table.inRightHand,
    builder: (column) => column,
  );

  GeneratedColumn<String> get inTwoHands => $composableBuilder(
    column: $table.inTwoHands,
    builder: (column) => column,
  );

  GeneratedColumn<String> get inWearableSlots => $composableBuilder(
    column: $table.inWearableSlots,
    builder: (column) => column,
  );

  GeneratedColumn<int> get handToHandAtributeIndex => $composableBuilder(
    column: $table.handToHandAtributeIndex,
    builder: (column) => column,
  );
}

class $$CharacterBoardTableTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $CharacterBoardTableTable,
          CharacterBoardTableData,
          $$CharacterBoardTableTableFilterComposer,
          $$CharacterBoardTableTableOrderingComposer,
          $$CharacterBoardTableTableAnnotationComposer,
          $$CharacterBoardTableTableCreateCompanionBuilder,
          $$CharacterBoardTableTableUpdateCompanionBuilder,
          (
            CharacterBoardTableData,
            BaseReferences<
              _$AppDatabase,
              $CharacterBoardTableTable,
              CharacterBoardTableData
            >,
          ),
          CharacterBoardTableData,
          PrefetchHooks Function()
        > {
  $$CharacterBoardTableTableTableManager(
    _$AppDatabase db,
    $CharacterBoardTableTable table,
  ) : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$CharacterBoardTableTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$CharacterBoardTableTableOrderingComposer(
                $db: db,
                $table: table,
              ),
          createComputedFieldComposer: () =>
              $$CharacterBoardTableTableAnnotationComposer(
                $db: db,
                $table: table,
              ),
          updateCompanionCallback:
              ({
                Value<String> uuid = const Value.absent(),
                Value<String> parentuuid = const Value.absent(),
                Value<String> boarduuid = const Value.absent(),
                Value<String> name = const Value.absent(),
                Value<String?> imagePath = const Value.absent(),
                Value<String?> imageAsset = const Value.absent(),
                Value<String?> displacement = const Value.absent(),
                Value<String?> senses = const Value.absent(),
                Value<int?> divinityId = const Value.absent(),
                Value<int> defense = const Value.absent(),
                Value<int> life = const Value.absent(),
                Value<int> mana = const Value.absent(),
                Value<int> strength = const Value.absent(),
                Value<int> dexterity = const Value.absent(),
                Value<int> constitution = const Value.absent(),
                Value<int> intelligence = const Value.absent(),
                Value<int> wisdom = const Value.absent(),
                Value<int> charisma = const Value.absent(),
                Value<int> creatureSizeIndex = const Value.absent(),
                Value<int> broodIndex = const Value.absent(),
                Value<String?> grimoireUuid = const Value.absent(),
                Value<int> createdAt = const Value.absent(),
                Value<int> updatedAt = const Value.absent(),
                Value<bool> isAlive = const Value.absent(),
                Value<int> aligmentIndex = const Value.absent(),
                Value<int> currentLife = const Value.absent(),
                Value<int> currentMana = const Value.absent(),
                Value<String?> inLeftHand = const Value.absent(),
                Value<String?> inRightHand = const Value.absent(),
                Value<String?> inTwoHands = const Value.absent(),
                Value<String?> inWearableSlots = const Value.absent(),
                Value<int?> handToHandAtributeIndex = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => CharacterBoardTableCompanion(
                uuid: uuid,
                parentuuid: parentuuid,
                boarduuid: boarduuid,
                name: name,
                imagePath: imagePath,
                imageAsset: imageAsset,
                displacement: displacement,
                senses: senses,
                divinityId: divinityId,
                defense: defense,
                life: life,
                mana: mana,
                strength: strength,
                dexterity: dexterity,
                constitution: constitution,
                intelligence: intelligence,
                wisdom: wisdom,
                charisma: charisma,
                creatureSizeIndex: creatureSizeIndex,
                broodIndex: broodIndex,
                grimoireUuid: grimoireUuid,
                createdAt: createdAt,
                updatedAt: updatedAt,
                isAlive: isAlive,
                aligmentIndex: aligmentIndex,
                currentLife: currentLife,
                currentMana: currentMana,
                inLeftHand: inLeftHand,
                inRightHand: inRightHand,
                inTwoHands: inTwoHands,
                inWearableSlots: inWearableSlots,
                handToHandAtributeIndex: handToHandAtributeIndex,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String uuid,
                required String parentuuid,
                required String boarduuid,
                required String name,
                Value<String?> imagePath = const Value.absent(),
                Value<String?> imageAsset = const Value.absent(),
                Value<String?> displacement = const Value.absent(),
                Value<String?> senses = const Value.absent(),
                Value<int?> divinityId = const Value.absent(),
                required int defense,
                required int life,
                required int mana,
                required int strength,
                required int dexterity,
                required int constitution,
                required int intelligence,
                required int wisdom,
                required int charisma,
                required int creatureSizeIndex,
                required int broodIndex,
                Value<String?> grimoireUuid = const Value.absent(),
                required int createdAt,
                required int updatedAt,
                required bool isAlive,
                required int aligmentIndex,
                required int currentLife,
                required int currentMana,
                Value<String?> inLeftHand = const Value.absent(),
                Value<String?> inRightHand = const Value.absent(),
                Value<String?> inTwoHands = const Value.absent(),
                Value<String?> inWearableSlots = const Value.absent(),
                Value<int?> handToHandAtributeIndex = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => CharacterBoardTableCompanion.insert(
                uuid: uuid,
                parentuuid: parentuuid,
                boarduuid: boarduuid,
                name: name,
                imagePath: imagePath,
                imageAsset: imageAsset,
                displacement: displacement,
                senses: senses,
                divinityId: divinityId,
                defense: defense,
                life: life,
                mana: mana,
                strength: strength,
                dexterity: dexterity,
                constitution: constitution,
                intelligence: intelligence,
                wisdom: wisdom,
                charisma: charisma,
                creatureSizeIndex: creatureSizeIndex,
                broodIndex: broodIndex,
                grimoireUuid: grimoireUuid,
                createdAt: createdAt,
                updatedAt: updatedAt,
                isAlive: isAlive,
                aligmentIndex: aligmentIndex,
                currentLife: currentLife,
                currentMana: currentMana,
                inLeftHand: inLeftHand,
                inRightHand: inRightHand,
                inTwoHands: inTwoHands,
                inWearableSlots: inWearableSlots,
                handToHandAtributeIndex: handToHandAtributeIndex,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ),
      );
}

typedef $$CharacterBoardTableTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $CharacterBoardTableTable,
      CharacterBoardTableData,
      $$CharacterBoardTableTableFilterComposer,
      $$CharacterBoardTableTableOrderingComposer,
      $$CharacterBoardTableTableAnnotationComposer,
      $$CharacterBoardTableTableCreateCompanionBuilder,
      $$CharacterBoardTableTableUpdateCompanionBuilder,
      (
        CharacterBoardTableData,
        BaseReferences<
          _$AppDatabase,
          $CharacterBoardTableTable,
          CharacterBoardTableData
        >,
      ),
      CharacterBoardTableData,
      PrefetchHooks Function()
    >;
typedef $$CharacterConditionTableTableCreateCompanionBuilder =
    CharacterConditionTableCompanion Function({
      required String uuid,
      required String parentUuid,
      required int conditionId,
      required String name,
      required String desc,
      Value<String?> atributesIndexes,
      Value<String?> expertisesIndexes,
      Value<String?> dice,
      required int createdAt,
      required int updatedAt,
      required bool inAllExpertises,
      required bool inMana,
      required bool inAttack,
      required bool inDefense,
      required bool inDisplacment,
      Value<int> rowid,
    });
typedef $$CharacterConditionTableTableUpdateCompanionBuilder =
    CharacterConditionTableCompanion Function({
      Value<String> uuid,
      Value<String> parentUuid,
      Value<int> conditionId,
      Value<String> name,
      Value<String> desc,
      Value<String?> atributesIndexes,
      Value<String?> expertisesIndexes,
      Value<String?> dice,
      Value<int> createdAt,
      Value<int> updatedAt,
      Value<bool> inAllExpertises,
      Value<bool> inMana,
      Value<bool> inAttack,
      Value<bool> inDefense,
      Value<bool> inDisplacment,
      Value<int> rowid,
    });

class $$CharacterConditionTableTableFilterComposer
    extends Composer<_$AppDatabase, $CharacterConditionTableTable> {
  $$CharacterConditionTableTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get uuid => $composableBuilder(
    column: $table.uuid,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get parentUuid => $composableBuilder(
    column: $table.parentUuid,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get conditionId => $composableBuilder(
    column: $table.conditionId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get desc => $composableBuilder(
    column: $table.desc,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get atributesIndexes => $composableBuilder(
    column: $table.atributesIndexes,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get expertisesIndexes => $composableBuilder(
    column: $table.expertisesIndexes,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get dice => $composableBuilder(
    column: $table.dice,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get inAllExpertises => $composableBuilder(
    column: $table.inAllExpertises,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get inMana => $composableBuilder(
    column: $table.inMana,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get inAttack => $composableBuilder(
    column: $table.inAttack,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get inDefense => $composableBuilder(
    column: $table.inDefense,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get inDisplacment => $composableBuilder(
    column: $table.inDisplacment,
    builder: (column) => ColumnFilters(column),
  );
}

class $$CharacterConditionTableTableOrderingComposer
    extends Composer<_$AppDatabase, $CharacterConditionTableTable> {
  $$CharacterConditionTableTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get uuid => $composableBuilder(
    column: $table.uuid,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get parentUuid => $composableBuilder(
    column: $table.parentUuid,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get conditionId => $composableBuilder(
    column: $table.conditionId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get desc => $composableBuilder(
    column: $table.desc,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get atributesIndexes => $composableBuilder(
    column: $table.atributesIndexes,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get expertisesIndexes => $composableBuilder(
    column: $table.expertisesIndexes,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get dice => $composableBuilder(
    column: $table.dice,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get inAllExpertises => $composableBuilder(
    column: $table.inAllExpertises,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get inMana => $composableBuilder(
    column: $table.inMana,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get inAttack => $composableBuilder(
    column: $table.inAttack,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get inDefense => $composableBuilder(
    column: $table.inDefense,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get inDisplacment => $composableBuilder(
    column: $table.inDisplacment,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$CharacterConditionTableTableAnnotationComposer
    extends Composer<_$AppDatabase, $CharacterConditionTableTable> {
  $$CharacterConditionTableTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get uuid =>
      $composableBuilder(column: $table.uuid, builder: (column) => column);

  GeneratedColumn<String> get parentUuid => $composableBuilder(
    column: $table.parentUuid,
    builder: (column) => column,
  );

  GeneratedColumn<int> get conditionId => $composableBuilder(
    column: $table.conditionId,
    builder: (column) => column,
  );

  GeneratedColumn<String> get name =>
      $composableBuilder(column: $table.name, builder: (column) => column);

  GeneratedColumn<String> get desc =>
      $composableBuilder(column: $table.desc, builder: (column) => column);

  GeneratedColumn<String> get atributesIndexes => $composableBuilder(
    column: $table.atributesIndexes,
    builder: (column) => column,
  );

  GeneratedColumn<String> get expertisesIndexes => $composableBuilder(
    column: $table.expertisesIndexes,
    builder: (column) => column,
  );

  GeneratedColumn<String> get dice =>
      $composableBuilder(column: $table.dice, builder: (column) => column);

  GeneratedColumn<int> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<int> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);

  GeneratedColumn<bool> get inAllExpertises => $composableBuilder(
    column: $table.inAllExpertises,
    builder: (column) => column,
  );

  GeneratedColumn<bool> get inMana =>
      $composableBuilder(column: $table.inMana, builder: (column) => column);

  GeneratedColumn<bool> get inAttack =>
      $composableBuilder(column: $table.inAttack, builder: (column) => column);

  GeneratedColumn<bool> get inDefense =>
      $composableBuilder(column: $table.inDefense, builder: (column) => column);

  GeneratedColumn<bool> get inDisplacment => $composableBuilder(
    column: $table.inDisplacment,
    builder: (column) => column,
  );
}

class $$CharacterConditionTableTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $CharacterConditionTableTable,
          CharacterConditionTableData,
          $$CharacterConditionTableTableFilterComposer,
          $$CharacterConditionTableTableOrderingComposer,
          $$CharacterConditionTableTableAnnotationComposer,
          $$CharacterConditionTableTableCreateCompanionBuilder,
          $$CharacterConditionTableTableUpdateCompanionBuilder,
          (
            CharacterConditionTableData,
            BaseReferences<
              _$AppDatabase,
              $CharacterConditionTableTable,
              CharacterConditionTableData
            >,
          ),
          CharacterConditionTableData,
          PrefetchHooks Function()
        > {
  $$CharacterConditionTableTableTableManager(
    _$AppDatabase db,
    $CharacterConditionTableTable table,
  ) : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$CharacterConditionTableTableFilterComposer(
                $db: db,
                $table: table,
              ),
          createOrderingComposer: () =>
              $$CharacterConditionTableTableOrderingComposer(
                $db: db,
                $table: table,
              ),
          createComputedFieldComposer: () =>
              $$CharacterConditionTableTableAnnotationComposer(
                $db: db,
                $table: table,
              ),
          updateCompanionCallback:
              ({
                Value<String> uuid = const Value.absent(),
                Value<String> parentUuid = const Value.absent(),
                Value<int> conditionId = const Value.absent(),
                Value<String> name = const Value.absent(),
                Value<String> desc = const Value.absent(),
                Value<String?> atributesIndexes = const Value.absent(),
                Value<String?> expertisesIndexes = const Value.absent(),
                Value<String?> dice = const Value.absent(),
                Value<int> createdAt = const Value.absent(),
                Value<int> updatedAt = const Value.absent(),
                Value<bool> inAllExpertises = const Value.absent(),
                Value<bool> inMana = const Value.absent(),
                Value<bool> inAttack = const Value.absent(),
                Value<bool> inDefense = const Value.absent(),
                Value<bool> inDisplacment = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => CharacterConditionTableCompanion(
                uuid: uuid,
                parentUuid: parentUuid,
                conditionId: conditionId,
                name: name,
                desc: desc,
                atributesIndexes: atributesIndexes,
                expertisesIndexes: expertisesIndexes,
                dice: dice,
                createdAt: createdAt,
                updatedAt: updatedAt,
                inAllExpertises: inAllExpertises,
                inMana: inMana,
                inAttack: inAttack,
                inDefense: inDefense,
                inDisplacment: inDisplacment,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String uuid,
                required String parentUuid,
                required int conditionId,
                required String name,
                required String desc,
                Value<String?> atributesIndexes = const Value.absent(),
                Value<String?> expertisesIndexes = const Value.absent(),
                Value<String?> dice = const Value.absent(),
                required int createdAt,
                required int updatedAt,
                required bool inAllExpertises,
                required bool inMana,
                required bool inAttack,
                required bool inDefense,
                required bool inDisplacment,
                Value<int> rowid = const Value.absent(),
              }) => CharacterConditionTableCompanion.insert(
                uuid: uuid,
                parentUuid: parentUuid,
                conditionId: conditionId,
                name: name,
                desc: desc,
                atributesIndexes: atributesIndexes,
                expertisesIndexes: expertisesIndexes,
                dice: dice,
                createdAt: createdAt,
                updatedAt: updatedAt,
                inAllExpertises: inAllExpertises,
                inMana: inMana,
                inAttack: inAttack,
                inDefense: inDefense,
                inDisplacment: inDisplacment,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ),
      );
}

typedef $$CharacterConditionTableTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $CharacterConditionTableTable,
      CharacterConditionTableData,
      $$CharacterConditionTableTableFilterComposer,
      $$CharacterConditionTableTableOrderingComposer,
      $$CharacterConditionTableTableAnnotationComposer,
      $$CharacterConditionTableTableCreateCompanionBuilder,
      $$CharacterConditionTableTableUpdateCompanionBuilder,
      (
        CharacterConditionTableData,
        BaseReferences<
          _$AppDatabase,
          $CharacterConditionTableTable,
          CharacterConditionTableData
        >,
      ),
      CharacterConditionTableData,
      PrefetchHooks Function()
    >;

class $AppDatabaseManager {
  final _$AppDatabase _db;
  $AppDatabaseManager(this._db);
  $$GrimoireTableTableTableManager get grimoireTable =>
      $$GrimoireTableTableTableManager(_db, _db.grimoireTable);
  $$MagicCharacterTableTableTableManager get magicCharacterTable =>
      $$MagicCharacterTableTableTableManager(_db, _db.magicCharacterTable);
  $$BoardTableTableTableManager get boardTable =>
      $$BoardTableTableTableManager(_db, _db.boardTable);
  $$BoardMaterialTableTableTableManager get boardMaterialTable =>
      $$BoardMaterialTableTableTableManager(_db, _db.boardMaterialTable);
  $$BoardSessionTableTableTableManager get boardSessionTable =>
      $$BoardSessionTableTableTableManager(_db, _db.boardSessionTable);
  $$BoardLinkTableTableTableManager get boardLinkTable =>
      $$BoardLinkTableTableTableManager(_db, _db.boardLinkTable);
  $$BoardPlayerTableTableTableManager get boardPlayerTable =>
      $$BoardPlayerTableTableTableManager(_db, _db.boardPlayerTable);
  $$BoardNoteTableTableTableManager get boardNoteTable =>
      $$BoardNoteTableTableTableManager(_db, _db.boardNoteTable);
  $$BoardCombatTableTableTableManager get boardCombatTable =>
      $$BoardCombatTableTableTableManager(_db, _db.boardCombatTable);
  $$MenaceTableTableTableManager get menaceTable =>
      $$MenaceTableTableTableManager(_db, _db.menaceTable);
  $$AdventureBackpackTableTableTableManager get adventureBackpackTable =>
      $$AdventureBackpackTableTableTableManager(
        _db,
        _db.adventureBackpackTable,
      );
  $$EquipmentTableTableTableManager get equipmentTable =>
      $$EquipmentTableTableTableManager(_db, _db.equipmentTable);
  $$AmmunitionTableTableTableManager get ammunitionTable =>
      $$AmmunitionTableTableTableManager(_db, _db.ammunitionTable);
  $$ArmorTableTableTableManager get armorTable =>
      $$ArmorTableTableTableManager(_db, _db.armorTable);
  $$BackpackTableTableTableManager get backpackTable =>
      $$BackpackTableTableTableManager(_db, _db.backpackTable);
  $$GeneralItemTableTableTableManager get generalItemTable =>
      $$GeneralItemTableTableTableManager(_db, _db.generalItemTable);
  $$GeneralSkillTableTableTableManager get generalSkillTable =>
      $$GeneralSkillTableTableTableManager(_db, _db.generalSkillTable);
  $$MagicMenaceTableTableTableManager get magicMenaceTable =>
      $$MagicMenaceTableTableTableManager(_db, _db.magicMenaceTable);
  $$SaddlebagTableTableTableManager get saddlebagTable =>
      $$SaddlebagTableTableTableManager(_db, _db.saddlebagTable);
  $$ShieldTableTableTableManager get shieldTable =>
      $$ShieldTableTableTableManager(_db, _db.shieldTable);
  $$TibarsTableTableTableManager get tibarsTable =>
      $$TibarsTableTableTableManager(_db, _db.tibarsTable);
  $$WeaponTableTableTableManager get weaponTable =>
      $$WeaponTableTableTableManager(_db, _db.weaponTable);
  $$ActionTableTableTableManager get actionTable =>
      $$ActionTableTableTableManager(_db, _db.actionTable);
  $$ActionHandToHandTableTableTableManager get actionHandToHandTable =>
      $$ActionHandToHandTableTableTableManager(_db, _db.actionHandToHandTable);
  $$ActionDistanceAttackTableTableTableManager get actionDistanceAttackTable =>
      $$ActionDistanceAttackTableTableTableManager(
        _db,
        _db.actionDistanceAttackTable,
      );
  $$ExpertiseTableTableTableManager get expertiseTable =>
      $$ExpertiseTableTableTableManager(_db, _db.expertiseTable);
  $$MenaceLinkBoardTableTableTableManager get menaceLinkBoardTable =>
      $$MenaceLinkBoardTableTableTableManager(_db, _db.menaceLinkBoardTable);
  $$ConfigTableTableTableManager get configTable =>
      $$ConfigTableTableTableManager(_db, _db.configTable);
  $$CharacterTableTableTableManager get characterTable =>
      $$CharacterTableTableTableManager(_db, _db.characterTable);
  $$ClasseCharacterTableTableTableManager get classeCharacterTable =>
      $$ClasseCharacterTableTableTableManager(_db, _db.classeCharacterTable);
  $$OriginTableTableTableManager get originTable =>
      $$OriginTableTableTableManager(_db, _db.originTable);
  $$PowerTableTableTableManager get powerTable =>
      $$PowerTableTableTableManager(_db, _db.powerTable);
  $$CharacterBoardTableTableTableManager get characterBoardTable =>
      $$CharacterBoardTableTableTableManager(_db, _db.characterBoardTable);
  $$CharacterConditionTableTableTableManager get characterConditionTable =>
      $$CharacterConditionTableTableTableManager(
        _db,
        _db.characterConditionTable,
      );
}
